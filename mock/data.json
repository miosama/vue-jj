{
  "articles": [
    {
      "articleID": 1,
      "type": 1,
      "title": "HTTP从入门到放弃",
      "publishTime": "2018年 04月 18日",
      "praise": "187",
      "author": "henryzp",
      "tag": ["Node.js"],
      "authorImg": "https://user-gold-cdn.xitu.io/2016/11/29/4b1e6543001f90200bc76a6803fc7f7a?imageView2/1/w/100/h/100/q/85/interlace/1&quot",
      "comment": [
        {
          "username": "鸠摩智",
          "commentTime": "4天前",
          "commentText": "大佬，受我一拜",
          "admire":"0",
          "commentImg":"https://user-gold-cdn.xitu.io/2018/4/12/162b8931ddb5684e?imageView2/1/w/100/h/100/q/85/interlace/1"
        },
        {
          "username": "Aemple",
          "commentTime": "5天前",
          "commentText": "来  大佬  互相关注一波",
          "admire":"0",
          "commentImg":"https://user-gold-cdn.xitu.io/2018/4/3/1628c1bfdf460229?imageView2/1/w/100/h/100/q/85/interlace/1"
        }
      ],
      "preview":"首部字段名说明个人觉得只要了解请求首部及响应首部即可。其中响应首部中的range（可以做断点续传，会在下文提及），还有缓存（ETag），这些是必须要掌握的知识。 我们通过翻源码，会发现上面两种写法的一致性： 可以通过它来处理请求的url，简单demo如下： 在上一篇的最后内容中，有提及req的一些",
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">基本知识</h2>\n<ul>\n<li>请求的一方叫客户端，响应的一方叫服务器端</li>\n<li>通过请求和响应达成通信</li>\n<li>HTTP是一种不保存状态的协议</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-1\">请求报文</h3>\n<p></p><figure><img alt=\"alt\" class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d9018fd31c9bd?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"594\" data-height=\"285\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d9018fd31c9bd?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>常见的方法有：</p>\n<ul>\n<li>GET 获取资源</li>\n<li>POST 向服务器端发送数据，传输实体主体</li>\n<li>PUT 传输文件</li>\n<li>HEAD 获取报文首部</li>\n<li>DELETE 删除文件</li>\n<li>OPTIONS 询问支持的方法</li>\n<li>TRACE 追踪路径</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-2\">响应报文</h3>\n<p></p><figure><img alt=\"alt\" class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d9018fd1280e5?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"503\" data-height=\"270\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d9018fd1280e5?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-3\">状态码</h3>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td>Informational(信息性状态码</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success(成功状态码)</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection(重定向)</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error(客户端错误状态码)</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error(服务器错误状态吗)</td>\n</tr>\n</tbody>\n</table>\n<h4 class=\"heading\" data-id=\"heading-4\">2XX 成功</h4>\n<ul>\n<li>200(OK 客户端发过来的数据被正常处理</li>\n<li>204(Not Content 正常响应，没有实体</li>\n<li>206(Partial Content 范围请求，返回部分数据，响应报文中由Content-Range指定实体内容</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-5\">3XX 重定向</h4>\n<ul>\n<li>301(Moved Permanently) 永久重定向</li>\n<li>302(Found) 临时重定向，规范要求\u001d方法名不变，但是都会改变</li>\n<li>303(See Other) 和302类似，但必须用GET方法</li>\n<li>304(Not Modified) 状态未改变\b 配合(If-Match、If-- Modified-Since、If-None_Match、If-Range、If-Unmodified-Since)</li>\n<li>307(Temporary Redirect) 临时重定向，不该改变请求方法</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-6\">4XX 客户端错误</h4>\n<ul>\n<li>400(Bad Request) 请求报文语法错误</li>\n<li>401 (unauthorized) 需要认证</li>\n<li>403(Forbidden) 服务器拒绝访问对应的资源</li>\n<li>404(Not Found) 服务器上无法找到资源</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-7\">5XX 服务器端错误</h4>\n<ul>\n<li>500(Internal Server Error)服务器故障</li>\n<li>503(Service Unavailable) 服务器处于超负载或正在停机维护</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-8\">headers</h3>\n<h4 class=\"heading\" data-id=\"heading-9\">通用首部字段</h4>\n<table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cache-Control</td>\n<td>控制缓存行为</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>链接的管理</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>报文日期</td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>报文指令</td>\n</tr>\n<tr>\n<td>Trailer</td>\n<td>报文尾部的首部</td>\n</tr>\n<tr>\n<td>Trasfer-Encoding</td>\n<td>指定报文主体的传输编码方式</td>\n</tr>\n<tr>\n<td>Upgrade</td>\n<td>升级为其他协议</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>代理服务器信息</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>错误通知</td>\n</tr>\n</tbody>\n</table>\n<h4 class=\"heading\" data-id=\"heading-10\">请求首部字段</h4>\n<table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept</td>\n<td>用户代理可处理的媒体类型</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>优先的字符集</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>优先的编码</td>\n</tr>\n<tr>\n<td>Accept-Langulage</td>\n<td>优先的语言</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>Web认证信息</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>期待服务器的特定行为</td>\n</tr>\n<tr>\n<td>From</td>\n<td>用户的电子邮箱地址</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>请求资源所在的服务器</td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>比较实体标记</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>比较资源的更新时间</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>比较实体标记</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>资源未更新时发送实体Byte的范围请求</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>比较资源的更新时间(和If-Modified-Since相反)</td>\n</tr>\n<tr>\n<td>Max-Forwards</td>\n<td>最大传输跳数</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>代理服务器需要客户端认证</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>实体字节范围请求</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>请求中的URI的原始获取方</td>\n</tr>\n<tr>\n<td>TE</td>\n<td>传输编码的优先级</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>HTTP客户端程序的信息</td>\n</tr>\n</tbody>\n</table>\n<h4 class=\"heading\" data-id=\"heading-11\">响应首部字段</h4>\n<table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept-Ranges</td>\n<td>是否接受字节范围</td>\n</tr>\n<tr>\n<td>Age</td>\n<td>资源的创建时间</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>资源的匹配信息</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>客户端重定向至指定的URI</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>代理服务器对客户端的认证信息</td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>再次发送请求的时机</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>服务器的信息</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>代理服务器缓存的管理信息</td>\n</tr>\n<tr>\n<td>www-Authenticate</td>\n<td>服务器对客户端的认证</td>\n</tr>\n</tbody>\n</table>\n<h4 class=\"heading\" data-id=\"heading-12\">实体首部字段</h4>\n<table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>资源可支持的HTTP方法</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>实体的编码方式</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>实体的自然语言</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>实体的内容大小(字节为单位)</td>\n</tr>\n<tr>\n<td>Content-Location</td>\n<td>替代对应资源的URI</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>实体的报文摘要</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>实体的位置范围</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>实体主体的媒体类型</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体过期时间</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>资源的最后修改时间</td>\n</tr>\n</tbody>\n</table>\n<p>个人觉得只要了解请求首部及响应首部即可。其中响应首部中的range（可以做断点续传，会在下文提及），还有缓存（ETag），这些是必须要掌握的知识。</p>\n<h2 class=\"heading\" data-id=\"heading-13\">创建http</h2>\n<ul>\n<li>方式一：</li>\n</ul>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n<span class=\"hljs-keyword\">const</span> server = http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">req,res</span>)</span>{\n    res.end(<span class=\"hljs-number\">123</span>);\n});\nserver.listen(<span class=\"hljs-number\">8080</span>);\n</code></pre><ul>\n<li>方式二：</li>\n</ul>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>); \n<span class=\"hljs-keyword\">const</span> server = http.createServer();\n<span class=\"hljs-comment\">// req是请求 是一个可读流 = socket</span>\n<span class=\"hljs-comment\">// res是响应 是一个可写流</span>\nserver.on(<span class=\"hljs-string\">'request'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">req,res</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> method = req.method;\n    <span class=\"hljs-keyword\">let</span> httpVersion  = req.httpVersion;\n    <span class=\"hljs-keyword\">let</span> url = req.url;\n    <span class=\"hljs-keyword\">let</span> headers = req.headers; <span class=\"hljs-comment\">// 请求头的名字都是小写的</span>\n    <span class=\"hljs-built_in\">console</span>.log(method,httpVersion,url,headers);\n    <span class=\"hljs-comment\">// 如果数据 大于64k data事件可能会触发多次</span>\n    <span class=\"hljs-keyword\">let</span> buffers = [];\n    <span class=\"hljs-comment\">// 如果没有请求体 不会走on('data'),没有请求体也会触发end事件</span>\n    req.on(<span class=\"hljs-string\">'data'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>)</span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)\n        buffers.push(data);\n    });\n\n    req.on(<span class=\"hljs-string\">'end'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n        <span class=\"hljs-built_in\">console</span>.log(Buffer.concat(buffers).toString());\n        <span class=\"hljs-comment\">// socket.write socket.end</span>\n        res.write(<span class=\"hljs-string\">'hello'</span>);\n        res.end(<span class=\"hljs-string\">'world'</span>);\n    });\n});\n<span class=\"hljs-comment\">// 监听请求的到来</span>\nserver.on(<span class=\"hljs-string\">'connection'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">socket</span>)</span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'建立连接'</span>);\n});\nserver.on(<span class=\"hljs-string\">'close'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'服务端关闭'</span>)\n})\nserver.on(<span class=\"hljs-string\">'error'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>)</span>{\n    <span class=\"hljs-built_in\">console</span>.log(err);\n});\nserver.listen(<span class=\"hljs-number\">8080</span>);\n</code></pre><p>我们通过翻源码，会发现上面两种写法的一致性：</p>\n<p></p><figure><img alt=\"alt\" class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d9018fe2f4b35?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"744\" data-height=\"136\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d9018fe2f4b35?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img alt=\"alt\" class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d9018fe391430?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1160\" data-height=\"300\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d9018fe391430?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-14\">url模块</h3>\n<p>可以通过它来处理请求的url，简单demo如下：</p>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> url = require(<span class=\"hljs-string\">'url'</span>);\n<span class=\"hljs-built_in\">let</span> u = <span class=\"hljs-string\">'http://www.baidu.com:80/abc/index.html?a=1&amp;b=2#hash'</span>;\n\n// 可以将查询字符串转化成对象\n<span class=\"hljs-built_in\">let</span> urlObj = url.parse(u,<span class=\"hljs-literal\">true</span>);\nconsole.log(urlObj.query); // 查询字符串\nconsole.log(urlObj.pathname); //  路径\n</code></pre><h3 class=\"heading\" data-id=\"heading-15\">res</h3>\n<p>在上一篇的最后内容中，有提及req的一些属性，那么我们来看一下res有哪些方法吧。</p>\n<h4 class=\"heading\" data-id=\"heading-16\">write &amp;&amp; end</h4>\n<p>可以使用write方法发送响应内容</p>\n<pre><code class=\"hljs js\" lang=\"js\">response.write(chunk,[encoding]);\nresponse.end([chunk],[encoding]);\n</code></pre><h4 class=\"heading\" data-id=\"heading-17\">writeHead</h4>\n<pre><code class=\"hljs js\" lang=\"js\">res.writeHead(statusCode, [headers]);\n</code></pre><h4 class=\"heading\" data-id=\"heading-18\">setHeader</h4>\n<pre><code class=\"hljs js\" lang=\"js\">res.setHeader(key, value);\n</code></pre><p>它与writeHead的区别是：它不会真正的把响应头写给客户端。</p>\n<p>即在writeHeader之后，再执行setHeader是会报错的。</p>\n<h2 class=\"heading\" data-id=\"heading-19\">应用</h2>\n<h3 class=\"heading\" data-id=\"heading-20\">客户端连接</h3>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-comment\">// server端</span>\n<span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n<span class=\"hljs-keyword\">const</span> server = http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">req,res</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> contentType = req.headers[<span class=\"hljs-string\">'content-type'</span>];\n    <span class=\"hljs-keyword\">let</span> buffers = [];\n    req.on(<span class=\"hljs-string\">'data'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">chunk</span>)</span>{\n        buffers.push(chunk);\n    });\n    req.on(<span class=\"hljs-string\">'end'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n        <span class=\"hljs-keyword\">let</span> content = Buffer.concat(buffers).toString();\n        <span class=\"hljs-keyword\">if</span>(contentType === <span class=\"hljs-string\">'application/json'</span>){\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">JSON</span>.parse(content).name)\n        }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(contentType === <span class=\"hljs-string\">'application/x-www-form-urlencoded'</span>){\n            <span class=\"hljs-keyword\">let</span> queryString = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'querystring'</span>);\n            <span class=\"hljs-built_in\">console</span>.log(queryString.parse(content).age)\n        }\n        res.end(<span class=\"hljs-string\">'hello'</span>);\n    });\n});\nserver.listen(<span class=\"hljs-number\">4000</span>);\n</code></pre><pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-comment\">// client</span>\n<span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n<span class=\"hljs-keyword\">const</span> options = {\n    <span class=\"hljs-attr\">hostname</span>:<span class=\"hljs-string\">'localhost'</span>,\n    <span class=\"hljs-attr\">port</span>:<span class=\"hljs-number\">4000</span>,\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'/'</span>,\n    <span class=\"hljs-attr\">method</span>:<span class=\"hljs-string\">'get'</span>,\n    <span class=\"hljs-comment\">// 告诉服务端我当前要给你发什么样的数据</span>\n    headers:{\n        <span class=\"hljs-string\">'Content-Type'</span>:<span class=\"hljs-string\">'application/x-www-form-urlencoded'</span>,\n        <span class=\"hljs-string\">'Content-Length'</span>:<span class=\"hljs-number\">5</span>\n    }\n}\n<span class=\"hljs-keyword\">const</span> req = http.request(options, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">res</span>) </span>{\n    res.on(<span class=\"hljs-string\">'data'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">chunk</span>)</span>{\n        <span class=\"hljs-built_in\">console</span>.log(chunk.toString());\n    });\n});\nreq.end(<span class=\"hljs-string\">'age=1'</span>);\n</code></pre><p>需要注意的是客户端请求需要传递Content-Length，不然会有问题。</p>\n<p>当然在实际工作中，可能直接就用下面两个npm包了（通常用promise的那个）：</p>\n<p></p><figure><img alt=\"alt\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d9019025af597?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"615\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;615&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-21\">多语言切换</h3>\n<p>可以通过Accept-Language检测浏览器的语言</p>\n<ul>\n<li>请求头格式 Accept-Language: Accept-Language:zh-CN,zh;q=0.9</li>\n<li>响应头格式 Content-Language:zh-CN</li>\n</ul>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> pack = {\n    <span class=\"hljs-string\">'en'</span>: { <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'english'</span> },\n    <span class=\"hljs-string\">'zh-CN'</span>: { <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'中文'</span> }\n}\n<span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n<span class=\"hljs-keyword\">const</span> server = http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">req, res</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> lan = <span class=\"hljs-string\">'en'</span>;\n    <span class=\"hljs-keyword\">let</span> language = req.headers[<span class=\"hljs-string\">'accept-language'</span>];\n    <span class=\"hljs-keyword\">if</span> (language) {\n        lan = language.split(<span class=\"hljs-string\">','</span>).map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) </span>{\n            <span class=\"hljs-keyword\">let</span> values = item.split(<span class=\"hljs-string\">';'</span>);\n            <span class=\"hljs-keyword\">return</span> {\n                <span class=\"hljs-attr\">name</span>: values[<span class=\"hljs-number\">0</span>],\n                <span class=\"hljs-attr\">q</span>: values[<span class=\"hljs-number\">1</span>] ? <span class=\"hljs-built_in\">parseInt</span>(values[<span class=\"hljs-number\">1</span>]) : <span class=\"hljs-number\">1</span>\n            }\n        }).sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">lang1, lang2</span>) =&gt;</span> lang2.q - lang1.q).shift().name;\n        <span class=\"hljs-built_in\">console</span>.log(lan)\n    }\n    res.end(pack[lan] ? pack[lan].title : pack[<span class=\"hljs-string\">'en'</span>].title);\n}).listen(<span class=\"hljs-number\">4000</span>);\n</code></pre><h3 class=\"heading\" data-id=\"heading-22\">图片防盗链</h3>\n<p>这个QQ空间图片比较常见，引用过去之后会变成裂图。</p>\n<p>实现原理：</p>\n<ul>\n<li>从一个网站跳转，或者网页引用到某个资源文件时，HTTP请求中带有Referer表示来源网页的URL</li>\n<li>通过检查请求头中的Referer来判断来源网页的域名</li>\n<li>如果来源域名不在白名单内，则返回错误提示\n用浏览器直接访问图片地址是没有referer的</li>\n</ul>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n<span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'url'</span>);\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n<span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">const</span> root = path.join(__dirname, <span class=\"hljs-string\">'public'</span>);\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">removePort</span>(<span class=\"hljs-params\">host</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> host.split(<span class=\"hljs-string\">':'</span>)[<span class=\"hljs-number\">0</span>]\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getHostName</span>(<span class=\"hljs-params\">urlAddr</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> { host } = url.parse(urlAddr);\n    <span class=\"hljs-keyword\">return</span> removePort(host);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">request</span>(<span class=\"hljs-params\">req, res</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> refer = req.headers[<span class=\"hljs-string\">'referer'</span>] || req.headers[<span class=\"hljs-string\">'referrer'</span>];\n    <span class=\"hljs-keyword\">if</span> (refer) {\n        <span class=\"hljs-keyword\">let</span> referHost = getHostName(refer);\n        <span class=\"hljs-keyword\">let</span> host = removePort(req.headers[<span class=\"hljs-string\">'host'</span>]);\n        <span class=\"hljs-keyword\">if</span> (referHost != host) {\n            sendForbidden(req, res);\n        } <span class=\"hljs-keyword\">else</span> {\n            serve(req, res);\n        }\n    } <span class=\"hljs-keyword\">else</span> {\n        serve(req, res);\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">serve</span>(<span class=\"hljs-params\">req, res</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> {\n        pathname\n    } = url.parse(req.url);\n    <span class=\"hljs-keyword\">let</span> filepath = path.join(root, pathname);\n    <span class=\"hljs-built_in\">console</span>.log(req.url, filepath);\n\n    fs.stat(filepath, (err, stat) =&gt; {\n        <span class=\"hljs-keyword\">if</span> (err) {\n            res.end(<span class=\"hljs-string\">'Not Found'</span>);\n        } <span class=\"hljs-keyword\">else</span> {\n            fs.createReadStream(filepath).pipe(res);\n        }\n    });\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendForbidden</span>(<span class=\"hljs-params\">req, res</span>) </span>{\n    res.end(<span class=\"hljs-string\">'防盗链'</span>);\n}\n<span class=\"hljs-keyword\">const</span> server = http.createServer();\nserver.on(<span class=\"hljs-string\">'request'</span>, request);\nserver.listen(<span class=\"hljs-number\">8080</span>);\n</code></pre><h3 class=\"heading\" data-id=\"heading-23\">代理服务器</h3>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2FAnker%2Fp%2F6056540.html\" rel=\"nofollow noopener noreferrer\">正向代理与反向代理【总结】</a></p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">let</span> httpProxy = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http-proxy'</span>);\n<span class=\"hljs-keyword\">let</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n<span class=\"hljs-keyword\">let</span> proxy = httpProxy.createProxyServer();\n\nhttp.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">req, res</span>) </span>{\n    proxy.web(req, res, {\n        <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">'http://localhost:8000'</span>\n    });\n    proxy.on(<span class=\"hljs-string\">'error'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'出错了'</span>);\n        res.end(err.toString());\n    });\n}).listen(<span class=\"hljs-number\">8080</span>);\n</code></pre><p>上面代码表示的是请求<code>localhost:8080</code>时，转发到<code>http://localhost:8000</code>。像webpack-dev-server的转发请求模块：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fchimurai%2Fhttp-proxy-middleware\" rel=\"nofollow noopener noreferrer\">http-proxy-middleware</a>，就是使用到了<code>http-proxy</code>。</p>\n<h3 class=\"heading\" data-id=\"heading-24\">虚拟主机</h3>\n<p>通过Host实现多个网站共用一个端口,多个网站共用一个服务器</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n<span class=\"hljs-keyword\">const</span> httpProxy = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http-proxy'</span>);\n<span class=\"hljs-keyword\">const</span> proxy = httpProxy.createProxyServer();\n\n<span class=\"hljs-keyword\">let</span> hosts = {\n    <span class=\"hljs-string\">'www.test1.com'</span>: <span class=\"hljs-string\">'http://localhost:8000'</span>,\n    <span class=\"hljs-string\">'www.test2.com'</span>: <span class=\"hljs-string\">'http://localhost:9000'</span>\n}\nhttp.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">req, res</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> host = req.headers[<span class=\"hljs-string\">'host'</span>];\n    host = host.split(<span class=\"hljs-string\">':'</span>)[<span class=\"hljs-number\">0</span>];\n    <span class=\"hljs-keyword\">let</span> target = hosts[host];\n    proxy.web(req, res, {\n        target\n    });\n}).listen(<span class=\"hljs-number\">80</span>);\n</code></pre><h2 class=\"heading\" data-id=\"heading-25\">Range</h2>\n<blockquote>\n<p>当用户在听一首歌的时候，如果听到一半（网络下载了一半），网络断掉了，用户需要继续听的时候，文件服务器不支持断点的话，则用户需要重新下载这个文件。而Range支持的话，客户端应该记录了之前已经读取的文件范围，网络恢复之后，则向服务器发送读取剩余Range的请求，服务端只需要发送客户端请求的那部分内容，而不用整个文件发送回客户端，以此节省网络带宽。</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-26\">获取部分内容的范围请求</h3>\n<p>为了实现中断恢复下载的需求，需要能下载指定下载的实体范围</p>\n<ul>\n<li>请求头中的Range来指定 资源的byte范围</li>\n<li>响应会返回状态码206响应报文</li>\n<li>对于多重范围的范围请求，响应会在首部字段Content-Type中标明multipart/byteranges</li>\n</ul>\n<p></p><figure><img alt=\"alt\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d9018fe1e6c83?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"592\" data-height=\"451\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;592&quot; height=&quot;451&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img alt=\"alt\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d9019929edf64?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"581\" data-height=\"296\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;581&quot; height=&quot;296&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-27\">如何应用</h3>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-comment\">// 服务端</span>\n<span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n<span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n<span class=\"hljs-keyword\">const</span> { promisify } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'util'</span>);\n<span class=\"hljs-keyword\">const</span> stat = promisify(fs.stat);\n<span class=\"hljs-comment\">// 客户端要发一个头Range:bytes=0-10</span>\n<span class=\"hljs-comment\">// 服务端返回一个头</span>\n<span class=\"hljs-comment\">// Accept-Ranges:bytes</span>\n<span class=\"hljs-comment\">// Content-Range:0-10/总大小</span>\n<span class=\"hljs-keyword\">const</span> server = http.createServer(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">req, res</span>) </span>{\n\n    <span class=\"hljs-keyword\">let</span> p = path.join(__dirname, <span class=\"hljs-string\">'content.txt'</span>);\n    <span class=\"hljs-comment\">// 判断当前文件的大小</span>\n    <span class=\"hljs-keyword\">let</span> statObj = <span class=\"hljs-keyword\">await</span> stat(p);\n    <span class=\"hljs-keyword\">let</span> start = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">let</span> end = statObj.size - <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 读流是包前又包后的</span>\n    <span class=\"hljs-keyword\">let</span> total = end\n    <span class=\"hljs-keyword\">let</span> range = req.headers[<span class=\"hljs-string\">'range'</span>];\n    <span class=\"hljs-keyword\">if</span> (range) {\n        <span class=\"hljs-comment\">// 告诉它支持范围请求</span>\n        res.setHeader(<span class=\"hljs-string\">'Accept-Ranges'</span>,<span class=\"hljs-string\">'bytes'</span>);\n        <span class=\"hljs-comment\">// ['匹配的字符串','第一个分组']</span>\n        <span class=\"hljs-keyword\">let</span> result = range.match(<span class=\"hljs-regexp\">/bytes=(\\d*)-(\\d*)/</span>);\n        start = result[<span class=\"hljs-number\">1</span>]?<span class=\"hljs-built_in\">parseInt</span>(result[<span class=\"hljs-number\">1</span>]):start;\n        end = result[<span class=\"hljs-number\">2</span>]?<span class=\"hljs-built_in\">parseInt</span>(result[<span class=\"hljs-number\">2</span>])<span class=\"hljs-number\">-1</span>:end;\n        <span class=\"hljs-comment\">// 获取成功并且文件总大小是多少</span>\n        res.setHeader(<span class=\"hljs-string\">'Content-Range'</span>,<span class=\"hljs-string\">`<span class=\"hljs-subst\">${start}</span>-<span class=\"hljs-subst\">${end}</span>/<span class=\"hljs-subst\">${total}</span>`</span>)\n    }\n    res.setHeader(<span class=\"hljs-string\">'Content-Type'</span>, <span class=\"hljs-string\">'text/plain;charset=utf8'</span>);\n    fs.createReadStream(p, { start, end }).pipe(res);\n});\nserver.listen(<span class=\"hljs-number\">3000</span>);\n</code></pre><pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-comment\">// 客户端</span>\n<span class=\"hljs-keyword\">const</span> options = {\n    <span class=\"hljs-attr\">hostname</span>: <span class=\"hljs-string\">'localhost'</span>,\n    <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">3000</span>,\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'/'</span>,\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'GET'</span>\n}\n<span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n<span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n<span class=\"hljs-keyword\">const</span> ws = fs.createWriteStream(<span class=\"hljs-string\">'./download.txt'</span>);\n<span class=\"hljs-keyword\">let</span> pause = <span class=\"hljs-literal\">false</span>;\n<span class=\"hljs-keyword\">let</span> start = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-comment\">// 监听键盘事件，如果有输入p，则暂停</span>\nprocess.stdin.on(<span class=\"hljs-string\">'data'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">chunk</span>) </span>{\n    chunk = chunk.toString();\n    <span class=\"hljs-keyword\">if</span> (chunk.includes(<span class=\"hljs-string\">'p'</span>)) {\n        pause = <span class=\"hljs-literal\">true</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        pause = <span class=\"hljs-literal\">false</span>;\n        download();\n    }\n});\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">download</span>(<span class=\"hljs-params\"></span>) </span>{\n    options.headers = {\n        <span class=\"hljs-attr\">Range</span>: <span class=\"hljs-string\">`bytes=<span class=\"hljs-subst\">${start}</span>-<span class=\"hljs-subst\">${start + <span class=\"hljs-number\">10</span>}</span>`</span>\n    }\n    start += <span class=\"hljs-number\">10</span>;\n    <span class=\"hljs-comment\">// 发请求</span>\n    <span class=\"hljs-comment\">// 0-10</span>\n    http.get(options, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">res</span>) </span>{\n        <span class=\"hljs-keyword\">let</span> range = res.headers[<span class=\"hljs-string\">'content-range'</span>];\n        <span class=\"hljs-keyword\">let</span> total = range.split(<span class=\"hljs-string\">'/'</span>)[<span class=\"hljs-number\">1</span>];\n        <span class=\"hljs-keyword\">let</span> buffers = [];\n        res.on(<span class=\"hljs-string\">'data'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">chunk</span>) </span>{\n            buffers.push(chunk);\n        });\n        res.on(<span class=\"hljs-string\">'end'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n            <span class=\"hljs-comment\">//将获取的数据写入到文件中</span>\n            ws.write(Buffer.concat(buffers));\n            setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n                <span class=\"hljs-keyword\">if</span> (pause === <span class=\"hljs-literal\">false</span> &amp;&amp; start &lt; total) {\n                    download();\n                }\n            }, <span class=\"hljs-number\">1000</span>)\n        })\n    })\n}\ndownload();\n</code></pre><h2 class=\"heading\" data-id=\"heading-28\">压缩</h2>\n<p>node的<a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fnodejs.cn%2Fapi%2Fzlib.html\" rel=\"nofollow noopener noreferrer\">压缩文档</a></p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>)\n<span class=\"hljs-keyword\">const</span> zlib = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'zlib'</span>);\n\n<span class=\"hljs-comment\">// 压缩</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">zip</span>(<span class=\"hljs-params\">src</span>)</span>{\n    <span class=\"hljs-comment\">// 压缩流 转化流</span>\n    <span class=\"hljs-keyword\">const</span> gzip = zlib.createGzip();\n    fs.createReadStream(src).pipe(gzip).pipe(fs.createWriteStream(src+<span class=\"hljs-string\">'.gz'</span>))\n}\n<span class=\"hljs-comment\">// zip(path.join(__dirname,'./1.txt'));</span>\n\n<span class=\"hljs-comment\">// 解压</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">unzip</span>(<span class=\"hljs-params\">src</span>)</span>{\n    <span class=\"hljs-keyword\">const</span> gunzip = zlib.createGunzip();\n    fs.createReadStream(src)\n    .pipe(gunzip)\n    .pipe(fs.createWriteStream(path.basename(src,<span class=\"hljs-string\">'.gz'</span>)));\n}\n<span class=\"hljs-comment\">// unzip(path.join(__dirname,'./1.txt.gz'));</span>\n</code></pre><p>在HTTP中，我们可以根据请求头来判断要不要对传输的内容进行压缩。</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n<span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">const</span> zlib = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'zlib'</span>);\nhttp.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">req, res</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> p = path.join(__dirname, <span class=\"hljs-string\">'1.txt'</span>);\n    <span class=\"hljs-comment\">// Accept-Encoding: gzip, deflate, br 客户端</span>\n    <span class=\"hljs-keyword\">const</span> header = req.headers[<span class=\"hljs-string\">'accept-encoding'</span>];\n    res.setHeader(<span class=\"hljs-string\">'Content-Type'</span>,<span class=\"hljs-string\">'text/html;charset=utf8'</span>);\n    <span class=\"hljs-keyword\">if</span> (header) {\n        <span class=\"hljs-keyword\">if</span> (header.match(<span class=\"hljs-regexp\">/\\bgzip\\b/</span>)) {\n            <span class=\"hljs-keyword\">const</span> gzip = zlib.createGzip();\n            res.setHeader(<span class=\"hljs-string\">'Content-Encoding'</span>,<span class=\"hljs-string\">'gzip'</span>);\n            fs.createReadStream(p).pipe(gzip).pipe(res);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (header.match(<span class=\"hljs-regexp\">/\\bdeflate\\b/</span>)) {\n            <span class=\"hljs-keyword\">const</span> deflate = zlib.createDeflate();\n            res.setHeader(<span class=\"hljs-string\">'Content-Encoding'</span>,<span class=\"hljs-string\">'deflate'</span>)\n            fs.createReadStream(p).pipe(deflate).pipe(res);\n        }<span class=\"hljs-keyword\">else</span>{\n            fs.createReadStream(p).pipe(res);\n        }\n    }<span class=\"hljs-keyword\">else</span>{\n        fs.createReadStream(p).pipe(res);\n    }\n}).listen(<span class=\"hljs-number\">8080</span>);\n</code></pre><h2 class=\"heading\" data-id=\"heading-29\">加密</h2>\n<h3 class=\"heading\" data-id=\"heading-30\">crypto</h3>\n<blockquote>\n<p>crypto是node.js中实现加密和解密的模块 在node.js中，使用OpenSSL类库作为内部实现加密解密的手段 OpenSSL是一个经过严格测试的可靠的加密与解密算法的实现工具</p>\n</blockquote>\n<h3 class=\"heading\" data-id=\"heading-31\">散列(哈希)算法</h3>\n<p>散列算法也叫哈希算法，用来把任意长度的输入变换成固定长度的输出,常见的有md5,sha1等，它有以下特点：</p>\n<ul>\n<li>相同的输入会产生相同的输出</li>\n<li>不同的输出会产生不同的输出</li>\n<li>任意的输入长度输出长度是相同的</li>\n<li>不能从输出推算出输入的值</li>\n</ul>\n<h4 class=\"heading\" data-id=\"heading-32\">示例</h4>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">var</span> crypto = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'crypto'</span>);\n<span class=\"hljs-keyword\">var</span> md5 = crypto.createHash(<span class=\"hljs-string\">'md5'</span>);<span class=\"hljs-comment\">//返回哈希算法</span>\n<span class=\"hljs-keyword\">var</span> md5Sum = md5.update(<span class=\"hljs-string\">'hello'</span>);<span class=\"hljs-comment\">//指定要摘要的原始内容,可以在摘要被输出之前使用多次update方法来添加摘要内容</span>\n<span class=\"hljs-keyword\">var</span> result = md5Sum.digest(<span class=\"hljs-string\">'hex'</span>);<span class=\"hljs-comment\">//摘要输出，在使用digest方法之后不能再向hash对象追加摘要内容。</span>\n<span class=\"hljs-built_in\">console</span>.log(result);\n</code></pre><p>多次update</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">const</span> shasum = crypto.createHash(<span class=\"hljs-string\">'sha1'</span>);<span class=\"hljs-comment\">//返回sha1哈希算法</span>\n<span class=\"hljs-keyword\">const</span> rs = fs.createReadStream(<span class=\"hljs-string\">'./readme.txt'</span>);\nrs.on(<span class=\"hljs-string\">'data'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n    shasum.update(data);<span class=\"hljs-comment\">//指定要摘要的原始内容,可以在摘要被输出之前使用多次update方法来添加摘要内容</span>\n});\nrs.on(<span class=\"hljs-string\">'end'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">const</span> result = shasum.digest(<span class=\"hljs-string\">'hex'</span>);<span class=\"hljs-comment\">//摘要输出，在使用digest方法之后不能再向hash对象追加摘要内容。</span>\n    <span class=\"hljs-built_in\">console</span>.log(result);\n})\n</code></pre><h3 class=\"heading\" data-id=\"heading-33\">HMAC算法</h3>\n<p>HMAC算法将散列算法与一个密钥结合在一起，以阻止对签名完整性的破坏。</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> crypto = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'crypto'</span>);\n<span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n<span class=\"hljs-keyword\">const</span> m = crypto.createHmac(<span class=\"hljs-string\">'sha1'</span>, fs.readFileSync(path.join(__dirname,<span class=\"hljs-string\">'./content.txt'</span>))); <span class=\"hljs-comment\">//将content文件中的内容作为一个密钥</span>\nm.update(<span class=\"hljs-string\">'ok'</span>); \n<span class=\"hljs-built_in\">console</span>.log(m.digest(<span class=\"hljs-string\">'hex'</span>));\n</code></pre><h3 class=\"heading\" data-id=\"heading-34\">对应加密</h3>\n<p>blowfish算法是一种对称的加密算法,对称的意思就是加密和解密使用的是同一个密钥。</p>\n<p></p><figure><img alt=\"alt\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d901999693586?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"470\" data-height=\"400\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;470&quot; height=&quot;400&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>私钥生成方法：</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">openssl genrsa -out rsa_private.key 1024\n</code></pre><pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> crypto = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'crypto'</span>);\n<span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">'hello'</span>;\n<span class=\"hljs-keyword\">const</span> cipher = crypto.createCipher(<span class=\"hljs-string\">'blowfish'</span>, fs.readFileSync(path.join(__dirname, <span class=\"hljs-string\">'rsa_private.key'</span>)));\n<span class=\"hljs-keyword\">let</span> encry = cipher.update(str, <span class=\"hljs-string\">'utf8'</span>,<span class=\"hljs-string\">'hex'</span>);\nencry += cipher.final(<span class=\"hljs-string\">'hex'</span>);\n<span class=\"hljs-built_in\">console</span>.log(encry);\n\n<span class=\"hljs-comment\">// 对称解密</span>\n<span class=\"hljs-keyword\">const</span> deciper = crypto.createDecipher(<span class=\"hljs-string\">'blowfish'</span>, fs.readFileSync(path.join(__dirname, <span class=\"hljs-string\">'rsa_private.key'</span>)));\n<span class=\"hljs-keyword\">let</span> deEncry = deciper.update(encry, <span class=\"hljs-string\">'hex'</span>,<span class=\"hljs-string\">'utf8'</span>);\ndeEncry += deciper.final(<span class=\"hljs-string\">'utf8'</span>);\n<span class=\"hljs-built_in\">console</span>.log(deEncry);\n</code></pre><h3 class=\"heading\" data-id=\"heading-35\">非对称加密</h3>\n<ul>\n<li>非对称加密算法需要两个密钥：公开密钥(publickey)和私有密钥(privatekey)</li>\n<li>公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密,如果私钥加密，只能公钥解密</li>\n<li>因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法</li>\n</ul>\n<p></p><figure><img alt=\"alt\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d9019af7b884e?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"490\" data-height=\"211\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;490&quot; height=&quot;211&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>为私钥创建公钥</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">openssl rsa -in rsa_private.key -pubout -out rsa_public.key\n</code></pre><pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> crypto = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'crypto'</span>);\n<span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">let</span> key = fs.readFileSync(path.join(__dirname, <span class=\"hljs-string\">'rsa_private.key'</span>));\n<span class=\"hljs-keyword\">let</span> cert = fs.readFileSync(path.join(__dirname, <span class=\"hljs-string\">'rsa_public.key'</span>));\n<span class=\"hljs-keyword\">let</span> secret = crypto.publicEncrypt(cert, buffer);<span class=\"hljs-comment\">//公钥加密</span>\n<span class=\"hljs-keyword\">let</span> result = crypto.privateDecrypt(key, secret);<span class=\"hljs-comment\">//私钥解密</span>\n<span class=\"hljs-built_in\">console</span>.log(result.toString());\n</code></pre><h3 class=\"heading\" data-id=\"heading-36\">签名</h3>\n<p>在网络中，私钥的拥有者可以在一段数据被发送之前先对数据进行签名得到一个签名 通过网络把此数据发送给数据接收者之后，数据的接收者可以通过公钥来对该签名进行验证,以确保这段数据是私钥的拥有者所发出的原始数据，且在网络中的传输过程中未被修改。</p>\n<p></p><figure><img alt=\"alt\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d901a06048cf5?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"580\" data-height=\"253\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;580&quot; height=&quot;253&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">let</span> private = fs.readFileSync(path.join(__dirname, <span class=\"hljs-string\">'rsa_private.key'</span>), <span class=\"hljs-string\">'ascii'</span>);\n<span class=\"hljs-keyword\">let</span> public = fs.readFileSync(path.join(__dirname, <span class=\"hljs-string\">'rsa_public.key'</span>), <span class=\"hljs-string\">'ascii'</span>);\n<span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">'hello'</span>;\n<span class=\"hljs-keyword\">let</span> sign = crypto.createSign(<span class=\"hljs-string\">'RSA-SHA256'</span>);\nsign.update(str);\n<span class=\"hljs-keyword\">let</span> signed = sign.sign(private, <span class=\"hljs-string\">'hex'</span>);\n<span class=\"hljs-keyword\">let</span> verify = crypto.createVerify(<span class=\"hljs-string\">'RSA-SHA256'</span>);\nverify.update(str);\n<span class=\"hljs-keyword\">let</span> verifyResult = verify.verify(public,signed,<span class=\"hljs-string\">'hex'</span>); <span class=\"hljs-comment\">//true</span>\n</code></pre><h2 class=\"heading\" data-id=\"heading-37\">缓存</h2>\n<h3 class=\"heading\" data-id=\"heading-38\">缓存分类</h3>\n<h4 class=\"heading\" data-id=\"heading-39\">强制缓存</h4>\n<p>强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？ 我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-comment\">// 当访问 localhost:8080/a.js</span>\n<span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n<span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'url'</span>);\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n<span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">const</span> mime = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'mime'</span>);\n<span class=\"hljs-keyword\">const</span> server = http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">req,res</span>)</span>{\n   <span class=\"hljs-keyword\">let</span> {pathname} =  url.parse(req.url);\n   <span class=\"hljs-built_in\">console</span>.log(pathname);\n   <span class=\"hljs-keyword\">let</span> p = path.join(__dirname,<span class=\"hljs-string\">'public'</span>,<span class=\"hljs-string\">'.'</span>+pathname);\n   <span class=\"hljs-comment\">// 这里可能会存在问题，p有可能是个目录</span>\n   fs.stat(p,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err,stat</span>)</span>{\n        <span class=\"hljs-keyword\">if</span>(!err){\n            sendFile(req,res,p);\n        }<span class=\"hljs-keyword\">else</span>{\n            sendError(res);\n        }\n   })\n});\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendError</span>(<span class=\"hljs-params\">res</span>)</span>{\n    res.statusCode = <span class=\"hljs-number\">404</span>;\n    res.end();\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendFile</span>(<span class=\"hljs-params\">req,res,p</span>)</span>{\n    <span class=\"hljs-keyword\">let</span> date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-built_in\">Date</span>.now()+<span class=\"hljs-number\">10</span>*<span class=\"hljs-number\">1000</span>);\n   <span class=\"hljs-comment\">// res.setHeader('Expires',date.toUTCString());</span>\n    res.setHeader(<span class=\"hljs-string\">'Cache-Control'</span>,<span class=\"hljs-string\">'max-age=10'</span>);\n    res.setHeader(<span class=\"hljs-string\">'Content-Type'</span>,mime.getType(p)+<span class=\"hljs-string\">';charset=utf8'</span>)\n    fs.createReadStream(p).pipe(res);\n}\nserver.listen(<span class=\"hljs-number\">8080</span>);\n</code></pre><p>这种缓存结果一般有两种：memory cache 与 disk cache。前者是从内存中读，后者是从磁盘读，相比之下，后者会稍微花点时间。</p>\n<p>在查阅了一些资料之后，得到的结论是：</p>\n<blockquote>\n<p>Simple Test: Open Chrome Developper Tools / Network. Reload a page multiple times. The table column \"Size\" will tell you that some files are loaded \"from memory cache\". Now close the browser, open Developper Tools / Network again and load that page again. All cached files are loaded \"from disk cache\" now, because your memory cache is empty.</p>\n</blockquote>\n<p>同<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fexcaliburhan.com%2Fpost%2Fthings-you-should-know-about-browser-cache.html\" rel=\"nofollow noopener noreferrer\">这篇文章</a>的结论：在命中强缓存的情况下，进程初次渲染会从磁盘读取缓存资源。Chrome会将部分资源保存到内存中</p>\n<h4 class=\"heading\" data-id=\"heading-40\">对比缓存</h4>\n<ul>\n<li>对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。</li>\n<li>浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。</li>\n<li>再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。</li>\n</ul>\n<p>通过最后修改时间来对比：</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n<span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'url'</span>);\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n<span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">const</span> mime = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'mime'</span>);\n<span class=\"hljs-keyword\">const</span> server = http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">req, res</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> { pathname } = url.parse(req.url);\n    <span class=\"hljs-keyword\">let</span> p = path.join(__dirname, <span class=\"hljs-string\">'public'</span>, <span class=\"hljs-string\">'.'</span> + pathname);\n    fs.stat(p, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, stat</span>) </span>{\n        <span class=\"hljs-comment\">// 根据修改时间判断</span>\n        <span class=\"hljs-comment\">// if-modified-since  Last-Modified</span>\n        <span class=\"hljs-keyword\">if</span> (!err) {\n            <span class=\"hljs-keyword\">let</span> since = req.headers[<span class=\"hljs-string\">'if-modified-since'</span>];\n            <span class=\"hljs-keyword\">if</span>(since){\n                <span class=\"hljs-keyword\">if</span>(since === stat.ctime.toUTCString()){\n                    res.statusCode = <span class=\"hljs-number\">304</span>;\n                    res.end();\n                }<span class=\"hljs-keyword\">else</span>{\n                    sendFile(req,res,p,stat);\n                }\n            }<span class=\"hljs-keyword\">else</span>{\n                sendFile(req,res,p,stat);\n            }\n        } <span class=\"hljs-keyword\">else</span> {\n            sendError(res);\n        }\n    })\n});\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendError</span>(<span class=\"hljs-params\">res</span>) </span>{\n    res.statusCode = <span class=\"hljs-number\">404</span>;\n    res.end();\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendFile</span>(<span class=\"hljs-params\">req, res, p,stat</span>) </span>{\n    res.setHeader(<span class=\"hljs-string\">'Cache-Control'</span>,<span class=\"hljs-string\">'no-cache'</span>)\n    res.setHeader(<span class=\"hljs-string\">'Last-Modified'</span>,stat.ctime.toUTCString());\n    res.setHeader(<span class=\"hljs-string\">'Content-Type'</span>, mime.getType(p) + <span class=\"hljs-string\">';charset=utf8'</span>)\n    fs.createReadStream(p).pipe(res);\n}\nserver.listen(<span class=\"hljs-number\">8080</span>);\n</code></pre><p>最后修改时间这个方案并不是太靠谱，它存在下面这些问题：</p>\n<ul>\n<li>某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。</li>\n<li>某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。</li>\n<li>一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。</li>\n<li>如果同样的一个文件位于多个CDN服务器上的时候内容虽然一样，修改时间不一样。</li>\n</ul>\n<p>对此，我们可以采用ETag的方案。它是根据实体内容生成的一段hash字符串,可以标识资源的状态。当资源发生改变时，ETag也随之发生变化。 ETag是Web服务端产生的，然后发给浏览器客户端。</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n<span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'url'</span>);\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n<span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">const</span> mime = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'mime'</span>);\n<span class=\"hljs-keyword\">const</span> crypto = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'crypto'</span>);\n<span class=\"hljs-comment\">// 根据的是最新修改时间  这回根据的是文件的内容 </span>\n<span class=\"hljs-comment\">// ETag:md5加密 / if-none-match</span>\n<span class=\"hljs-keyword\">const</span> server = http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">req, res</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> { pathname } = url.parse(req.url);\n    <span class=\"hljs-keyword\">let</span> p = path.join(__dirname, <span class=\"hljs-string\">'public'</span>, <span class=\"hljs-string\">'.'</span> + pathname);\n    fs.stat(p, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, stat</span>) </span>{\n        <span class=\"hljs-keyword\">let</span> md5 = crypto.createHash(<span class=\"hljs-string\">'md5'</span>);\n        <span class=\"hljs-keyword\">let</span> rs = fs.createReadStream(p);\n        rs.on(<span class=\"hljs-string\">'data'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>)</span>{\n            md5.update(data);\n        });\n        rs.on(<span class=\"hljs-string\">'end'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n            <span class=\"hljs-keyword\">let</span> r = md5.digest(<span class=\"hljs-string\">'hex'</span>); <span class=\"hljs-comment\">// 当前文件的唯一标识</span>\n            <span class=\"hljs-comment\">// 下次再拿最新文件的加密值 和客户端请求来比较</span>\n            <span class=\"hljs-keyword\">let</span> ifNoneMatch = req.headers[<span class=\"hljs-string\">'if-none-match'</span>];\n            <span class=\"hljs-keyword\">if</span>(ifNoneMatch){\n                <span class=\"hljs-keyword\">if</span>(ifNoneMatch === r){\n                    res.statusCode = <span class=\"hljs-number\">304</span>;\n                    res.end();\n                }<span class=\"hljs-keyword\">else</span>{\n                    sendFile(req,res,p,r);\n                }\n            }<span class=\"hljs-keyword\">else</span>{\n                sendFile(req,res,p,r);\n            }\n        });\n    })\n});\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendError</span>(<span class=\"hljs-params\">res</span>) </span>{\n    res.statusCode = <span class=\"hljs-number\">404</span>;\n    res.end();\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendFile</span>(<span class=\"hljs-params\">req, res, p,r</span>) </span>{\n    res.setHeader(<span class=\"hljs-string\">'Cache-Control'</span>,<span class=\"hljs-string\">'no-cache'</span>)\n    res.setHeader(<span class=\"hljs-string\">'Etag'</span>,r);\n    res.setHeader(<span class=\"hljs-string\">'Content-Type'</span>, mime.getType(p) + <span class=\"hljs-string\">';charset=utf8'</span>)\n    fs.createReadStream(p).pipe(res);\n}\nserver.listen(<span class=\"hljs-number\">8080</span>);\n</code></pre><p>当然如果文件比较大，比如说1G，每次这样操作，性能比较低，所以也可以考虑stat.ctime+stat.size来对比，或者把前面两个方案一起加上。</p>\n<h3 class=\"heading\" data-id=\"heading-41\">请求流程</h3>\n<p>第一次请求：</p>\n<p></p><figure><img alt=\"alt\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d901a53ffc00a?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"501\" data-height=\"412\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;501&quot; height=&quot;412&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>第二次请求：</p>\n<p></p><figure><img alt=\"alt\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d901a53e8c90f?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1138\" data-height=\"731\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1138&quot; height=&quot;731&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-42\">Cache-Control</h3>\n<ul>\n<li>private 客户端可以缓存</li>\n<li>public 客户端和代理服务器都可以缓存</li>\n<li>max-age=60 缓存内容将在60秒后失效</li>\n<li>no-cache 需要使用对比缓存验证数据,强制向源服务器再次验证</li>\n<li>no-store 所有内容都不会缓存，强制缓存和对比缓存都不会触发</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-43\">实现一个静态服务器的脚手架</h2>\n<p>根据上面的代码，其实差不多可以撸一个简单版本出来。大概是有以下几个部分：</p>\n<ul>\n<li>判断URL是文件夹还是文件，如果是文件，则跳到下一步，文件夹的话，显示一个列表即可</li>\n<li>判断该文件是否缓存过，如果有缓存，直接读取缓存内容，没有（需要设置一个头，如etag等），则跳到下一步</li>\n<li>gzip压缩文件</li>\n<li>支持Range的功能</li>\n</ul>\n<p>在写脚手架的过程中，有两个工具，不得不提一下。</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fyargs\" rel=\"nofollow noopener noreferrer\">yargs</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Finquirer\" rel=\"nofollow noopener noreferrer\">inquirer</a></li>\n</ul>\n<p>上面一个是生成option，help的一些选项，能用使用者快速明白这个脚手架是干嘛的，下面一个则是交互的问答式命令行。</p>\n<p></p><figure><img alt=\"alt\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d903869c1c838?imageslim\" data-width=\"959\" data-height=\"1090\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;959&quot; height=&quot;1090&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-44\">最后的最后</h2>\n<p>为我的博客打个广告，欢迎访问：<a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fmy-fe.pub\" rel=\"nofollow noopener noreferrer\">小翼的前端天地</a></p>\n"
    },
    {
      "articleID": 2,
      "type": 2,
      "title": "一行代码蒸发了¥6,447,277,680 人民币！",
      "publishTime": "2018年 04月 22日",
      "praise": "10",
      "author": "爬虫",
      "tag": ["安全", "Python"],
      "authorImg": "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUde2ibZT7DLZQu72pSutGKEtYubB9uFVJLiaVTmHwHnicUGg5XaHWia74MHKqv4mgOEpLhLpatf7Qmw/132",
      "comment": [
        {
          "username": "黄宽",
          "commentTime": "2小时前",
          "commentText": "被标题骗进来的来此签到",
          "admire":"0",
          "commentImg":"https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJ61LjzbOrHsqEb1E2qiaJQPAibvAuDy0VeC4ZaCBh8OFJxAYuPXrDH0vWDkB58obpKyYAcMrDtaw4g/132"
        },
        {
          "username": "Q1Q1啦啦啦",
          "commentTime": "2小时前",
          "commentText": "路人甲？",
          "admire":"0",
          "commentImg":"https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJ61LjzbOrHsqEb1E2qiaJQPAibvAuDy0VeC4ZaCBh8OFJxAYuPXrDH0vWDkB58obpKyYAcMrDtaw4g/132"
        }
      ],
      "preview":"一行代码蒸发了¥6,447,277,680 人民币！ 现在进入你还是先行者，最后观望者进场才是韭菜。 美图董事长蔡文胜曾在三点钟群，高调的说出了这句话，随即被大众疯传。 在他发表完言论没多久，2月美链（BEC）上交易所会暴涨4000%，后又暴跌。尽管他多次否认，聪明的网友早已扒出，他与BEC千丝万",
      "content": "<h2 class=\"heading\" data-id=\"heading-0\">一行代码蒸发了¥6,447,277,680 人民币！</h2>\n<p><strong>现在进入你还是先行者，最后观望者进场才是韭菜。</strong></p>\n<p>美图董事长蔡文胜曾在三点钟群，高调的说出了这句话，随即被大众疯传。</p>\n<p>在他发表完言论没多久，2月美链（BEC）上交易所会暴涨4000%，后又暴跌。尽管他多次否认，聪明的网友早已扒出，他与BEC千丝万缕的关系。</p>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf063245531f?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"640\" data-height=\"493\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf063245531f?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>庄家坐庄操控币价，美图的股价随之暴涨，蔡文胜顺利完成了他的韭菜收割大计。</p>\n<p>但在币圈，割人者，人恒割之。</p>\n<p>随着BEC智能合约的漏洞的爆出，被黑客利用，瞬间套现抛售大额BEC，6亿在瞬间归零。</p>\n<p>而这一切，竟然是因为一个简单至极的程序Bug。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">背景</h2>\n<p>今天有人在群里说，<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fetherscan.io%2Faddress%2F0xc5d105e63711398af9bbff092d4b6769c82f793d\" rel=\"nofollow noopener noreferrer\">Beauty Chain 美蜜</a> 代码里面有bug，已经有人利用该bug获得了  57,896,044,618,658,100,000,000,000,000,000,000,000,000,000,000,000,000,000,000.792003956564819968 个 BEC</p>\n<p>那笔操作记录是 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fetherscan.io%2Ftx%2F0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f\" rel=\"nofollow noopener noreferrer\">0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f</a></p>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf06325c2d8b?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"848\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf06325c2d8b?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>下面我来带大家看看，黑客是如何实现的！</p>\n<p>我们可以看到执行的方法是 <code>batchTransfer</code></p>\n<p>那这个方法是干嘛的呢？（给指定的几个地址，发送相同数量的代币）</p>\n<h3 class=\"heading\" data-id=\"heading-2\">整体逻辑是</h3>\n<p>你传几个地址给我(_receivers),然后再传给我你要给每个人多少代币（_value)</p>\n<p>然后你要发送的总金额 = 发送的人数* 发送的金额</p>\n<p>然后 要求你当前的余额大于 发送的总金额</p>\n<p>然后扣掉你发送的总金额</p>\n<p>然后 给_receivers 里面的每个人发送 指定的金额（_value)</p>\n<p>从逻辑上看，这边是没有任何问题的，你想给别人发送代币，那么你本身的余额一定要大于发送的总金额的！</p>\n<p>但是这段代码却犯了一个很傻的错!</p>\n<h2 class=\"heading\" data-id=\"heading-3\">代码解释</h2>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf06324e8776?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"369\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf06324e8776?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>这个方法会传入两个参数</p>\n<ol>\n<li>_receivers</li>\n<li>_value</li>\n</ol>\n<p>_receivers 的值是个列表，里面有两个地址</p>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fetherscan.io%2Ftoken%2F0xc5d105e63711398af9bbff092d4b6769c82f793d%3Fa%3D0x0e823ffe018727585eaf5bc769fa80472f76c3d7\" rel=\"nofollow noopener noreferrer\">0x0e823ffe018727585eaf5bc769fa80472f76c3d7</a></p>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fetherscan.io%2Ftoken%2F0xc5d105e63711398af9bbff092d4b6769c82f793d%3Fa%3D0xb4d30cac5124b46c2df0cf3e3e1be05f42119033\" rel=\"nofollow noopener noreferrer\">0xb4d30cac5124b46c2df0cf3e3e1be05f42119033</a></p>\n<p>_value 的值是 <code>8000000000000000000000000000000000000000000000000000000000000000</code></p>\n<p>我们再查看代码（如下图）</p>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf0635076480?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"393\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf0635076480?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>我们一行一行的来解释</p>\n<p><code>uint cnt = _receivers.length;</code></p>\n<p>是获取 _receivers 里面有几个地址，我们从上面可以看到 参数里面只有两个地址，所以 cnt=2，也就是 给两个地址发送代币</p>\n<p><code>uint256 amount = uint256(cnt) * _value;</code></p>\n<h2 class=\"heading\" data-id=\"heading-4\">uint256</h2>\n<p>首先<code>uint256(cnt)</code> 是把cnt 转成了 uint256类型</p>\n<p>那么,什么是uint256类型？或者说uint256类型的取值范围是多少...</p>\n<p>uintx 类型的取值范围是 0 到 2的x次方 -1</p>\n<p>也就是 假如是 uint8的话</p>\n<p>则 uint8的取值范围是 0 到 2的8次方 -1</p>\n<p>也就是 0 到255</p>\n<p>那么uint256 的取值范围是</p>\n<p>0 - 2的256次方-1  也就是 <code>0 到115792089237316195423570985008687907853269984665640564039457584007913129639935</code></p>\n<p>python 算 2的256次方是多少\n</p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf06346a8747?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"119\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf06346a8747?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>那么假如说 设置的值超过了 取值范围怎么办？这种情况称为<code>溢出</code></p>\n<p>举个例子来说明</p>\n<p>因为uint256的取值太大了，所以用uint8来 举例。。。</p>\n<p>从上面我们已经知道了  uint8 最小是0，最大是255</p>\n<p>那么当我 255 + 1 的时候，结果是啥呢？<strong>结果会变成0</strong></p>\n<p>那么当我 255 + 2 的时候，结果是啥呢？<strong>结果会变成1</strong></p>\n<p>那么当我 0 - 1  的时候，结果是啥呢？<strong>结果会变成255</strong></p>\n<p>那么当我 0 - 2  的时候，结果是啥呢？<strong>结果会变成255</strong></p>\n<p>那么 我们回到上面的代码中，</p>\n<p><code>amount = uint256(cnt) * _value</code></p>\n<p>则 amount = 2* _value</p>\n<p>但是此时 _value 是16进制的，我们把他转成 10进制</p>\n<p>（python 16进制转10进制）\n</p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf0634fe6af0?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1226\" data-height=\"136\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf0634fe6af0?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>可以看到 _value = <code>57896044618658097711785492504343953926634992332820282019728792003956564819968</code></p>\n<p>那么amount = _value*2 = <code>115792089237316195423570985008687907853269984665640564039457584007913129639936</code></p>\n<p>可以在查看上面看到 uint256取值范围最大为 <code>115792089237316195423570985008687907853269984665640564039457584007913129639935</code></p>\n<p>此时，amout已经超过了最大值，溢出 则<code>amount = 0</code></p>\n<p>下一行代码\n<code>require(cnt &gt; 0 &amp;&amp; cnt &lt;= 20);</code>\nrequire 语句是表示该语句一定要是正确的，也就是 cnt 必须大于0 且 小于等于20</p>\n<p>我们的cnt等于2，通过!</p>\n<p><code>require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);</code></p>\n<p>这句要求 _value 大于0，我们的_value是大于0 的\n且,当前用户拥有的代币余额大于等于 amount,因为amount等于0，所以 就算你一个代币没有，也是满足的！</p>\n<p><code>balances[msg.sender] = balances[msg.sender].sub(amount);</code></p>\n<p>这句是当前用户的余额 - amount</p>\n<p>当前amount 是0，所以当前用户代币的余额没有变动</p>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-keyword\">for</span> (uint i = 0; i &lt; cnt; i++) {\n    balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n    Transfer(msg.sender, _receivers[i], _value);\n}\n</code></pre><p>这句是遍历 _receivers中的地址，\n对每个地址做以下操作</p>\n<p><code>balances[_receivers[i]] = balances[_receivers[i]].add(_value);</code>\n_receivers中的地址 的余额 = 原本余额+value</p>\n<p>所以 _receivers 中地址的余额 则加了57896044618658097711785492504343953926634992332820282019728792003956564819968 个代币！！！</p>\n<p><code>Transfer(msg.sender, _receivers[i], _value); }</code>\n这句则只是把赠送代币的记录存下来！！！</p>\n<h2 class=\"heading\" data-id=\"heading-5\">总结</h2>\n<p>就一个简单的溢出漏洞，导致BEC代币的市值接近归0</p>\n<p>那么，开发者有没有考虑到溢出问题呢？</p>\n<p>其实他考虑了,</p>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf06590aad67?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"396\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf06590aad67?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>可以看如上截图</p>\n<p>除了amount的计算外, 其他的给用户转钱 都用了safeMath 的方法（sub,add)</p>\n<p>那么 为啥就偏偏这一句没有用safeMath的方法呢。。。</p>\n<p>这就要用写代码的人了。。。</p>\n<h2 class=\"heading\" data-id=\"heading-6\">啥是safeMath</h2>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf066064b049?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"865\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf066064b049?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>safeMath 是为了计算安全 而写的一个library</p>\n<p>我们看看他干了啥？为啥能保证计算安全.</p>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> mul(uint256 a, uint256 b) internal constant returns (uint256) {\nuint256 c = a * b;\nassert(a == 0 || c / a == b);\n<span class=\"hljs-built_in\">return</span> c;\n}\n\n</code></pre><p>如上面的乘法.\n他在计算后，用assert 验证了下结果是否正确！</p>\n<p>如果在上面计算 amount的时候，用了 mul的话，\n则 <code>c / a == b</code>\n也就是 验证 amount / cnt == _value</p>\n<p>这句会执行报错的，因为 0 / cnt  不等于 _value</p>\n<p>所以程序会报错！</p>\n<p>也就不会发生溢出了...</p>\n<p>那么 还有一个小问题，这里的<code>assert</code> 好 <code>require</code> 好像是干的同一件事</p>\n<p>都是为了验证 某条语句是否正确！</p>\n<p>那么他俩有啥区别呢？</p>\n<p>用了assert的话，则程序的gas limit 会消耗完毕</p>\n<p>而require的话，则只是消耗掉当前执行的gas</p>\n<h2 class=\"heading\" data-id=\"heading-7\">总结</h2>\n<p>那么 我们如何避免这种问题呢？</p>\n<p>我个人看法是</p>\n<ol>\n<li>只要涉及到计算，一定要用safeMath</li>\n<li>代码一定要测试！</li>\n<li>代码一定要review！</li>\n<li>必要时，要请专门做代码审计的公司来 测试代码</li>\n</ol>\n<p>这件事后需要如何处理呢？</p>\n<p>目前，该方法已经暂停了（还好可以暂停）所以看过文章的朋友 不要去测试了...</p>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf065f063401?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"416\" src=\"https://user-gold-cdn.xitu.io/2018/4/22/162edf065f063401?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>不过已经发生了的事情咋办呢？</p>\n<p>我的想法是，快照在漏洞之前，所有用户的余额情况</p>\n<p>然后发行新的token，给之前的用户 发送等额的代币...</p>\n"
    },
    {
      "articleID": 3,
      "type": 1,
      "title": "async/await，了解一下？",
      "publishTime": "2018年 04月 24日",
      "praise": "26",
      "tag": ["Promise", "前端"],
      "author": "lunlunshiwo",
      "authorImg": "https://avatars1.githubusercontent.com/u/30309080?v=4",
      "comment": [
        {
          "username": "songming43",
          "commentTime": "3小时前",
          "commentText": "fn = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(1)\n    }, 2000)\n  })\n}\nconst Fn = async () => {\n  await fn().then((res) => {\n    console.log(res)\n  })\n}\nFn()\nconsole.log(2)\n\n执行这段函数的结果，并不是2s后打印1，然后打印2。\n而是先打印2，再2s后打印1",
          "admire":"1",
          "commentImg":"https://lc-mhke0kuv.cn-n1.lcfile.com/1vAbR4zqE8tRPbd3AmQPaHaNag84P3AmNudjJQNu"
        }
      ],
      "preview":"上一篇博客我们在现实使用和面试角度讲解了Promise(原文可参考《面向面试题和实际使用谈promise》)，但是Promise 的方式虽然解决了 callback hell，但是这种方式充满了 Promise的 方法，如果处理流程复杂的话，整段代码将充满 ，代码流程不能很好的表示执行流程。",
      "content": "<p>　　上一篇博客我们在现实使用和面试角度讲解了Promise(原文可参考《<a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Flunlunshiwo%2Fp%2F8852984.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">面向面试题和实际使用谈promise</a>》)，但是Promise 的方式虽然解决了 callback hell，但是这种方式充满了 Promise的 <code>then()</code> 方法，如果处理流程复杂的话，整段代码将充满 <code>then</code>，代码流程不能很好的表示执行流程。</p><h2 data-id=\"heading-0\">为什么是async/await</h2><p>　　在es6中，我们可以使用Generator函数控制流程，如下面这段代码：</p><div><pre code-lang=\"\" class=\"hljs bash\"><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-keyword\">function</span>* foo(x) {\n    yield x + 1;\n    yield x + 2;\n    <span class=\"hljs-built_in\">return</span> x + 3;\n}</code></pre></div><p>　　我们可以根据不断地调用Generator对象的<code>next()</code>方法来控制函数的流程。但是这样仿佛不是那么的语义化。因此，在ES6中封装了Generator函数的语法糖async函数，但是将其定义在了es7中。ES7定义出的<code>async</code> 函数，终于让 JavaScript 对于异步操作有了终极解决方案。<code>Async</code> 函数是 Generator函数的语法糖。使用 关键字 <code>Async</code> 来表示，在函数内部使用 await来表示异步。相较于 Generator，Async函数的改进在于下面几点：Generator 函数的执行必须依靠执行器，而 <code>Async（）</code> 函数自带执行器，调用方式跟普通函数的调用一样。<code>Async</code> 和 await相较于 <code>*</code> 和 <code>yield</code> 更加语义化。<code>async</code> 函数返回值是 Promise 对象，比 Generator函数返回的 Iterator 对象方便，可以直接使用 <code>then（）</code>方法进行调用。</p><p>　　那么，我们通过一段小小的代码来说明async/await函数的用法：</p><p>　　　　未使用async/await的定时函数：</p><div><pre code-lang=\"\" class=\"hljs bash\"><code class=\"hljs bash\" lang=\"bash\">fn = () =&gt; {\n  <span class=\"hljs-built_in\">return</span> new Promise((resolve, reject) =&gt; {\n    <span class=\"hljs-built_in\">set</span>Timeout(() =&gt; {\n      resolve(1)\n    }, 2000)\n  })\n}\nconst Fn = () =&gt;{\n  fn().then((res) =&gt; {\n    console.log(res)\n  })\n}\nFn()\nconsole.log(2)</code></pre></div><p>　　我相信能看到这里的各位程序员大佬应该都知道这段代码的输出状况：先打印2，2s之后打印出1。</p><p>　　　　使用async/await的定时函数：</p><div><pre code-lang=\"\" class=\"hljs bash\"><code class=\"hljs bash\" lang=\"bash\">fn = () =&gt; {\n  <span class=\"hljs-built_in\">return</span> new Promise((resolve, reject) =&gt; {\n    <span class=\"hljs-built_in\">set</span>Timeout(() =&gt; {\n      resolve(1)\n    }, 2000)\n  })\n}\nconst Fn = async () =&gt; {\n  await fn().then((res) =&gt; {\n    console.log(res)\n  })\n}\nFn()\nconsole.log(2)</code></pre></div><p>　　这一段函数的输出状况是：2s后打印1，然后打印2。</p><p>　　那么，why？</p><p>　　我们在字面上理解这两个单词async和await：async的意思是异步，async用于定义一个异步函数，该函数返回一个Promise。；await的意思是等待，Promise是一个承诺，await也是一个承诺。Promise的承诺是将返回值输出到then的回掉函数里面，无论是成功还是失败。await的承诺是无论刮风还是下雨，我都会等你完成在做其他的步骤。因此，在上面的运用了async/await的代码中，会等待fn完全运行完成并且异步的回调完成对返回值的处理之后在开始进行下一步操作的。其原理是将异步函数转变为同步操作。</p><h2 data-id=\"heading-1\">实际运用</h2><p>　　在上周的工作中，我在一段基于node完成的爬虫操作中多次运用async/await来控制程序的执行流程：</p><div><pre code-lang=\"\" class=\"hljs bash\"><code class=\"hljs bash\" lang=\"bash\">//伪代码\n<span class=\"hljs-built_in\">let</span> axiosArr = [];\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> i = 0, len = arr.length; i &lt; len; i++) {\n  <span class=\"hljs-built_in\">let</span> params = qs.stringify({\n    <span class=\"hljs-string\">'param'</span>: arr[i].index,\n  })\n  axiosArr.push(axios.post(url, params, {\n    headers\n  }))\n}\n/*\n*上面的循环是循环抓取2345条数据，平均每个数据要访问16个接口\n*用axios.all同时询问，当返回结束后将返回值处理\n*然后将返回值存储到mongodb数据库中\n*/\nawait axios.all(axiosArr).then(\n  axios.spread(<span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> i = 0, len = arguments.length; i &lt; len; i++) {\n      <span class=\"hljs-built_in\">let</span> str = `<span class=\"hljs-variable\">${unescape(arguments[i].data.replace(/\\\\u/g, '%u'))}</span>`;\n      str = basics.subStr(basics.deletN(basics.deletS(basics.cutStr(str))));\n      concentArr[i].concent = str\n    }\n    mg.mongodbMain({\n      name: obj.name,\n      <span class=\"hljs-built_in\">alias</span>: obj.alias,\n      <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-built_in\">type</span>,\n      url: obj.url,\n      drugsConcent: concentArr\n    })\n  }))</code></pre></div><p>　　其实操作就这么点，大家看一下代码都会懂。但是问题是，当我不使用async/await时，会产生的情况是会先访问2000+个数据，不断访问其16个接口，但是由于promise的then的回调函数为异步的，会挂起，而不是直接将数据存到数据库中。这貌似和我们预想的不一样啊。因此，我在这里使用了async/await函数，使用同步处理异步操作，将promise同步化，当axios.all访问完成这每一条数据的16个接口后，直接将数据存储到数据库中，然后才会走到循环的下一层，依旧是访问下一条数据的16个接口。</p><h2 data-id=\"heading-2\">async/await的身后事</h2><p>　　我们说过了<code>async</code> 函数返回值是 Promise 对象。</p><div><pre code-lang=\"\" class=\"hljs bash\"><code class=\"hljs bash\" lang=\"bash\">const delay = timeout =&gt; new Promise(resolve=&gt; <span class=\"hljs-built_in\">set</span>Timeout(resolve, timeout));\nasync <span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">f</span></span>(){\n    await delay(1000);\n    await delay(2000);\n    await delay(3000);\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'done'</span>;\n}\n\nf().then(v =&gt; console.log(v));// 6s之后打印<span class=\"hljs-string\">'done'</span></code></pre></div><p>　　那么其内部一旦抛出异常，则会导致返回的 Promise 对象状态变为 <code>reject</code> 状态。抛出的错误而会被 <code>catch</code> 方法回调函数接收到。</p><div><pre code-lang=\"\" class=\"hljs bash\"><code class=\"hljs bash\" lang=\"bash\">async <span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">e</span></span>(){\n    throw new Error(<span class=\"hljs-string\">'error'</span>);\n}\ne().then(v =&gt; console.log(v))\n.catch( e =&gt; console.log(e));//抛出的错误会被catch捕捉到</code></pre></div><p>　　并且，async有一个和promise.all相似的特性，就是内部一点有一个await函数报错，后续的就不再执行了</p><div><pre code-lang=\"\" class=\"hljs bash\"><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> fn1 = ()=&gt;{\n    <span class=\"hljs-built_in\">return</span> new Promise((resolve,reject) =&gt; {\n        <span class=\"hljs-built_in\">set</span>Timeout(()=&gt;{\n            reject(<span class=\"hljs-string\">'故意抛出错误'</span>);\n        },500);\n    });\n}\n\n<span class=\"hljs-built_in\">let</span> fn2 = ()=&gt;{\n    <span class=\"hljs-built_in\">return</span> new Promise((resolve,reject)=&gt;{\n        <span class=\"hljs-built_in\">set</span>Timeout(()=&gt;{\n            resolve(1);\n        },500);\n    });\n}\n\n<span class=\"hljs-built_in\">let</span> getList = async ()=&gt;{\n    <span class=\"hljs-built_in\">let</span> a = await fn1();\n    <span class=\"hljs-built_in\">let</span> b = await fn2();\n    <span class=\"hljs-built_in\">return</span> {first: a,second:b};\n}\ngetList().then(result=&gt; {\n    console.log(result);\n}).catch(err=&gt; {\n    console.log(err);// 由于fn1的报错，async的状态直接变成了rejected\n});</code></pre></div><p> </p><p>　　当Promise出现的时候，我们仿佛看到了回调地狱的灭亡。当Async/Await出现时，异步终于不是一件困难的事情。</p><p> </p><p> </p><p class=\"\"><img alt=\"\" class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f536ab9ce3276?imageslim\" data-width=\"300\" data-height=\"184\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f536ab9ce3276?imageslim\"></p><p class=\"\"><img alt=\"\" class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f536ab9b6f37e?imageslim\" data-width=\"300\" data-height=\"168\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f536ab9b6f37e?imageslim\"></p><p><br></p>"
    },
    {
      "articleID": 4,
      "type": 2,
      "title": "Java锁机制了解一下",
      "publishTime": "2018年 04月 24日",
      "praise": "28",
      "tag": ["java","后端"],
      "author": "Java3y",
      "authorImg": "https://user-gold-cdn.xitu.io/2018/4/9/162a82f18292cf7f?imageView2/1/w/100/h/100/q/85/interlace/1&quot",
      "comment": [
      {
        "username": "Skyline7",
        "commentTime": "1小时前",
        "commentText": "打卡",
        "admire":"0",
        "commentImg":"https://user-gold-cdn.xitu.io/2017/12/10/160412584f1dfac3?imageView2/1/w/100/h/100/q/85/interlace/1"
      }
      ],
      "preview":"本文章主要讲的是Java多线程加锁机制，有两种： 其实都比较坑，如果能先系统讲了Synchronized锁机制，接着讲显式Lock锁机制，那就很容易理解了。也不需要跨那么多章节。 1.1SYNCHRONIZED锁是什么？ synchronized是Java的一个关键字，它能够将代码块(方法)锁起来",
      "content": "<h1 class=\"heading\" data-id=\"heading-0\">前言</h1>\n<p>回顾前面：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njg5MDA5NA%3D%3D%26mid%3D2247484186%26idx%3D1%26sn%3D2a7b937e6d3b1623aceac199d3e402f9%26chksm%3Debd7421bdca0cb0d6206db8c7f063c884c3f0b285975c8e896fde424660b4ccb88da1549f32c%23rd\" rel=\"nofollow noopener noreferrer\">多线程三分钟就可以入个门了！</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njg5MDA5NA%3D%3D%26mid%3D2247484190%26idx%3D1%26sn%3Dab7301e393aa7762be9ef80d30c5fb7a%26chksm%3Debd7421fdca0cb09f4a880064a8610416df414ea25284e6d5142ea659e4e7e669632cfed4050%23rd\" rel=\"nofollow noopener noreferrer\">Thread源码剖析</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njg5MDA5NA%3D%3D%26mid%3D2247484194%26idx%3D1%26sn%3Ded1241fcba5d3e85b6d900d8667f04f6%26chksm%3Debd74223dca0cb35fe16a267c88ac9e5159825b27c278fb165a8c50d681e1340b73cfd69ae0d%23rd\" rel=\"nofollow noopener noreferrer\">多线程基础必要知识点！看了学习多线程事半功倍</a></li>\n</ul>\n<blockquote>\n<p>只有光头才能变强！</p>\n</blockquote>\n<p>本文章主要讲的是Java多线程<strong>加锁机制</strong>，有两种：</p>\n<ul>\n<li>Synchronized</li>\n<li>显式Lock</li>\n</ul>\n<p>不得不唠叨几句：</p>\n<ul>\n<li>在《Java核心技术卷 一》是先讲比较难的显式Lock，而再讲的是比较简单的Synchronized</li>\n<li>而《Java并发编程实战》在前4章零散地讲解了Synchronized，将显式Lock放到了13章</li>\n</ul>\n<p>其实<strong>都比较坑</strong>，如果能先系统讲了Synchronized锁机制，接着讲显式Lock锁机制，那就很容易理解了。也不需要跨那么多章节。</p>\n<p>那么接下来我们就开始吧~</p>\n<h1 class=\"heading\" data-id=\"heading-1\">一、synchronized锁</h1>\n<h2 class=\"heading\" data-id=\"heading-2\">1.1synchronized锁是什么？</h2>\n<p>synchronized是Java的一个<strong>关键字</strong>，它能够将<strong>代码块(方法)锁起来</strong></p>\n<ul>\n<li>它使用起来是非常简单的，只要在代码块(方法)添加关键字synchronized，即可以<strong>实现同步</strong>的功能~</li>\n</ul>\n<pre><code class=\"hljs java\" lang=\"java\">\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// 关注公众号Java3y</span>\n        <span class=\"hljs-comment\">// doSomething</span>\n    }\n\n</code></pre><p>synchronized是一种<strong>互斥锁</strong></p>\n<ul>\n<li><strong>一次只能允许一个线程进入被锁住的代码块</strong></li>\n</ul>\n<p>synchronized是一种<strong>内置锁/监视器锁</strong></p>\n<ul>\n<li>Java中<strong>每个对象</strong>都有一个<strong>内置锁(监视器,也可以理解成锁标记)</strong>，而synchronized就是使用**对象的内置锁(监视器)**来将代码块(方法)锁定的！</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-3\">1.2synchronized用处是什么？</h2>\n<ul>\n<li>synchronized保证了线程的<strong>原子性</strong>。(被保护的代码块是一次被执行的，没有任何线程会同时访问)</li>\n<li>synchronized还保证了<strong>可见性</strong>。(当执行完synchronized之后，修改后的变量对其他的线程是可见的)</li>\n</ul>\n<p>Java中的synchronized，通过使用内置锁，来实现对变量的同步操作，进而实现了<strong>对变量操作的原子性和其他线程对变量的可见性</strong>，从而确保了并发情况下的线程安全。</p>\n<h2 class=\"heading\" data-id=\"heading-4\">1.3synchronized的原理</h2>\n<p>我们首先来看一段synchronized修饰方法和代码块的代码：</p>\n<pre><code class=\"hljs java\" lang=\"java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Main</span> </span>{\n\t<span class=\"hljs-comment\">//修饰方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">()</span></span>{\n\n    }\n\n\t\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">()</span></span>{\n\t\t<span class=\"hljs-comment\">// 修饰代码块</span>\n        <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>){\n\n        }\n    }\n}\n</code></pre><p>来反编译看一下：</p>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f76943723a1cf?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1098\" data-height=\"721\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f76943723a1cf?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p><strong>同步代码块</strong>：</p>\n<ul>\n<li>monitorenter和monitorexit指令实现的</li>\n</ul>\n<p><strong>同步方法</strong>（在这看不出来需要看JVM底层实现）</p>\n<ul>\n<li>方法修饰符上的ACC_SYNCHRONIZED实现。</li>\n</ul>\n<p>synchronized底层是是<strong>通过monitor对象，对象有自己的对象头，存储了很多信息，其中一个信息标示是被哪个线程持有</strong>。</p>\n<p>具体可参考：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fchenssy%2Farticle%2Fdetails%2F54883355\" rel=\"nofollow noopener noreferrer\">blog.csdn.net/chenssy/art…</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fu012465296%2Farticle%2Fdetails%2F53022317\" rel=\"nofollow noopener noreferrer\">blog.csdn.net/u012465296/…</a></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-5\">1.4synchronized如何使用</h2>\n<p>synchronized一般我们用来修饰三种东西：</p>\n<ul>\n<li>修饰普通方法</li>\n<li>修饰代码块</li>\n<li>修饰静态方法</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-6\">1.4.1修饰普通方法：</h3>\n<p>用的锁是<strong>Java3y对象(内置锁)</strong></p>\n<pre><code class=\"hljs java\" lang=\"java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Java3y</span> </span>{\n\n\n    <span class=\"hljs-comment\">// 修饰普通方法，此时用的锁是Java3y对象(内置锁)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// 关注公众号Java3y</span>\n        <span class=\"hljs-comment\">// doSomething</span>\n    }\n\n}\n\n</code></pre><h3 class=\"heading\" data-id=\"heading-7\">1.4.2修饰代码块：</h3>\n<p>用的锁是<strong>Java3y对象(内置锁)</strong>---&gt;this</p>\n<pre><code class=\"hljs java\" lang=\"java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Java3y</span> </span>{\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span>  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n        \n        <span class=\"hljs-comment\">// 修饰代码块，此时用的锁是Java3y对象(内置锁)---&gt;this</span>\n        <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>){\n            <span class=\"hljs-comment\">// 关注公众号Java3y</span>\n            <span class=\"hljs-comment\">// doSomething</span>\n        }\n    }\n}\n</code></pre><p>当然了，我们使用synchronized修饰代码块时未必使用this，还可以<strong>使用其他的对象(随便一个对象都有一个内置锁)</strong></p>\n<p>所以，我们可以这样干：</p>\n<pre><code class=\"hljs java\" lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Java3y</span> </span>{\n\n\n    <span class=\"hljs-comment\">// 使用object作为锁(任何对象都有对应的锁标记，object也不例外)</span>\n    <span class=\"hljs-keyword\">private</span> Object object = <span class=\"hljs-keyword\">new</span> Object();\n\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n\n        <span class=\"hljs-comment\">// 修饰代码块，此时用的锁是自己创建的锁Object</span>\n        <span class=\"hljs-keyword\">synchronized</span> (object){\n            <span class=\"hljs-comment\">// 关注公众号Java3y</span>\n            <span class=\"hljs-comment\">// doSomething</span>\n        }\n    }\n\n}\n\n</code></pre><p>上面那种方式(随便使用一个对象作为锁)在书上称之为--&gt;<strong>客户端锁</strong>，这是<strong>不建议使用的</strong>。</p>\n<p>书上想要实现的功能是：给ArrayList添加一个<code>putIfAbsent()</code>，这需要是线程安全的。</p>\n<p><strong>假定直接添加synchronized是不可行的</strong></p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f7694354307a9?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1118\" data-height=\"245\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1118&quot; height=&quot;245&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p><strong>使用客户端锁，会将当前的实现与原本的list耦合了</strong>：</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f76943774df73?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1085\" data-height=\"385\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1085&quot; height=&quot;385&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>书上给出的办法是使用<strong>组合</strong>的方式(也就是装饰器模式)</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f7694355f7fcc?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1164\" data-height=\"664\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1164&quot; height=&quot;664&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-8\">1.4.3修饰静态方法</h3>\n<p>获取到的是<strong>类锁(类的字节码文件对象)</strong>：Java3y.class</p>\n<pre><code class=\"hljs java\" lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Java3y</span> </span>{\n\n    <span class=\"hljs-comment\">// 修饰静态方法代码块，静态方法属于类方法，它属于这个类，获取到的锁是属于类的锁(类的字节码文件对象)--&gt;Java3y.class</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n\n        <span class=\"hljs-comment\">// 关注公众号Java3y</span>\n        <span class=\"hljs-comment\">// doSomething</span>\n    }\n}\n</code></pre><h3 class=\"heading\" data-id=\"heading-9\">1.4.4类锁与对象锁</h3>\n<p>synchronized修饰静态方法获取的是类锁(类的字节码文件对象)，synchronized修饰普通方法或代码块获取的是对象锁。</p>\n<ul>\n<li>它俩是不冲突的，也就是说：<strong>获取了类锁的线程和获取了对象锁的线程是不冲突的</strong>！</li>\n</ul>\n<pre><code class=\"hljs java\" lang=\"java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SynchoronizedDemo</span> </span>{\n\n    <span class=\"hljs-comment\">//synchronized修饰非静态方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">function</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>{\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;<span class=\"hljs-number\">3</span>; i++) {\n            Thread.sleep(<span class=\"hljs-number\">1000</span>);\n            System.out.println(<span class=\"hljs-string\">\"function running...\"</span>);\n        }\n    }\n    <span class=\"hljs-comment\">//synchronized修饰静态方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">staticFunction</span><span class=\"hljs-params\">()</span>\n            <span class=\"hljs-keyword\">throws</span> InterruptedException </span>{\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; i++) {\n            Thread.sleep(<span class=\"hljs-number\">1000</span>);\n            System.out.println(<span class=\"hljs-string\">\"Static function running...\"</span>);\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        <span class=\"hljs-keyword\">final</span> SynchoronizedDemo demo = <span class=\"hljs-keyword\">new</span> SynchoronizedDemo();\n\n        <span class=\"hljs-comment\">// 创建线程执行静态方法</span>\n        Thread t1 = <span class=\"hljs-keyword\">new</span> Thread(() -&gt; {\n            <span class=\"hljs-keyword\">try</span> {\n                staticFunction();\n            } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n\n        <span class=\"hljs-comment\">// 创建线程执行实例方法</span>\n        Thread t2 = <span class=\"hljs-keyword\">new</span> Thread(() -&gt; {\n            <span class=\"hljs-keyword\">try</span> {\n                demo.function();\n            } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        <span class=\"hljs-comment\">// 启动</span>\n        t1.start();\n        t2.start();\n    }\n}\n</code></pre><p>结果证明：<strong>类锁和对象锁是不会冲突的</strong>！</p>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f7694382ef523?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"988\" data-height=\"271\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f7694382ef523?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-10\">1.5重入锁</h2>\n<p>我们来看下面的代码：</p>\n<pre><code class=\"hljs java\" lang=\"java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Widget</span> </span>{\n\n\t<span class=\"hljs-comment\">// 锁住了</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doSomething</span><span class=\"hljs-params\">()</span> </span>{\n\t\t...\n\t}\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LoggingWidget</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Widget</span> </span>{\n\n\t<span class=\"hljs-comment\">// 锁住了</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doSomething</span><span class=\"hljs-params\">()</span> </span>{\n\t\tSystem.out.println(toString() + <span class=\"hljs-string\">\": calling doSomething\"</span>);\n\t\t<span class=\"hljs-keyword\">super</span>.doSomething();\n\t}\n}\n</code></pre><ol>\n<li>当线程A进入到LoggingWidget的<code>doSomething()</code>方法时，<strong>此时拿到了LoggingWidget实例对象的锁</strong>。</li>\n<li>随后在方法上又调用了父类Widget的<code>doSomething()</code>方法，它<strong>又是被synchronized修饰</strong>。</li>\n<li>那现在我们LoggingWidget实例对象的锁还没有释放，进入父类Widget的<code>doSomething()</code>方法<strong>还需要一把锁吗？</strong></li>\n</ol>\n<p><strong>不需要的！</strong></p>\n<p>因为<strong>锁的持有者是“线程”，而不是“调用”</strong>。线程A已经是有了LoggingWidget实例对象的锁了，当再需要的时候可以继续**“开锁”**进去的！</p>\n<p>这就是内置锁的<strong>可重入性</strong>。</p>\n<h2 class=\"heading\" data-id=\"heading-11\">1.6释放锁的时机</h2>\n<ol>\n<li>当方法(代码块)执行完毕后会<strong>自动释放锁</strong>，不需要做任何的操作。</li>\n<li><strong>当一个线程执行的代码出现异常时，其所持有的锁会自动释放</strong>。</li>\n</ol>\n<ul>\n<li>不会由于异常导致出现死锁现象~</li>\n</ul>\n<h1 class=\"heading\" data-id=\"heading-12\">二、Lock显式锁</h1>\n<h2 class=\"heading\" data-id=\"heading-13\">2.1Lock显式锁简单介绍</h2>\n<p>Lock显式锁是JDK1.5之后才有的，之前我们都是使用Synchronized锁来使线程安全的~</p>\n<p>Lock显式锁是一个接口，我们来看看：</p>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f769eb628db65?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"470\" data-height=\"186\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f769eb628db65?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>随便翻译一下他的顶部注释，看看是干嘛用的：</p>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f769475d5e980?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"663\" data-height=\"1280\" src=\"https://user-gold-cdn.xitu.io/2018/4/24/162f769475d5e980?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>可以<strong>简单概括</strong>一下：</p>\n<ul>\n<li>Lock方式来获取锁<strong>支持中断、超时不获取、是非阻塞的</strong></li>\n<li><strong>提高了语义化</strong>，哪里加锁，哪里解锁都得写出来</li>\n<li><strong>Lock显式锁可以给我们带来很好的灵活性，但同时我们必须手动释放锁</strong></li>\n<li>支持Condition条件对象</li>\n<li><strong>允许多个读线程同时访问共享资源</strong></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-14\">2.2synchronized锁和Lock锁使用哪个</h2>\n<p>前面说了，Lock显式锁给我们的程序带来了很多的灵活性，很多特性都是Synchronized锁没有的。那Synchronized锁有没有存在的必要？？</p>\n<p>必须是有的！！Lock锁在刚出来的时候很多性能方面都比Synchronized锁要好，但是从JDK1.6开始Synchronized锁就做了各种的优化(毕竟亲儿子，牛逼)</p>\n<ul>\n<li>优化操作：适应自旋锁，锁消除，锁粗化，轻量级锁，偏向锁。</li>\n<li>详情可参考：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fchenssy%2Farticle%2Fdetails%2F54883355\" rel=\"nofollow noopener noreferrer\">blog.csdn.net/chenssy/art…</a></li>\n</ul>\n<p>所以，到现在Lock锁和Synchronized锁的性能其实<strong>差别不是很大</strong>！而Synchronized锁用起来又特别简单。<strong>Lock锁还得顾忌到它的特性，要手动释放锁才行</strong>(如果忘了释放，这就是一个隐患)</p>\n<p>所以说，我们<strong>绝大部分时候还是会使用Synchronized锁</strong>，用到了Lock锁提及的特性，带来的灵活性才会考虑使用Lock显式锁~</p>\n<h2 class=\"heading\" data-id=\"heading-15\">2.3公平锁</h2>\n<p>公平锁理解起来非常简单：</p>\n<ul>\n<li>线程将按照它们<strong>发出请求的顺序来获取锁</strong></li>\n</ul>\n<p>非公平锁就是：</p>\n<ul>\n<li>线程发出请求的时可以**“插队”**获取锁</li>\n</ul>\n<p>Lock和synchronize都是<strong>默认使用非公平锁的</strong>。如果不是必要的情况下，不要使用公平锁</p>\n<ul>\n<li>公平锁会来带一些性能的消耗的</li>\n</ul>\n<h1 class=\"heading\" data-id=\"heading-16\">四、最后</h1>\n<p>本文讲了synchronized内置锁和简单描述了一下Lock显式锁，总得来说：</p>\n<ul>\n<li><strong>synchronized好用，简单，性能不差</strong></li>\n<li>没有使用到Lock显式锁的特性就不要使用Lock锁了。</li>\n</ul>\n<p>Lock锁这里只是介绍了一些些，<strong>明天会详解它的相关子类和需要注意的地方，敬请期待</strong>~</p>\n<p>之前在学习操作系统的时候根据《计算机操作系统-汤小丹》这本书也做了一点点笔记，都是比较<strong>浅显的知识点</strong>。或许对大家有帮助</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njg5MDA5NA%3D%3D%26mid%3D2247484186%26idx%3D2%26sn%3De272d8e95a5677c75c21b058a064f0f8%26chksm%3Debd7421bdca0cb0d9d15da009894c8d1b503acbeb601af180ad7408bf2ff191de4995cccf0aa%23rd\" rel=\"nofollow noopener noreferrer\">操作系统第一篇【引论】</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njg5MDA5NA%3D%3D%26mid%3D2247484186%26idx%3D3%26sn%3Dcefa7781f34e2244b5eea83b7e242c3e%26chksm%3Debd7421bdca0cb0de76d3f1705f43cbdd41d0c9eb58cf4b55f32793d4f9f8ae2efbd539c8c30%23rd\" rel=\"nofollow noopener noreferrer\">操作系统第二篇【进程管理】</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njg5MDA5NA%3D%3D%26mid%3D2247484186%26idx%3D4%26sn%3Dc8d83a508f7a87ad49dcfd6965779129%26chksm%3Debd7421bdca0cb0d309a3c444240b3677755c7b3083e9dce5e7d70d8d5dbb6e57bd14a7f38fc%23rd\" rel=\"nofollow noopener noreferrer\">操作系统第三篇【线程】</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njg5MDA5NA%3D%3D%26mid%3D2247484186%26idx%3D5%26sn%3D54bda03c277af5283c9daff07fff4246%26chksm%3Debd7421bdca0cb0da6de8e2211049a7b9e95b0d4f5a76b9f6c68682d8648ecc71d92b12bcde3%23rd\" rel=\"nofollow noopener noreferrer\">操作系统第四篇【处理机调度】</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njg5MDA5NA%3D%3D%26mid%3D2247484186%26idx%3D6%26sn%3Dfbe59571e8469fe953404cc632723646%26chksm%3Debd7421bdca0cb0d85c3a6651e765821d8e0b8aba43e2358d6f3be550a10e0b3ef02bc603715%23rd\" rel=\"nofollow noopener noreferrer\">操作系统第五篇【死锁】</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njg5MDA5NA%3D%3D%26mid%3D2247484186%26idx%3D7%26sn%3D3e027ee134e65c5cfae67218ce69a06a%26chksm%3Debd7421bdca0cb0d29437cad1483f5f59cf1ea9da57bf64900e52a2cd3d63e8fbaaeef9f2c51%23rd\" rel=\"nofollow noopener noreferrer\">操作系统第六篇【存储器管理】</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njg5MDA5NA%3D%3D%26mid%3D2247484186%26idx%3D8%26sn%3D01562e2dee725260460898e31edd8d29%26chksm%3Debd7421bdca0cb0d9011b0e63154b0052ede92030537c9be3fcf3a34dac059f79926bdaf98ca%23rd\" rel=\"nofollow noopener noreferrer\">操作系统第七篇【设备管理】</a></li>\n</ul>\n<p>参考资料：</p>\n<ul>\n<li>《Java核心技术卷一》</li>\n<li>《Java并发编程实战》</li>\n<li>《计算机操作系统-汤小丹》</li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fpanweiwei1994%2Farticle%2Fdetails%2F78483167\" rel=\"nofollow noopener noreferrer\">blog.csdn.net/panweiwei19…</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Fdolphin0520%2Fcategory%2F602384.html\" rel=\"nofollow noopener noreferrer\">www.cnblogs.com/dolphin0520…</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fchenssy%2Farticle%2Fcategory%2F3145247\" rel=\"nofollow noopener noreferrer\">blog.csdn.net/chenssy/art…</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fu012465296%2Farticle%2Fdetails%2F53022317\" rel=\"nofollow noopener noreferrer\">blog.csdn.net/u012465296/…</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fwxd0108%2Fp%2F5479442.html\" rel=\"nofollow noopener noreferrer\">www.cnblogs.com/wxd0108/p/5…</a></li>\n</ul>\n<blockquote>\n<p>如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章，想要获取更多的Java资源的同学，可以<strong>关注微信公众号:Java3y</strong>。</p>\n</blockquote>\n<p><strong>文章的目录导航</strong>：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fzhongfucheng.bitcron.com%2Fpost%2Fshou-ji%2Fwen-zhang-dao-hang\" rel=\"nofollow noopener noreferrer\">zhongfucheng.bitcron.com/post/shou-j…</a></li>\n</ul>\n"
    },
    {
      "articleID": 5,
      "type": 1,
      "title": "手把手教你写vue裁切预览组件",
      "publishTime": "2018年 05月 03日",
      "praise": "13",
      "tag": ["GitHub", "JavaScript"],
      "author": "饭妖精",
      "authorImg": "https://avatars.githubusercontent.com/u/8822358?v=3",
      "comment": [
      {
        "username": "zjzhang",
        "commentTime": "48分钟前",
        "commentText": "先顶后学习",
        "admire":"0",
        "commentImg":"https://user-gold-cdn.xitu.io/2017/6/28/d6dd839be53c4b752a28db8621aacd9c?imageView2/1/w/100/h/100/q/85/interlace/1"
      }
      ],
      "preview":"最终效果： https://qiuyaofan.github.io/vue-crop-demo/ 源码地址： https://github.com/qiuyaofan/vue-crop 1.引用所有插件：SRC/COMPONENTS/INDEX.JS 2.全局调用插件：SRC/MAIN.JS （ ...",
      "content": "<blockquote>\n<p>vue版本裁切工具，包含预览功能</p>\n</blockquote>\n<p>最终效果： <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fqiuyaofan.github.io%2Fvue-crop-demo%2F\" rel=\"nofollow noopener noreferrer\">qiuyaofan.github.io/vue-crop-de…</a></p>\n<p>源码地址： <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fqiuyaofan%2Fvue-crop\" rel=\"nofollow noopener noreferrer\">github.com/qiuyaofan/v…</a></p>\n<h4 class=\"heading\" data-id=\"heading-0\">第一步：先用vue-cli安装脚手架（不会安装的看 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fvue-cli\" rel=\"nofollow noopener noreferrer\">vue-cli官网</a>）</h4>\n<pre><code class=\"hljs bash\" lang=\"bash\">// 初始化vue-cli\nvue init webpack my-plugin\n</code></pre><h4 class=\"heading\" data-id=\"heading-1\">第二步：创建文件</h4>\n<pre><code class=\"hljs bash\" lang=\"bash\">新建src/views/validSlideDemo.vue,\n\nsrc/components里新建VueCrop/index.js,VueCrop.vue，\n\n在routes/index.js配置访问路由（具体看github源码）\n</code></pre><p>最终生成的文件结构如下图:</p>\n<p></p><figure><img alt=\"文件结构\" class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/163254c6cb80bc30?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"616\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/163254c6cb80bc30?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-2\">第三步：注册组件</h4>\n<h5 class=\"heading\" data-id=\"heading-3\">1.引用所有插件：src/components/index.js</h5>\n<pre><code class=\"hljs bash\" lang=\"bash\">// 导入插件入口文件\nimport VueCrop from <span class=\"hljs-string\">'./VueCrop/index.js'</span>\nconst install = <span class=\"hljs-keyword\">function</span> (Vue, opts = {}) {\n  /* 如果已安装就跳过 */\n  <span class=\"hljs-keyword\">if</span> (install.installed) <span class=\"hljs-built_in\">return</span>\n  \n  // 注册插件\n  Vue.component(VueCrop.name, VueCrop)\n}\n\n// 全局情况下注册插件\n<span class=\"hljs-keyword\">if</span> (typeof window !== <span class=\"hljs-string\">'undefined'</span> &amp;&amp; window.Vue) {\n  install(window.Vue)\n}\n\n<span class=\"hljs-built_in\">export</span> {\n  install,\n  // 此处是为了兼容在vue内单独引入这个插件，如果是main.js全局引入就可以去掉\n  VueCrop\n}\n</code></pre><h5 class=\"heading\" data-id=\"heading-4\">2.全局调用插件：src/main.js （ <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fplugins.html\" rel=\"nofollow noopener noreferrer\">vue plugins官方文档解说install</a>）</h5>\n<pre><code class=\"hljs bash\" lang=\"bash\">import Vue from <span class=\"hljs-string\">'vue'</span>\nimport App from <span class=\"hljs-string\">'./App'</span>\nimport router from <span class=\"hljs-string\">'./router'</span>\n\n// 新加的：导入入口文件\nimport { install } from <span class=\"hljs-string\">'src/components/index.js'</span>\n\n// 全局调用，相当于调用 `MyPlugin.install(Vue)`\nVue.use(install)\n\nVue.config.productionTip = <span class=\"hljs-literal\">false</span>\n/* eslint-disable no-new */\nnew Vue({\n  el: <span class=\"hljs-string\">'#app'</span>,\n  router,\n  components: { App },\n  template: <span class=\"hljs-string\">'&lt;App/&gt;'</span>\n})\n</code></pre><h5 class=\"heading\" data-id=\"heading-5\">3.VueCrop入口文件调用VueCrop.vue：src/components/VueCrop/index.js</h5>\n<pre><code class=\"hljs bash\" lang=\"bash\">// 导入vue\nimport VueCrop from <span class=\"hljs-string\">'./VueCrop.vue'</span>\n\n// Vue.js 的插件应当有一个公开方法 install 。这个方法的第一个参数是 Vue 构造器\nVueCrop.install = <span class=\"hljs-keyword\">function</span> (Vue) {\n  // 注册组件\n  Vue.component(VueCrop.name, VueCrop)\n}\n\n<span class=\"hljs-built_in\">export</span> default VueCrop\n</code></pre><h5 class=\"heading\" data-id=\"heading-6\">小结：我一开始一直有个误解，以为myPlugin.install是vue的一个方法，其实不是，他只是我们构造plugin识的一个公开方法，可以理解为原生js中的构造函数的方法：</h5>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">MyPlugin</span></span>(){\n  console.info(<span class=\"hljs-string\">'构造函数'</span>)\n}\nMyPlugin.prototype.install=<span class=\"hljs-keyword\">function</span>(vue,options){\n\tconsole.info(<span class=\"hljs-string\">'构造器vue:'</span>+vue);\n}\n</code></pre><p>而真正注册组件的是：Vue.component()</p>\n<p>所以，vue插件注册的过程是：</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">1.调用main.js中：\nimport { install } from <span class=\"hljs-string\">'src/components/index.js'</span>\nvue.use(install)\n\n2.index.js添加install方法，调用Vue.component注册组件\n\n3.组件内的index.js同所有组件的index.js一样\n</code></pre><h4 class=\"heading\" data-id=\"heading-7\">第四步：设计开发自己的组件，构建组件结构</h4>\n<blockquote>\n<p>在此之前，可以先了解下组件的命名规范等，可参考文章 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5ada9b586fb9a07aaf34c746%3Futm_source%3Dgold_browser_extension\" rel=\"nofollow noopener noreferrer\">掘金：Vue前端开发规范</a>，其中第2点有详细讲解</p>\n</blockquote>\n<p>首先，确定自己的调用方式和需要暴露的参数</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">&lt;vue-crop\n:crop-url=<span class=\"hljs-string\">\"cropUrl1\"</span>\n:ratio=<span class=\"hljs-string\">\"ratio\"</span>\n:height=<span class=\"hljs-string\">\"460\"</span>\n:width=<span class=\"hljs-string\">\"460\"</span>\n:previewJson=<span class=\"hljs-string\">\"previewJson1\"</span>\nclass=<span class=\"hljs-string\">\"c-crop--preview_right\"</span>\n@afterCrop=<span class=\"hljs-string\">\"afterCrop\"</span>\n&gt;\n&gt;\n</code></pre><p>其中，@afterCrop=\"afterCrop\"是裁切完成的回调函数，其他是属性配置</p>\n<p>在组件src/components/VueCrop/VueCrop.vue内，可以用this.$emit('afterCrop')触发demo里的afterCrop事件</p>\n<p>组件结构上，主要分为：裁切主要部分，选框组件（VueCropTool.vue）,裁切框宽度、位置坐标等计算（VueCropMove.js）,拖拽事件注册公共js（components/utils/draggable.js）</p>\n<h5 class=\"heading\" data-id=\"heading-8\">draggable.js是参照element里的，修改了一部分，源码如下</h5>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-built_in\">export</span> default <span class=\"hljs-keyword\">function</span> (element, options) {\n  const moveFn = <span class=\"hljs-keyword\">function</span> (event) {\n    <span class=\"hljs-keyword\">if</span> (options.drag) {\n      options.drag(event)\n    }\n  }\n  // mousedown fn\n  const downFn = <span class=\"hljs-keyword\">function</span> (event) {\n    <span class=\"hljs-keyword\">if</span> (options.start) {\n    \t// 调用参数中start函数\n      options.start(event)\n    }\n  }\n  // mouseup fn\n  const upFn = <span class=\"hljs-keyword\">function</span> (event) {\n    document.removeEventListener(<span class=\"hljs-string\">'mousemove'</span>, moveFn)\n    document.removeEventListener(<span class=\"hljs-string\">'mouseup'</span>, upFn)\n    document.onselectstart = null\n    document.ondragstart = null\n\n    <span class=\"hljs-keyword\">if</span> (options.end) {\n    \t// 调用参数中end函数\n      options.end(event)\n    }\n  }\n  // 绑定事件\n  element.addEventListener(<span class=\"hljs-string\">'mousedown'</span>, event =&gt; {\n    <span class=\"hljs-keyword\">if</span> (options.stop &amp;&amp; options.stop(event, element) === <span class=\"hljs-literal\">false</span>) {\n      <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>\n    }\n    document.onselectstart = <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n      <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>\n    }\n    document.ondragstart = <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n      <span class=\"hljs-built_in\">return</span> <span class=\"hljs-literal\">false</span>\n    }\n    document.addEventListener(<span class=\"hljs-string\">'mousedown'</span>, downFn)\n    document.addEventListener(<span class=\"hljs-string\">'mousemove'</span>, moveFn)\n    document.addEventListener(<span class=\"hljs-string\">'mouseup'</span>, upFn)\n  })\n}\n\n</code></pre><h5 class=\"heading\" data-id=\"heading-9\">VueCropTool.vue使用如下</h5>\n<pre><code class=\"hljs bash\" lang=\"bash\">draggable(this.<span class=\"hljs-variable\">$el</span>.querySelector(<span class=\"hljs-string\">'.c-crop--drap_screen'</span>), {\n\tstart: (event) =&gt; {\n\t  this.startPos = [event.x, event.y]\n\t},\n\tdrag: (event) =&gt; {\n\t  this.handleDragLocation(event)\n\t},\n\tend: (event) =&gt; {\n\t  this.handleDragLocation(event)\n\t}\n})\n</code></pre><p>剩下的就是逻辑的事了，今天就分享到这里啦～喜欢这个插件可以去 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fqiuyaofan%2Fvue-crop\" rel=\"nofollow noopener noreferrer\">github star~</a></p>\n"
    },
    {
      "articleID": 6,
      "type": 1,
      "title": "如何在疲劳的JS世界中持续学习",
      "publishTime": "2018年 05月 02日",
      "praise": "583",
      "tag": ["Twitter"],
      "author": "蚂蚁金服数据体验技术",
      "authorImg": "https://user-gold-cdn.xitu.io/2017/9/7/217d533ac647f900de33fcd6f7d64c64?imageView2/1/w/100/h/100/q/85/interlace/1",
      "comment": [
        {
          "username": "seognil",
          "commentTime": "16分钟前",
          "commentText": "：现在前端要学的太多了，如何对付前端疲劳？\n：学爆\n\n流下委屈的眼泪.jpg",
          "admire":"0",
          "commentImg":"https://avatars.githubusercontent.com/u/5526096?v=3"
        },
        {
          "username": "思考ing",
          "commentTime": "2小时前",
          "commentText": "看样子，得重新恶补英语呀。",
          "admire":"0",
          "commentImg":"https://lc-mhke0kuv.cn-n1.lcfile.com/1vAbR4zqE8tRPbd3AmQPaHaNag84P3AmNudjJQNu"
        },
        {
          "username": "zsirfs",
          "commentTime": "3小时前",
          "commentText": "然后作为pragramer，去学习英语。",
          "admire":"0",
          "commentImg":"https://user-gold-cdn.xitu.io/2017/7/6/8ce0fc51cda45bb52b25edba1162f285?imageView2/1/w/100/h/100/q/85/interlace/1"
        }
      ],
      "preview":"本文翻译自《Stay updated in JS fatigue universe》，并对内容有所补充和修改。 部分内容参考《HOW TO KEEP UP TO DATE ON  FRONT-END TECHNOLOGIES》",
      "content": "<blockquote>\n<p>作者简介 cnfi 蚂蚁金服·数据体验技术团队</p>\n</blockquote>\n<p><span style=\"color: rgb(140, 140, 140);\" data-type=\"color\">本文翻译自</span><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2F%40alonronin%2Fstay-updated-in-js-fatigue-universe-3bf5c0d671a4\" rel=\"nofollow noopener noreferrer\">《Stay updated in JS fatigue&nbsp;universe》</a><span style=\"color: rgb(140, 140, 140);\" data-type=\"color\">，并对内容有所补充和修改。</span>\n<span style=\"color: rgb(140, 140, 140);\" data-type=\"color\">部分内容参考</span><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fuptodate.frontendrescue.org%2F\" rel=\"nofollow noopener noreferrer\">《HOW TO KEEP UP TO DATE ON&nbsp;&nbsp;FRONT-END TECHNOLOGIES》</a></p>\n<blockquote>\n<p>想要在“每天都有新事物冒出来”的前端世界中跟上步伐，眼下已经成为了一个艰巨的任务。\n很多人都有这样的感觉：不需要几个月你的技术就会过时，全新的炒作、类库、框架总会让你迷失，面对这场比赛，你只能选择退出。</p>\n</blockquote>\n<p>我的许多同事都想知道我是如何设法保持最新的状态，并且仍能完成我的日常工作。在这篇文章中，我将分享我的日常生活，并告诉你如何找到有用的信息。</p>\n<h3 class=\"heading\" data-id=\"heading-0\">关注大牛</h3>\n<p>我的许多资源来自twitter。去follow那些JavaScript社区的领袖们，可以让我很轻松的获取到有意思的东西，尽管找到这些人是多么地不容易。</p>\n<p>由于我们非常关注开源社区，于是Github成了我的主要来源。 首先找到一个业界顶级的项目（比如React），点击“Contributors”标签，可以看到这些主要贡献者的档案。 他们中的一些人拥有twitter帐户，他们经常会发布一些有价值的信息。</p>\n<p></p><figure><img alt=\"20180429110352.png | center | 747x577\" class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b9ccb2dfac?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"989\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b9ccb2dfac?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-1\">业界大牛不完全名单</h3>\n<p><span style=\"color: rgb(51, 51, 51);\" data-type=\"color\"><span style=\"background-color: rgb(255, 255, 255);\" data-type=\"background\"><strong>Addy Osmani</strong></span></span></p>\n<div class=\"bi-table\">\n  <table>\n    <colgroup>\n      <col width=\"188px\">\n      <col width=\"188px\">\n      <col width=\"71px\">\n      <col width=\"299px\">\n    </colgroup>\n    <tbody>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"3\">\n          <div data-type=\"p\">\n            <div data-width=\"166\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b9f6868a69?w=400&amp;h=400&amp;f=jpeg&amp;s=27735\" data-align=\"\" data-display=\"block\" data-type=\"image\">\n              <img width=\"166\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b9f6868a69?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"400\" data-height=\"400\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/svg&gt;\">\n            </div>\n          </div>\n        </td>\n        <td colspan=\"1\" rowspan=\"3\">\n          <h4 data-type=\"h\" data-id=\"heading-2\">\n            <a href=\"#9972lt\" id=\"\" class=\"anchor\"></a>\n          </h4>\n          <div data-type=\"p\">TodoMVC、Material-Design-Lite、Yeoman等项目作者，Google Chrome工程经理</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">主页</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">https://addyosmani.com/</div>\n        </td>\n      </tr>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">github</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">https://github.com/addyosmani</div>\n        </td>\n      </tr>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">twitter</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">https://twitter.com/addyosmani</div>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n<p><span style=\"color: rgb(51, 51, 51);\" data-type=\"color\"><span style=\"background-color: rgb(255, 255, 255);\" data-type=\"background\"><strong>Lea Verou</strong></span></span></p>\n<div class=\"bi-table\">\n  <table>\n    <colgroup>\n      <col width=\"188px\">\n      <col width=\"188px\">\n      <col width=\"78px\">\n      <col width=\"294px\">\n    </colgroup>\n    <tbody>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"3\">\n          <div data-type=\"p\">\n            <div data-width=\"166\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b8b4e775f5?w=300&amp;h=300&amp;f=png&amp;s=11048\" data-align=\"\" data-display=\"block\" data-type=\"image\">\n              <img width=\"166\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b8b4e775f5?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"300\" data-height=\"300\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/svg&gt;\">\n            </div>\n          </div>\n        </td>\n        <td colspan=\"1\" rowspan=\"3\">\n          <div data-type=\"p\"></div>\n          <div data-type=\"p\"></div>\n          <div data-type=\"p\">麻省理工学院HCI研究员， W3C-CSSWG成员，github多个项目作者</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">主页</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">http://lea.verou.me/</div>\n        </td>\n      </tr>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">github</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">https://github.com/LeaVerou</div>\n        </td>\n      </tr>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">推特</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">https://twitter.com/leaverou</div>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n<p><span style=\"color: rgb(51, 51, 51);\" data-type=\"color\"><span style=\"background-color: rgb(255, 255, 255);\" data-type=\"background\"><strong>Evan You 尤雨溪</strong></span></span></p>\n<div class=\"bi-table\">\n  <table>\n    <colgroup>\n      <col width=\"191px\">\n      <col width=\"190px\">\n      <col width=\"80px\">\n      <col width=\"285px\">\n    </colgroup>\n    <tbody>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"3\">\n          <div data-type=\"p\">\n            <div data-width=\"170\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b8b5953ab3?w=460&amp;h=460&amp;f=jpeg&amp;s=34245\" data-align=\"\" data-display=\"block\" data-type=\"image\">\n              <img width=\"170\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b8b5953ab3?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"460\" data-height=\"460\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;460&quot; height=&quot;460&quot;&gt;&lt;/svg&gt;\">\n            </div>\n          </div>\n        </td>\n        <td colspan=\"1\" rowspan=\"3\">\n          <div data-type=\"p\"></div>\n          <div data-type=\"p\"></div>\n          <div data-type=\"p\">大名鼎鼎的Vue.js作者，前端布道者，业界大V</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">主页</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">http://evanyou.me/</div>\n        </td>\n      </tr>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">github</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">https://github.com/yyx990803</div>\n        </td>\n      </tr>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">推特</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">https://twitter.com/youyuxi</div>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n<p><span style=\"color: rgb(51, 51, 51);\" data-type=\"color\"><span style=\"background-color: rgb(255, 255, 255);\" data-type=\"background\"><strong>Axel Rauschmayer</strong></span></span></p>\n<div class=\"bi-table\">\n  <table>\n    <colgroup>\n      <col width=\"194px\">\n      <col width=\"188px\">\n      <col width=\"77px\">\n      <col width=\"288px\">\n    </colgroup>\n    <tbody>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"3\">\n          <div data-type=\"p\">\n            <div data-width=\"172\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b8b5453e4f?w=400&amp;h=400&amp;f=jpeg&amp;s=21547\" data-align=\"\" data-display=\"block\" data-type=\"image\">\n              <img width=\"172\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b8b5453e4f?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"400\" data-height=\"400\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/svg&gt;\">\n            </div>\n          </div>\n        </td>\n        <td colspan=\"1\" rowspan=\"3\">\n          <div data-type=\"p\"></div>\n          <div data-type=\"p\"></div>\n          <div data-type=\"p\">2ality博主，写有《Speaking JavaScript》等著作，ES.next News刊物主编</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">主页</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">http://2ality.com/</div>\n        </td>\n      </tr>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">github</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\"></div>\n        </td>\n      </tr>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">推特</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">https://twitter.com/rauschma</div>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n<p><span style=\"color: rgb(51, 51, 51);\" data-type=\"color\"><span style=\"background-color: rgb(255, 255, 255);\" data-type=\"background\"><strong>Ben Alman</strong></span></span></p>\n<div class=\"bi-table\">\n  <table>\n    <colgroup>\n      <col width=\"195px\">\n      <col width=\"188px\">\n      <col width=\"86px\">\n      <col width=\"279px\">\n    </colgroup>\n    <tbody>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"3\">\n          <div data-type=\"p\">\n            <div data-width=\"174\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b8b581891f?w=400&amp;h=400&amp;f=jpeg&amp;s=26263\" data-align=\"\" data-display=\"block\" data-type=\"image\">\n              <img width=\"174\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b8b581891f?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"400\" data-height=\"400\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/svg&gt;\">\n            </div>\n          </div>\n        </td>\n        <td colspan=\"1\" rowspan=\"3\">\n          <div data-type=\"p\"></div>\n          <div data-type=\"p\"></div>\n          <div data-type=\"p\"></div>\n          <div data-type=\"p\">GruntJS作者，jQuery界大神，开发了jQuery BBQ等大量插件</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">主页</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">http://benalman.com/</div>\n        </td>\n      </tr>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">github</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">https://github.com/cowboy</div>\n        </td>\n      </tr>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">推特</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">https://twitter.com/cowboy</div>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n<p><span style=\"color: rgb(51, 51, 51);\" data-type=\"color\"><span style=\"background-color: rgb(255, 255, 255);\" data-type=\"background\"><strong>Nicholas C. Zakas</strong></span></span></p>\n<div class=\"bi-table\">\n  <table>\n    <colgroup>\n      <col width=\"188px\">\n      <col width=\"188px\">\n      <col width=\"100px\">\n      <col width=\"272px\">\n    </colgroup>\n    <tbody>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"3\">\n          <div data-type=\"p\">\n            <div data-width=\"167\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b8e418ca7d?w=400&amp;h=400&amp;f=jpeg&amp;s=15493\" data-align=\"\" data-display=\"block\" data-type=\"image\">\n              <img width=\"167\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b8e418ca7d?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"400\" data-height=\"400\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/svg&gt;\">\n            </div>\n          </div>\n        </td>\n        <td colspan=\"1\" rowspan=\"3\">\n          <div data-type=\"p\"></div>\n          <div data-type=\"p\"></div>\n          <div data-type=\"p\"></div>\n          <div data-type=\"p\">著名的《JavaScript高级程序设计》作者，JS布道者</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">主页</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">https://www.nczonline.net/</div>\n        </td>\n      </tr>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">github</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\"></div>\n        </td>\n      </tr>\n      <tr height=\"34px\">\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">推特</div>\n        </td>\n        <td colspan=\"1\" rowspan=\"1\">\n          <div data-type=\"p\">https://twitter.com/slicknet</div>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n<h3 class=\"heading\" data-id=\"heading-3\">探索新项目</h3>\n<p>另一个巨大的信息来源地，是Github的“Explore”标签。那里有无尽的内容如“Topics”、“Trends”、“Resources”...，你完全可以呆上几天。</p>\n<p>打开 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Ftrending\" rel=\"nofollow noopener noreferrer\">github.com/trending</a> 可以看到最新的趋势库和开发者。 你还可以根据语言和时间跨度（今天，本周，本月）对它们进行过滤。</p>\n<p></p><figure><img alt=\"20180429110717.png | center | 747x496\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b8f23ea13a?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"850\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;850&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-4\">看最好的资讯</h3>\n<p>我每天都会访问这些网站。 我喜欢他们，因为他们没有垃圾邮件，他们的所有内容都来自社区。</p>\n<h4 class=\"heading\" data-id=\"heading-5\">EchoJS</h4>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.echojs.com%2F\" rel=\"nofollow noopener noreferrer\">www.echojs.com/</a></p>\n<p></p><figure><img alt=\"20180429110936.png | center | 747x438\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b8e41bf3ae?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"749\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;749&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-6\">DailyJS</h4>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2Fdailyjs\" rel=\"nofollow noopener noreferrer\">medium.com/dailyjs/</a></p>\n<p></p><figure><img alt=\"20180429111337.png | center | 747x549\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b910c38556?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"941\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;941&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-7\">Front-End Front</h4>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Ffrontendfront.com%2F\" rel=\"nofollow noopener noreferrer\">frontendfront.com/</a></p>\n<p></p><figure><img alt=\"20180429111227.png | center | 747x497\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b91114ee07?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"851\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;851&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p><span style=\"color: rgb(51, 51, 51);\" data-type=\"color\"><span style=\"background-color: rgb(255, 255, 255);\" data-type=\"background\">另外，我也会订阅以下两个前端领域的技术刊物</span></span></p>\n<h4 class=\"heading\" data-id=\"heading-8\">ES.next News</h4>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fesnextnews.com%2F\" rel=\"nofollow noopener noreferrer\">esnextnews.com/</a></p>\n<p></p><figure><img alt=\"20180430165238.png | center | 747x367\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b91f302a8f?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"628\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;628&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-9\">Web Design Weekly</h4>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fweb-design-weekly.com%2F\" rel=\"nofollow noopener noreferrer\">web-design-weekly.com/</a></p>\n<p></p><figure><img alt=\"20180430165218.png | center | 747x419\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/163200b93740518f?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"718\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;718&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-10\">怎么抽出时间？</h3>\n<p>很多人认为，白天忙于工作，晚上回家后又太累，所以根本无法抽出时间再去消化与工作相关的信息。当然我也不认为你应该在业余时间去做这件事。从“时间管理哲学”的角度看，这是一种非常糟糕的做法。</p>\n<p>在我看来，在工作时间内去丰富你的内在是一种不错的方式。每天早上到达工作岗位后，我开始浏览新闻网站。 如果我发现一些有趣的事情，我会将它加入书签供以后阅读。毕竟我们并不是机器，一天的工作中通常会有几个休息的间隙。 即使没有，我也会每天花半小时来阅读这些书签链接。每天下班之前，我会简要浏览github的“Trends”页面，并start一些我认为有意思的项目。 我会在30分钟内回顾它们，在我的下一个POC中小试牛刀，甚至在工作中使用它们。</p>\n<h3 class=\"heading\" data-id=\"heading-11\">做一名贡献者</h3>\n<p>贡献可以成为一个很好的信息来源，同时也让你有能力亲自动手练习你所学到的东西。\n你可以在<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fstackoverflow.com%2F\" rel=\"nofollow noopener noreferrer\">Stack Overflow</a>提出问题或者回答问题。在Github上提issue、提request、参与讨论等等，这将对你的知识和技能带来巨大的帮助。</p>\n<h3 class=\"heading\" data-id=\"heading-12\">总结出自己的学习方法</h3>\n<p><span style=\"color: rgb(51, 51, 51);\" data-type=\"color\"><span style=\"background-color: rgb(255, 255, 255);\" data-type=\"background\">总结出一套自己的方法来跟上最新方向是很重要的. 来看看这些厉害的开发者们是怎么做的吧!</span></span></p>\n<p><strong>Axel Rauschmayer：</strong></p>\n<blockquote>\n<p>我推荐读以下3个资源来跟上最新发展.\n1.推特. 先关注些你认识的知名前端开发者, 比如你经常用的某个库的作者. 然后从他的关注列表里面去挖掘, 迟早你会看到一些有用的推特.\n2.<a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.echojs.com%2F\" rel=\"nofollow noopener noreferrer\">Echo JS</a>&nbsp;是个 JavaScript 新闻站. 它的布局和&nbsp;<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fnews.ycombinator.com%2F\" rel=\"nofollow noopener noreferrer\">Hacker News</a>&nbsp;类似.\n3.关注这些&nbsp;<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fcooperpress.com%2F\" rel=\"nofollow noopener noreferrer\">每周邮件</a>&nbsp;(那啥: 我是 JavaScript 每周新闻的编辑).</p>\n</blockquote>\n<p><strong>Alex Sexton：</strong></p>\n<blockquote>\n<p>我发现对我来说, 只有不断实践才能跟上最新发展.\n我在推特上关注了很多前端界的人, 也读博客和编程界新闻, 但我发现实践比纯读更能学到东西.\n当我想学一样东西的时候, 我就直接开始做项目, 然后从中不断学习, 理解核心概念.</p>\n</blockquote>\n<p><strong>Addy Osmani：</strong></p>\n<blockquote>\n<p>为了知道前端界都在发生些什么, 我经常刷推特和 G+.\n对于那些我经常使用的工具和库, 我会关注下作者的最新情况, 这样才能知道接下来会有什么发展.\n关注下那些制定网络标准的人也很有好处, 这样你才能知道接下来的几年会有什么发展.</p>\n</blockquote>\n<p><strong>Lea Verou：</strong></p>\n<blockquote>\n<p>有几个订阅源(feeds) 我天天都读\n我关注了很多人, 包括 Web 标准的制定者, 以及开发浏览器的, 还有厉害的其他类别的开发者.\n我偶尔会阅读标准, 有些很好理解而且是一手资讯, W3C邮件列表(W3C mailing lists) 也很有帮助: 你在新技术出现的那一刻就能开始学习他们, 甚至你可以影响到这些新技术的发展!\n参加会议</p>\n</blockquote>\n<p>End.</p>\n<blockquote>\n<p>对我们团队感兴趣的可以关注专栏，关注<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FProtoTeam%2Fblog\" rel=\"nofollow noopener noreferrer\">github</a>或者发送简历至'tao.qit####alibaba-inc.com'.replace('####', '@')，欢迎有志之士加入~</p>\n</blockquote>\n<p>原文地址：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FProtoTeam%2Fblog%2Fblob%2Fmaster%2F201805%2F1.md\" rel=\"nofollow noopener noreferrer\">github.com/ProtoTeam/b…</a></p>\n"
    },
    {
      "articleID": 7,
      "type": 1,
      "title": "好用的npm包：debug",
      "publishTime": "2018年 05月 03日",
      "praise": "42",
      "tag": ["NPM", "Debug"],
      "author": "阿里巴巴TXD",
      "authorImg": "https://user-gold-cdn.xitu.io/2018/4/18/162d7994bb46b836?imageView2/1/w/100/h/100/q/85/interlace/1",
      "comment": [
        {
          "username": "happyyi",
          "commentTime": "4小时前",
          "commentText": "请问那个佛祖和那个英文字母输出是什么东西生成的",
          "admire":"0",
          "commentImg":"https://avatars0.githubusercontent.com/u/16871439?v=3"
        },
        {
          "username": "xcsweb",
          "commentTime": "5小时前",
          "commentText": "那个二维码是用哪个工具生成的",
          "admire":"0",
          "commentImg":"https://avatars0.githubusercontent.com/u/20693737?v=4"
        }
      ],
      "preview":"npm是JavaScript的包管理系统，提供通用的模块给其他开发者及工程内使用，类似于Java语言 的 maven库，设计师使用的素材库。 好用的npm包系列致力于挖掘一些好玩实用的npm包，聊些使用场景和实现思路。如果说程序员喜欢用自己的方式去实现别人已实现的东西，叫做重复造轮子, 那么这个系列就是带你去看飞轮海",
      "content":"<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16324d6921a3883e?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"900\" data-height=\"370\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16324d6921a3883e?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>npm是JavaScript的包管理系统，提供通用的模块给其他开发者及工程内使用，类似于Java语言 的 maven库，设计师使用的素材库。</p>\n<p>好用的npm包系列致力于挖掘一些好玩实用的npm包，聊些使用场景和实现思路。如果说程序员喜欢用自己的方式去实现别人已实现的东西，叫做重复造轮子, 那么这个系列就是带你去看飞轮海 。</p>\n<h3 class=\"heading\" data-id=\"heading-0\">基本介绍</h3>\n<blockquote>\n<p>DEBUG是一种计算机程序。马克2号（Harvard Mark II）编制程序的葛丽丝·霍波（Grace Hopper）是一位美国海军准将及计算机科学家，同时也是世界最早的一批程序设计师之一。有一天，她在调试设备时出现故障，拆开继电器后，发现有只飞蛾被夹扁在触点中间，从而“卡”住了机器的运行。于是，霍波诙谐的把程序故障统称为“臭虫（BUG）”，把排除程序故障叫DEBUG，而这奇怪的“称呼”，竟成为后来计算机领域的专业行话。</p>\n</blockquote>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fdebug\" rel=\"nofollow noopener noreferrer\">debug</a>在npm上周下载量1千八百万+，github上有6k+的star，是一个受关注的高频基础包。</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16324d94a4f98ea3?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1030\" data-height=\"526\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1030&quot; height=&quot;526&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-1\">基本使用场景</h3>\n<p>主要的功能包括命名空间和色彩定义、毫秒级时间差、printf语法变量替换，附带个函数性能比较的代码示例意思一下。</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">// 计算函数性能示例，传入一个纯数字数组，计算其平均值\n// avgA 使用 lodash 库中 sum 求和\n// avgB 使用ES5中 Array.proptype.reduce求和\nconst _ = require(<span class=\"hljs-string\">'lodash'</span>);\nconst debug = require(<span class=\"hljs-string\">'debug'</span>);\nconst debugA = debug(<span class=\"hljs-string\">'avgA:'</span>);\nconst debugB = debug(<span class=\"hljs-string\">'avgB:'</span>);\nconst <span class=\"hljs-built_in\">test</span>Fixture = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// 使用lodash sum求和\n<span class=\"hljs-keyword\">function</span> avgA(arr) {\n  <span class=\"hljs-built_in\">return</span> _.sum(arr) / arr.length;\n}\n\n// 使用原生reduce 求和\n<span class=\"hljs-keyword\">function</span> avgB(arr) {\n  <span class=\"hljs-built_in\">return</span> arr.reduce((cal, curr) =&gt; cal + curr, 0) / arr.length;\n}\n\nconst range = _.range(0, 10000000, 1);\nrange.forEach((index) =&gt; {\n  const result = avgA(<span class=\"hljs-built_in\">test</span>Fixture);\n  <span class=\"hljs-keyword\">if</span> (index % 1000000 === 0) {\n    debugA(<span class=\"hljs-string\">'time %d'</span>, index);\n  }\n})\n\nrange.forEach((index) =&gt; {\n  const result = avgB(<span class=\"hljs-built_in\">test</span>Fixture);\n  <span class=\"hljs-keyword\">if</span> (index % 1000000 === 0) {\n    debugB(<span class=\"hljs-string\">'time %d'</span>, index);\n  }\n})\n</code></pre><p>运行结果：</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16324de8b549d5a6?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"422\" data-height=\"293\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;422&quot; height=&quot;293&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-2\">使用场景1: 项目中根据环境开启debug</h4>\n<p>实际项目中，往往线下环境要开启调试，而线上环境要有条件开启。</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">const _ = require(<span class=\"hljs-string\">'lodash'</span>);\nconst debug = require(<span class=\"hljs-string\">'debug'</span>);\nconst debugA = debug(<span class=\"hljs-string\">'A:'</span>);\nconst debugB = debug(<span class=\"hljs-string\">'B:'</span>);\n\n// 当环境为production时，所有的debugA均不会输出\n\n<span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV === <span class=\"hljs-string\">'production'</span>) {\n  debugA.enabled = <span class=\"hljs-literal\">false</span>;\n}\n\ndebugA(<span class=\"hljs-string\">'hello world'</span>);\ndebugB(<span class=\"hljs-string\">'I am new to debug'</span>);\n</code></pre><p>运行结果：</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16324df87a7a3042?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"526\" data-height=\"32\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;526&quot; height=&quot;32&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-3\">使用场景2: 展示有意思的字符画</h4>\n<p>我们是一群有着特殊信仰的群体...</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16324e007e4f3fc9?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"459\" data-height=\"399\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;459&quot; height=&quot;399&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>顺便打个广告？AIS-TXD招人，前端/设计师快到碗里来，简历速投 txd-jobs@list.alibaba-inc.com</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16324df4e767509b?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"292\" data-height=\"346\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;292&quot; height=&quot;346&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-4\">代码分析</h3>\n<p>源码可以看下<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fvisionmedia%2Fdebug%2Ftree%2Fmaster\" rel=\"nofollow noopener noreferrer\">官方github</a>，基本逻辑如下:</p>\n<ul>\n<li>环境判断分发 Node.js 使用 <code>/node.js</code> , browser 使用 <code>/browser.js</code></li>\n<li><code>node.js</code> 部分 处理命令行启动指令，颜色定义和<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fnodejs.org%2Fapi%2Ftty.html\" rel=\"nofollow noopener noreferrer\">命令行展示库tty</a></li>\n<li><code>brower.js</code> 部分 处理js申明配置，颜色定义（枚举web安全色值），底层使用 <code>console.log</code></li>\n<li>common.js 部分，通用逻辑，包含实例创建、启用开关、色彩选择、printf 语法等</li>\n</ul>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16324e2350f93b1f?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"887\" data-height=\"482\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16324e2350f93b1f?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p>本期的npm包 debug 就介绍到这里，遇到有相似场景的情况就放心使用吧, 还有什么实用的npm包欢迎在留言区推荐啦。</p>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16324e355c795ab5?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"1237\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16324e355c795ab5?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>关注查看更多原创内容</p>\n<p>关注公众号投递简历\n（招聘视觉、交互、前端）</p>\n"
    },
    {
      "articleID": 8,
      "type": 1,
      "title": "前端将数据转化为弹幕效果的实现方式",
      "publishTime": "2018年 05月 02日",
      "praise": "390",
      "tag": ["CSS", "JavaScript"],
      "author": "OBKoro1",
      "authorImg": "https://user-gold-cdn.xitu.io/2017/12/22/1607d2bb387d545d?imageView2/1/w/100/h/100/q/85/interlace/1",
      "comment": [
        {
          "username": "百万强心剂",
          "commentTime": "19分钟前",
          "commentText": "看评论学习",
          "admire":"0",
          "commentImg":"https://user-gold-cdn.xitu.io/2018/3/27/16263245f76762db?imageView2/1/w/100/h/100/q/85/interlace/1"
        },
        {
          "username": "少林寺驻武当山办事处大神父张喇嘛",
          "commentTime": "4小时前",
          "commentText": "canvas + requestAnimationFrame",
          "admire":"0",
          "commentImg":"https://user-gold-cdn.xitu.io/2017/5/17/098d42048ec4bfab467b8089191c2097?imageView2/1/w/100/h/100/q/85/interlace/1"
        },
        {
          "username": "ylinwind-yo",
          "commentTime": "10小时前",
          "commentText": "看到dom操作都怕...",
          "admire":"0",
          "commentImg":"https://avatars2.githubusercontent.com/u/22312482?v=3"
        }
      ],
      "preview":"这个需求如题，大体上是将文章的评论数据，在文章的首图上面以弹幕的形式出现。当时在做这个需求的时候，花了挺多精力的，踩了很多坑，现将弹幕的实现思路写出来，如果喜欢的话可以点波赞/关注，支持一下，希望大家看完本文可以有所收获。",
      "content":"<h2 class=\"heading\" data-id=\"heading-0\">前言</h2>\n<p>这个需求如题，大体上是将文章的评论数据，在文章的首图上面以弹幕的形式出现。当时在做这个需求的时候，花了挺多精力的，踩了很多坑，现将弹幕的实现思路写出来，如果喜欢的话可以点波赞/关注，支持一下，希望大家看完本文可以有所收获。</p>\n<blockquote>\n<p>个人博客了解一下：<a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fobkoro1.com%2F\" rel=\"nofollow noopener noreferrer\">obkoro1.com</a></p>\n</blockquote>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-1\">实现效果：</h2>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/4/29/1631066f5f7cbcd4?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"415\" data-height=\"234\" src=\"https://user-gold-cdn.xitu.io/2018/4/29/1631066f5f7cbcd4?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-2\">实现原理：</h2>\n<p>实现弹幕的原理，并不算太复杂，耗费一些时间，怼一怼应该都可以做出来。</p>\n<ol>\n<li>获取弹幕数据。</li>\n<li>将弹幕设置为四个通道，每个通道最多只能出现两条弹幕。</li>\n<li>使用<code>setInterval</code>动态设置<code>dom</code>的<code>left</code>属性。</li>\n<li>使用dom的<code>offsetWidth</code>和屏幕的宽度判断元素是否滚动超出屏幕，然后移除dom。</li>\n</ol>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-3\">实现步骤：</h2>\n<h3 class=\"heading\" data-id=\"heading-4\">1. 首先看一下<code>html</code>的结构。</h3>\n<pre><code>    &lt;div class=\"detailImg\"&gt;\n        &lt;img src=\"url\"/&gt;\n        &lt;div id=\"barrageDiv\"&gt;\n            &lt;div id=\"barrageLayer1\"&gt;&lt;/div&gt;\n            &lt;div id=\"barrageLayer2\"&gt;&lt;/div&gt;\n            &lt;div id=\"barrageLayer3\"&gt;&lt;/div&gt;\n            &lt;div id=\"barrageLayer4\"&gt;&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;!--detailImg 设置relative， barrageDiv设置z-index在图片上面，以及图片的位置--&gt;\n      &lt;!---barrageLayer1~4 主要设置了一个top属性让四个div在各自的水平线上，形成四个通道-&gt;\n</code></pre>\n<p>关于这里的css样式，关键点都在上面说了，就注意一下上面通道是怎样形成的，就可以了。具体的样式也就不贴出来了，就根据各自的需求来吧。</p>\n<h3 class=\"heading\" data-id=\"heading-5\">2.获取弹幕所需要的数据。</h3>\n<p>要实现弹幕效果肯定需要有数据，这里就是发请求了。</p>\n<p>获取数据时，<strong>要考虑数据量，一次不可能全部都获取</strong>，可以一次获取一部分，当数据要加载完的时候，再次请求数据。</p>\n<p>这里要<strong>记录数据数据是否全部请求完成</strong>，如果请求完成，就可以不再发送数据，直接用之前获取的全部数据就可以了。</p>\n<h3 class=\"heading\" data-id=\"heading-6\">3.执行弹幕的函数。</h3>\n<p>弹幕数据获取后，就执行弹幕运行的函数，因为我在写弹幕函数的时候，设置了很多数据状态，这里就大概讲一下实现思路和关键部分代码。</p>\n<h4 class=\"heading\" data-id=\"heading-7\">弹幕函数包括的功能：</h4>\n<ol>\n<li>\n<p>定时获取数据(判断数据是否加载完毕)</p>\n</li>\n<li>\n<p>定时发射弹幕(判断通道是否闲置),传入弹幕所需要的内容，用户头像等。</p>\n</li>\n<li>\n<p>创建dom内容，根据传参生成弹幕div，设置style属性，根据控制弹幕数据数组的下标将div插入对应的dom中。</p>\n</li>\n<li>\n<p>采用定时器移动dom，这里是根据内容长度定义弹幕的移动速度。</p>\n</li>\n<li>\n<p>移动弹幕的过程中判断四个通道是否处于闲置状态，当dom移动出了屏幕，移动dom并且清除定时器。</p>\n<pre><code> function barrage(){\n     //第一部分先判断数据是否加载完成 这里是一个定时器，设置为15秒。\n     //如果数据还未加载完毕，就再次运行请求数据的接口，请求的页数可以 数组/每次请求的条数+1\n     //数据加载完毕就清除定时器。（我将定时器都保存在vue 组件的data里面） 清除的时候clearInterval(this.data);\n     \n     //定时发射\n      _this.barrageStatus.divStatus.intervalid=setInterval( selfTime,1100);\n      function selfTime() { \n         if(_this.dataNum&gt;=_this.barrageStatus.data.length){\n         //当dataNum大于等于数组的数量时，弹幕从头再来一遍\n           _this.dataNum=0;\n         }\n     //设置四个通道的变量，当这几个变量为false的时候，才可发射\n       if(divStatus.div1===false){\n         //这里只演示其中一个变量\n         divStatus.div1=true;\n         _this.dataNum++;                        \n        return barrageOut(_this.barrageStatus.data[_this.dataNum-1].content,_this.barrageStatus.data[_this.dataNum-1].commentator.headImgUrl,_this.dataNum);\n       }\n   };\n   \n   // 创建弹幕内容，自定义弹幕移动速度\n   function barrageOut(text,imgUrl,num) { \n     //text：弹幕的内容,imgUrl:用户的头像,num:数组的第几个\n     if(num%4==1){ \n     //根据数组下标 创建对应通道的节点 这里也演示其中一个\n       barrageLayer=document.getElementById('barrageLayer1');\n     }\n     \n     // 创建dom内容 定义dom style样式\n     let divBox = document.createElement('div');\n     let divBoxImg=document.createElement('span');\n     let divBoxText=document.createElement('span');\n     divBox.setAttribute('class','barrageDivClass');\n     divBoxText.innerHTML=text;\n     divBox.appendChild(divBoxImg);\n     divBoxImg.setAttribute('class','barrageDivClass_img');\n     divBoxImg.style.backgroundImage=`url(${imgUrl})`;\n     divBox.appendChild(divBoxText);\n     divBox.style.left=document.body.clientWidth+2000+'px';// 初始化left位置,一开始在屏幕的右侧\n     barrageLayer.appendChild(divBox);\n     \n     // 定时器移动dom，形成弹幕\n     let time,l=0;\n     time= setInterval(function(){\n       if(text.length&lt;15){ \n       // 这里可以根据需求自定义弹幕加载的速度\n         l=l-1;\n       }else{\n         l=l-2;\n       }\n       \n       //通过减少left属性移动这个div 从右往左移动\n      divBox.style.left = document.body.clientWidth+l+'px';\n       let delDiv=()=&gt;{\n             if(num%4==1){ \n              //在移动弹幕的过程中判断四个通道是否处于闲置状态 这里只演示其中一个\n               barrageLayer=document.getElementById('barrageLayer1');\n               if(barrageLayer.childNodes.length&lt;2){\n                 //判断弹幕数量，如果小于2，设为false，上面的定时器可以继续发射弹幕\n                 divStatus.div1=false;\n               }else{\n                 divStatus.div1=true;\n               }\n           }\n         }\n       }\n       if( l &lt;= (0-divBox.offsetWidth-120) ){ \n         if(_this.barrageStatus.divStatus.switch==true){ //弹幕开关\n           delDiv();\n           if(l &lt;= (0-divBox.offsetWidth-document.body.clientWidth) ){\n             //不断减少left属性，当小于这个内容的宽度,并且滚了120的时候\n               barrageLayer.removeChild(divBox); //移除dom\n               clearInterval(time);//清除这个div的定时器\n             }\n         }else{\n            clearInterval(time);//清除这个div的定时器\n         }\n       }\n     },20)\n   }\n }\n</code></pre>\n</li>\n</ol>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-8\">结语</h2>\n<p>这个弹幕需求，我是如上这么实现的，回头看看实现，发现还是有不少地方可以优化和拆分的，如果有更好的实现思路和本文有哪些错误，欢迎在评论区下面留言。</p>\n<h3 class=\"heading\" data-id=\"heading-9\">希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。</h3>\n<p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。</p>\n<p><strong><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fobkoro1.com%2F\" rel=\"nofollow noopener noreferrer\">个人blog</a></strong> and <strong><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fuser%2F58714f0eb123db4a2eb95372\" rel=\"nofollow noopener noreferrer\">掘金个人主页</a></strong></p>\n<p>关注我的订阅号，来一起学习成长。</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/1/1631b6f52f7e7015?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"344\" data-height=\"344\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;344&quot; height=&quot;344&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>以上2018.4.29</p>\n<h3 class=\"heading\" data-id=\"heading-10\">参考资料：</h3>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fnatural_live%2Farticle%2Fdetails%2F76571597\" rel=\"nofollow noopener noreferrer\">纯js 实现弹幕效果</a></p>\n"
    },
    {
      "articleID": 9,
      "type": 1,
      "title": "三角形的 N 种画法与浏览器的开放世界",
      "publishTime": "2018年 05月 02日",
      "praise": "107",
      "tag": ["CSS", "前端"],
      "author": "doodlewind",
      "authorImg": "https://user-gold-cdn.xitu.io/2018/3/15/162277f166bfb142?imageView2/1/w/100/h/100/q/85/interlace/1",
      "comment": [
        {
          "username": "Porisika",
          "commentTime": "12小时前",
          "commentText": "好喜欢你总结的最后一段话，在还没参加工作前 我每天的乐趣就是把一种样式用多种方法去实现，就是很开心的那种。自从参加工作后，每天都是完成该完成的任务，每天都是小心翼翼地上班，就怕工作上出错，连我原来每天花半天时间拓展新知识的计划都被慢慢地打乱，有点枯燥不开森。今天无意间看完你的文章，觉得自己应该拾起之前的状态，发现前端乐趣，谢谢！",
          "admire":"5",
          "commentImg":"https://user-gold-cdn.xitu.io/2017/9/5/159acff6b8cff532cc4f105ed287cd41?imageView2/1/w/100/h/100/q/85/interlace/1"
        },
        {
          "username": "wkx101",
          "commentTime": "1天前",
          "commentText": "以下純屬個人觀感啦。\n看到樓主提到為什麼要捨近求遠時候，我覺得沒有甚麼太大的目的，只是應場景需求而已。\n\n我前年還是前端的時候，我把公司的軟體畫面全部重做一次，原本貼圖的按鍵，只因為我想讓它有動畫效果，所以我把它全部變成CSS或SVG。說真話，公司內評價兩極，一邊認為沒必要，一邊認為不錯。\n\n所以我想對需求的考量才是重點，但既然可以滿足需求，不妨找點樂子。\n\n最後，多謝樓主幫我推開另一扇門，讓我可以看見更多的東西。",
          "admire":"5",
          "commentImg":"https://avatars.githubusercontent.com/u/7298570?v=3"
        },
        {
          "username": "城管大队长",
          "commentTime": "1天前",
          "commentText": "厉害了",
          "admire":"0",
          "commentImg":"https://user-gold-cdn.xitu.io/2018/4/1/1628005a35c53985?imageView2/1/w/100/h/100/q/85/interlace/1"
        }
      ],
      "preview":"最近，我完全沉迷在了任天堂 Switch 上的《塞尔达传说：荒野之息》里，以至于专栏都快要停更了（罪过罪过）。大概每个塞尔达玩家都会有这个疑问，那就是 这个游戏为什么这么好玩？！ 非常有意思的是，这个问题的答案似乎和「前端为什么这么日新月异」有着微妙的关系，这让我有了一些全新的认识",
      "content":"<p>最近，我完全沉迷在了任天堂 Switch 上的《塞尔达传说：荒野之息》里，以至于专栏都快要停更了（罪过罪过）。大概每个塞尔达玩家都会有这个疑问，那就是 <strong>这个游戏为什么这么好玩？！</strong> 非常有意思的是，这个问题的答案似乎和「<strong>前端为什么这么日新月异</strong>」有着微妙的关系，这让我有了一些全新的认识…</p>\n<p>塞尔达的游戏体验有一点广受好评，那就是<strong>符合直觉的开放世界</strong>。换句话说，在这个游戏里<strong>想要做到一件事，只要你能想到什么方式，那么你几乎就能基于这种方式去实现</strong>。比如，你看到树上挂着一颗苹果，那么想要摘下这颗苹果，至少有以下这些办法：</p>\n<ul>\n<li>把树砍倒，捡到苹果</li>\n<li>爬树、骑在马上或者搬来箱子垫脚够到苹果</li>\n<li>用弓箭把苹果射下来</li>\n<li>扇风或者炸弹制造冲击波，把苹果吹下来</li>\n<li>从周围的高地滑翔到苹果树上</li>\n<li>放火把树点着，留下烤苹果</li>\n<li>……</li>\n</ul>\n<p>这种自由度使得游戏的冒险体验充满了惊喜。对各种棘手的机关谜题，解法常常是开放而不唯一的。巧的是，我近期的工作也和折腾前端的各种渲染机制有些关系。<strong>当用自由程度来评价浏览器的时候，能看到的几乎也是一个塞尔达级别的开放世界了。</strong></p>\n<p>我们不妨用三角形作为例子吧。三角形作为最简单的几何图形，绘制它对于任何一位前端同学都不会是一件难事。但在今天的前端领域里，到底有多少种技术方案能够画出一个三角形呢？答案可以说非常的百花齐放了。让我们循序渐进地开始吧。下面的各种套路可以按照折腾程度分为三种：</p>\n<ul>\n<li>2B Play</li>\n<li>普通 Play</li>\n<li>羞耻 Play</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-0\">2B Play</h2>\n<p>首先让我们从最不费劲的耍无赖方法开始吧：</p>\n<h3 class=\"heading\" data-id=\"heading-1\">字符</h3>\n<p>还有什么比复制粘贴一个 <code>△</code> 字符更简单的绘制方式呢？这其实就是个形如 <code>'\\u25b3'</code> 的 Unicode 特殊字符而已。</p>\n<h3 class=\"heading\" data-id=\"heading-2\">图片</h3>\n<p>看起来 <code>&lt;img src=\"三角形.jpg\"/&gt;</code> 的套路很 low，但完全没毛病啊🙄</p>\n<h3 class=\"heading\" data-id=\"heading-3\">HTML</h3>\n<p>只要垂直居中一系列宽度均匀增长的矩形，我们是不是就得到了一个三角形呢😅</p>\n<pre><code class=\"hljs html\" lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"triangle\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"width: 1px; height: 1px;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"width: 2px; height: 1px;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"width: 3px; height: 1px;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"width: 4px; height: 1px;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- ...... --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre><p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjsfiddle.net%2Fmbvgdjv7%2F4%2F\" rel=\"nofollow noopener noreferrer\">Demo</a></p>\n<h2 class=\"heading\" data-id=\"heading-4\">普通 Play</h2>\n<p>如果感觉上面的实现太过于玩世不恭，接来下我们可以用一些略微「正常」一点的操作来画出同样的三角形：</p>\n<h3 class=\"heading\" data-id=\"heading-5\">CSS</h3>\n<p>CSS 里充斥着大量的奇技淫巧，而下面这个操作可能是很多面试题的标准答案了。我们只需要简单的 HTML：</p>\n<pre><code class=\"hljs html\" lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"triangle\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre><p>配合魔改容器边框的样式：</p>\n<pre><code class=\"hljs css\" lang=\"css\"><span class=\"hljs-selector-class\">.triangle</span> {\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-attribute\">border-left</span>: <span class=\"hljs-number\">50px</span> solid transparent;\n  <span class=\"hljs-attribute\">border-right</span>: <span class=\"hljs-number\">50px</span> solid transparent;\n  <span class=\"hljs-attribute\">border-bottom</span>: <span class=\"hljs-number\">100px</span> solid red;\n}\n</code></pre><p>就能够模拟出一个三角形了。<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjsfiddle.net%2Fdzvbv1La%2F\" rel=\"nofollow noopener noreferrer\">Demo</a></p>\n<h3 class=\"heading\" data-id=\"heading-6\">Icon Font</h3>\n<p>把字体当做图标使用的做法也是老调重弹了。只需要大致这样的字体样式配置：</p>\n<pre><code class=\"hljs css\" lang=\"css\">@<span class=\"hljs-keyword\">font-face</span> {\n  <span class=\"hljs-attribute\">font-family</span>: Triangle;\n  <span class=\"hljs-attribute\">src</span>: <span class=\"hljs-built_in\">url</span>(./triangle.woff) <span class=\"hljs-built_in\">format</span>(<span class=\"hljs-string\">\"woff\"</span>);\n}\n\n<span class=\"hljs-selector-class\">.triangle</span><span class=\"hljs-selector-pseudo\">:before</span> { <span class=\"hljs-attribute\">content</span>:<span class=\"hljs-string\">\"\\t666\"</span> }\n</code></pre><p>这样一个 <code>&lt;i class=\"triangle\"&gt;&lt;/i&gt;</code> 的标签，就能通过 <code>:before</code> 插入特殊字符，进而渲染对应的图标字体了😑<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjsfiddle.net%2Fa5L8fuz9%2F1%2F\" rel=\"nofollow noopener noreferrer\">Demo</a></p>\n<h3 class=\"heading\" data-id=\"heading-7\">SVG</h3>\n<p>很多时候我们习惯把 SVG 当做图片一样的静态资源直接引入使用，但其实只要稍微了解一下它的语法后，就会发现直接手写 SVG 来绘制简单图形也并不复杂：</p>\n<pre><code class=\"hljs html\" lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">polygon</span> <span class=\"hljs-attr\">points</span>=<span class=\"hljs-string\">\"50,0 100,100 0,100\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"fill: red;\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n</code></pre><p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjsfiddle.net%2Fpnetx4vw%2F\" rel=\"nofollow noopener noreferrer\">Demo</a></p>\n<h3 class=\"heading\" data-id=\"heading-8\">Clip Path</h3>\n<p>SVG 和 CSS 有很多相似之处，但 CSS 虽然长于样式，长久以来却一直缺乏「绘制出一个形状」的能力。好在 CSS 规范中刚加入不久的 clip path 能够名正言顺地让我们用类似 SVG 的形式绘制出更多样的形状。这只需要形如下面的样式：</p>\n<pre><code class=\"hljs css\" lang=\"css\"><span class=\"hljs-selector-class\">.triangle</span> {\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">10px</span>; <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">10px</span>;\n  <span class=\"hljs-attribute\">background</span>: red;\n  <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">polygon</span>(50% 0, 0 100%, 100% 100%);\n}\n</code></pre><p>这和熟悉的 border 套路有什么区别呢？除了代码更直观简洁以外，它还能够为绘制出的形状支持背景图片属性，可惜的地方主要是 IE 兼容了。<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjsfiddle.net%2F7xzwbp2t%2F\" rel=\"nofollow noopener noreferrer\">Demo</a></p>\n<h3 class=\"heading\" data-id=\"heading-9\">Canvas</h3>\n<p>到目前为止的方法没有一个需要编写 JS 代码，这多少有些对不起工钱。还好我们有 Canvas 来名正言顺地折腾。只需要一个 <code>&lt;canvas&gt;</code> 标签配上这样的胶水代码就行：</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> canvas = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'canvas'</span>)\n<span class=\"hljs-keyword\">const</span> ctx = canvas.getContext(<span class=\"hljs-string\">'2d'</span>)\nctx.beginPath()\nctx.fillStyle = <span class=\"hljs-string\">'red'</span>\nctx.moveTo(<span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>)\nctx.lineTo(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>)\nctx.lineTo(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>)\nctx.fill()\n</code></pre><p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjsfiddle.net%2Fmbvgdjv7%2F1%2F\" rel=\"nofollow noopener noreferrer\">Demo</a></p>\n<h2 class=\"heading\" data-id=\"heading-10\">羞耻 Play</h2>\n<p>如果你还是嫌弃上面的操作过于中规中矩，让我们用最后的几种方法来探索浏览器的自由尺度吧：</p>\n<h3 class=\"heading\" data-id=\"heading-11\">CSS Houdini</h3>\n<p>近期的 CSS 大会上 CSS Houdini 可以说赚足了眼球。这套大大增强 CSS 控制力的规范中，目前已经实装的主要也就是 CSS Paint 了。简而言之，通过这个 API，只要 CSS 属性需要图片的地方，你就可以编程式地通过 canvas 控制图片的渲染过程。</p>\n<p>通过 <code>CSS.paintWorklet.addModule</code> API，我们可以定义绘制 canvas 所用的 paint worklet：</p>\n<pre><code class=\"hljs html\" lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"actionscript\">\n  CSS.paintWorklet.addModule(<span class=\"hljs-string\">'/worklet.js'</span>)\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre><p>Paint worklet 中能够拿到正常的 canvas 上下文：</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrianglePainter</span> </span>{\n  paint(ctx, geom, properties) {\n\t <span class=\"hljs-keyword\">const</span> offset = geom.width\n    ctx.beginPath()\n    ctx.fillStyle = <span class=\"hljs-string\">'red'</span>\n    ctx.moveTo(offset / <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>)\n    ctx.lineTo(offset, offset)\n    ctx.lineTo(<span class=\"hljs-number\">0</span>, offset)\n    ctx.fill()\n  }\n}\n\nregisterPaint(<span class=\"hljs-string\">'triangle'</span>, TrianglePainter)\n</code></pre><p>只要这样，就能在 CSS 里使用 <code>paint</code> 规则了：</p>\n<pre><code class=\"hljs css\" lang=\"css\"><span class=\"hljs-selector-class\">.demo</span> {\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;\n  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;\n  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">paint</span>(triangle);\n}\n</code></pre><p>我们还可以使用 CSS Variable 在 CSS 中定义形如 <code>--triangle-size</code> 或 <code>--triangle-fill</code> 的参数，来控制 canvas 的渲染，这样在参数更新时 canvas 会自动重绘。结合上 animation，它在特效领域的想象空间也很大。虽然最后使用的还是前面提及的 canvas，但 Houdini 确实给基于 CSS 的渲染带来了更大的掌控。</p>\n<h3 class=\"heading\" data-id=\"heading-12\">WebGL 多边形</h3>\n<p>主流浏览器对 WebGL 的支持已经相当不错了，但目前看来它仍然不是前端领域人人必备的主流技术。这或许和它较为陡峭的学习曲线有关。可能有不少同学对 WebGL 有一种误解，即它和 canvas 一样，是一套 JS API。实际上，编写 WebGL 应用时，除了需要编写运行在 CPU 范畴内的 JS 胶水代码外，真正在 GPU 上执行的是 GLSL 语言编写的<strong>着色器</strong>。但是由于绘图库本身的复杂性，在入门示例中，JS 的胶水代码占了绝对的大头。按照计算机图形学按部就班的教程，即便只是完成一个三角形的渲染过程，也需要百行左右的代码。限于篇幅，我们只简要地将这个流程里所需要做的关键事项概括为以下三步：</p>\n<ol>\n<li>用 GLSL 语言编写顶点着色器和片元着色器。</li>\n<li>定义出一个顶点缓冲区，向其中传入三角形逐个顶点的数据。</li>\n<li>在我们自己实现的 render 函数里做一些准备。在加载完着色器程序后，调用 <code>drawArray</code> API 绘制缓冲区中数据。</li>\n</ol>\n<p>这个过程（<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjsfiddle.net%2Fskpuk5b1%2F\" rel=\"nofollow noopener noreferrer\">Demo</a>）初看之下控制的不过是一个更啰嗦而折腾的 canvas 而已，除了可以支持 3D 以外，有什么不同呢？在最后一种方法里我们就能看到区别了。</p>\n<h3 class=\"heading\" data-id=\"heading-13\">WebGL 造型函数</h3>\n<p>上面的流程基本是每一个 WebGL 教程都会按部就班地去做的。考虑这个问题：绘制三角形一定需要提供三个顶点吗？这可不一定。</p>\n<p>熟悉 canvas 的同学都知道，在处理图像时，像下面这样的逐像素操作很容易带来性能问题：</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; width; i++) {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">0</span>; j &lt; height; j++) {\n    <span class=\"hljs-comment\">// ...</span>\n  }\n}\n</code></pre><p>但是在 WebGL 中，是不存在这样<strong>串行</strong>的循环的。你用 GLSL 语言所编写的着色器，会被编译到 GPU 上去<strong>并行</strong>执行。听起来是不是比较酷？上面已经提到，我们有两种着色器，即<strong>顶点着色器</strong>和<strong>片元着色器</strong>：</p>\n<ul>\n<li>顶点着色器的代码逐顶点执行，比如对于三角形，它就执行三次。</li>\n<li>片元着色器的代码逐片元（粗略的理解就是像素）执行，对于一个 100x100 的区域，GPU 会并行地对这 1w 个像素调用片元着色器，这个并行的过程对你是透明的。</li>\n</ul>\n<p>所以对于一个「逐像素执行」的片元着色器来说，只要它知道自己每次被调用时所在的坐标，那么就能够根据这个位置计算出最终的颜色。这样一来，我们甚至不需要顶点缓冲区，就能够基于特定的公式去计算逐像素的颜色了。这样为着色器设计的函数我们称为 shaping function，即造型函数。一个正多边形的着色器形如：</p>\n<pre><code class=\"hljs glsl\" lang=\"glsl\"><span class=\"hljs-meta\">#define TWO_PI 6.28318530718</span>\n\n<span class=\"hljs-comment\">// 由 JS 传入的屏幕分辨率</span>\n<span class=\"hljs-keyword\">uniform</span> <span class=\"hljs-type\">vec2</span> u_resolution;\n\n<span class=\"hljs-type\">void</span> main() {\n  <span class=\"hljs-type\">vec2</span> st = <span class=\"hljs-built_in\">gl_FragCoord</span>.xy/u_resolution.xy;\n  st.x *= u_resolution.x/u_resolution.y;\n  <span class=\"hljs-type\">vec3</span> color = <span class=\"hljs-type\">vec3</span>(<span class=\"hljs-number\">0.0</span>);\n  <span class=\"hljs-type\">float</span> d = <span class=\"hljs-number\">0.0</span>;\n\n  <span class=\"hljs-comment\">// 重新映射空间坐标到 -1. 与 1. 间</span>\n  st = st * <span class=\"hljs-number\">2.</span><span class=\"hljs-number\">-1.</span>;\n\n  <span class=\"hljs-comment\">// 多边形边数量</span>\n  <span class=\"hljs-type\">int</span> N = <span class=\"hljs-number\">3</span>;\n\n  <span class=\"hljs-comment\">// 当前像素的角度与半径</span>\n  <span class=\"hljs-type\">float</span> a = <span class=\"hljs-built_in\">atan</span>(st.x,st.y)+PI;\n  <span class=\"hljs-type\">float</span> r = TWO_PI/<span class=\"hljs-type\">float</span>(N);\n\n  <span class=\"hljs-comment\">// 调节距离的造型函数</span>\n  d = <span class=\"hljs-built_in\">cos</span>(<span class=\"hljs-built_in\">floor</span>(<span class=\"hljs-number\">.5</span>+a/r)*r-a)*<span class=\"hljs-built_in\">length</span>(st);\n\n  color = <span class=\"hljs-type\">vec3</span>(<span class=\"hljs-number\">1.0</span>-<span class=\"hljs-built_in\">smoothstep</span>(<span class=\"hljs-number\">.4</span>,<span class=\"hljs-number\">.41</span>,d));\n  <span class=\"hljs-comment\">// color = vec3(d);</span>\n\n  <span class=\"hljs-built_in\">gl_FragColor</span> = <span class=\"hljs-type\">vec4</span>(color,<span class=\"hljs-number\">1.0</span>);\n}\n</code></pre><p>这就是一个船新的领域了，由于 shader 编程要求对众多的像素编写出同一份简洁而并行执行的代码，彼此之间还完全透明且无法随意 log 调试，这使得面向着色器编程的门槛实际上很高。这里的示例在非常好的入门书 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fthebookofshaders.com%2F07%2F\" rel=\"nofollow noopener noreferrer\">The Book of Shaders</a> 中有相应的章节，有兴趣的同学或许会打开新世界的大门哦🤔</p>\n<p>P.S. 在这里我们为什么要舍近求远呢？这个途径其实和字体渲染的原理有些接近，近期我也在学习一些相关的知识，希望届时能有更多的内容可以分享~</p>\n<h2 class=\"heading\" data-id=\"heading-14\">总结</h2>\n<p>不可否认，常规的业务开发很容易进入枯燥的重复劳动阶段，但再看开一点，我们可以发现实际上我们已经有了非常多可用的技术手段来优化前端这个领域里的交互了。一个简单的三角形都能用 HTML / CSS / JS / GLSL 四种语言的十几种方案来画，更复杂的场景下就更是百花齐放了。浏览器的渲染能力之强应该也算得上是个开放世界了吧：别管你想画什么，总有适合你的方法去实现。</p>\n<p>不过和塞尔达里越高级的操作看起来越风骚简洁不同，越是掌控力强的技术方案，在实现上就会更加复杂。但总之不管是游戏还是代码还是生活，相信快乐的方式都不止一种~希望大家都能够享受过程，找到属于自己的那份乐趣~</p>\n"
    },
    {
      "articleID": 10,
      "type": 2,
      "title": "算法初体验",
      "publishTime": "2018年 05月 03日",
      "praise": "31",
      "tag": ["面试", "后端"],
      "author": "木可大大",
      "authorImg": "https://user-gold-cdn.xitu.io/2018/4/11/162b1e298080d8c7?imageView2/1/w/100/h/100/q/85/interlace/1",
      "comment": [
        {
          "username": "豊乢",
          "commentTime": "4小时前",
          "commentText": "现在做机器学习这感觉不那么重要了",
          "admire":"0",
          "commentImg":"https://user-gold-cdn.xitu.io/2016/11/29/8b9a35acd98e288e2d5302ba3966377a.jpg?imageView2/1/w/100/h/100/q/85/interlace/1"
        }
      ],
      "preview":"在介绍具体算法之前，我先谈一下个人对学习算法的初心。我的初心无非有两点：一，BAT等互联网公司招聘面试时要问算法知识，如果想要进入互联网公司，我就必须学好算法；二，通过学习算法提升个人开发的基本功，这样一来，对于不同场景我就可以正确选择对应的数据结构和算法，使得程序更健壮，提高程序的运行效率。",
      "content":"<blockquote>\n<p>我们知道<strong>程序由数据结构和算法组成的</strong>。其中，数据结构表示数据的组织形式，基本的数据结构包括数组、链表、栈、队列、树、哈希表、图、堆等。而算法表示对数据结构中的数据进行处理的方式或过程，换句话说，就是解决问题的方法。它们俩之间的关系：数据结构为算法服务，很多算法依赖于特定的数据结构，但不是全部算法，算法可以和数据结构没有关系。本期我们就来聊一聊算法。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-0\">学习算法的重要性</h2>\n<p>在介绍具体算法之前，我先谈一下个人对学习算法的初心。我的初心无非有两点：一，BAT等互联网公司招聘面试时要问算法知识，如果想要进入互联网公司，我就必须学好算法；二，通过学习算法提升个人开发的基本功，这样一来，对于不同场景我就可以正确选择对应的数据结构和算法，使得程序更健壮，提高程序的运行效率。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">应用领域</h2>\n<p>目前计算机各个细分领域涉及到不同的算法。比如说<strong>搜索引擎</strong>，平时我们使用google、百度等浏览器，只要我们输入一个关键字，浏览器就会<strong>快速</strong>地返回相关的集合，这个集合的背后就隐藏着许多算法。如果没有这些算法，我们是不可能这么快速地得到想要的结果。再比如说人工智能，通过计算模型算法实现人体识别、语音识别等各应用场景。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">算法分析</h2>\n<p>上文我们已经介绍到算法就是解决问题的方法，而对于同一个问题，可能存在不同的解决方法。因此，为了衡量一个算法的优劣，提出了<strong>时间复杂度</strong>与<strong>空间复杂度</strong>这两个概念。</p>\n<blockquote>\n<p>时间复杂度</p>\n</blockquote>\n<p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，算法的时间度量记为 <code>T(n) = O(f(n))</code>，它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。</p>\n<blockquote>\n<p>空间复杂度</p>\n</blockquote>\n<p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，记做<code>S(n)=O(f(n))</code>。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。</p>\n<h2 class=\"heading\" data-id=\"heading-3\">排序算法</h2>\n<p>根据时间复杂度我们大体可以将排序算法分为两类，一类是以选择排序为代表的<code>O(n^2)</code>的算法，另一类是以快速排序为代表的<code>O(nlogn)</code>的算法。看到这里我们不禁会问：既然有<code>O(nlogn)</code>的排序算法，那些<code>O(n^2)</code>的算法还有存在的必要吗？要回答这个问题，先来看下<code>O(n^2)</code>的排序算法的特点：首先，它相对是比较基础的，编码简单，易于实现，在一些特定场景下<code>O(n^2)</code>更适合 ，譬如在机器语言中<code>O(n^2)</code>更容易实现；其次，简单的排序算法思路衍生出复杂的排序算法，比如说希尔排序是对插入排序的优化；最后，对于一些简单的算法，由于它们本身的一些性质，可以被用作改进更复杂排序算法的子过程中。基于此，本文<code>O(n^2)</code>排序算法中两个代表性的算法即选择算法和插入算法。\n</p><figure><img alt=\"image.png\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/163259606fe4a422?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"630\" data-height=\"365\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;630&quot; height=&quot;365&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-4\">选择排序</h2>\n<p>思想：在整个待排序数组里找到最小的值，然后和待排序中的第一个元素进行交换，接着在剩下的元素里找到最小的元素，接着将它和待排序中的第一个元素进行交换，以此类推。为了加深大家的理解，举个具体例子，对8、6、2、3、1、5、7、4进行升序排序。\n</p><figure><img alt=\"image.png\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/163259607030ab36?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"671\" data-height=\"421\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;671&quot; height=&quot;421&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>选择排序的Java语言实现如下：</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">   /**\n     * 思路：每次从待选数组中选择一个最小元素，然后和对应位置交换位置\n     * @param arr\n     * @param n\n     */\n    public void sort(int[] arr, int n) {\n        <span class=\"hljs-keyword\">for</span>(int i=0;i&lt;n;i++) {\n            // 1. 寻找[i,n)区间里的最小元素\n            int minIndex = i;\n            <span class=\"hljs-keyword\">for</span>(int j=i+1;j&lt;n;j++ ) {\n                <span class=\"hljs-keyword\">if</span> (arr[j] &lt; arr[minIndex]) {\n                    minIndex = j;\n                }\n            }\n            // 2. 交换位置\n            this.swap(arr,i,minIndex);\n\n        }\n    }\n</code></pre><h2 class=\"heading\" data-id=\"heading-5\">插入排序</h2>\n<p>思路：插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>\n<p></p><figure><img alt=\"image.png\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16325960703cb9af?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"668\" data-height=\"416\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;668&quot; height=&quot;416&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure>\n插入排序的Java语言实现如下：<p></p>\n<pre><code class=\"hljs bash\" lang=\"bash\"> public void sort(Comparable[] arr){\n        int n = arr.length;\n        <span class=\"hljs-keyword\">for</span> (int i = 0; i &lt; n; i++) {\n            // 寻找元素arr[i]合适的插入位置\n            <span class=\"hljs-keyword\">for</span>( int j = i; j &gt; 0 &amp;&amp; arr[j].compareTo(arr[j-1]) &lt; 0 ; j--)\n                swap(arr, j, j-1);\n        }\n    }\n</code></pre><p>通过比较选择排序和插入排序的代码实现，我们可以发现一旦有部分排序好之后，新插入一个数如果比排好序最大值还要大，则不用再和其他数字比较，<strong>减少了比较次数</strong>。但是，<strong>我们应该注意到插入排序在每次遍历的时候都需要进行交换操作</strong>，这个交换操作包含三次赋值操作，导致插入排序的时间要比选择排序的时间更长。针对这个问题，我们的先辈们想到了一个方法：<strong>先将待比较元素复制一份</strong>，然后依次和有序数组中的元素进行比较，如果比有序数组中的元素小，则将有序数组中的元素覆盖待比较元素，以此类推。如下图所示，首先我们将元素6复制一份，接着验证元素6是否应当放在当前位置，通过比较6和它之前的元素大小，发现元素8应该放在元素6的位置上，因此将元素8覆盖元素6，然后我们考查元素6是否应该放在前一个元素位置上，此时，由于元素8在第0个位置上我们就不用比较直接覆盖。它的Java代码实现如下：</p>\n<p></p><figure><img alt=\"image.png\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/1632596071fdf0b7?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"841\" data-height=\"315\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;841&quot; height=&quot;315&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<pre><code class=\"hljs bash\" lang=\"bash\"> <span class=\"hljs-keyword\">for</span> (int i = 0; i &lt; n; i++) {\n            // 寻找元素arr[i]合适的插入位置\n            Comparable e = arr[i];\n            int j = i;\n            <span class=\"hljs-keyword\">for</span>( ; j &gt; 0 &amp;&amp; arr[j-1].compareTo(e) &gt; 0 ; j--)\n                arr[j] = arr[j-1];\n            arr[j] = e;\n        }\n</code></pre><p>这样一来，内循环只需要进行一次赋值操作，效率得到了大大优化，不仅超过了选择排序，而且在待排序数组是有序的情况下，时间复杂度可以达到<code>O(n)</code>。</p>\n<hr>\n<p></p><figure><img alt=\"image\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/1632596070fc1bfc?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"258\" data-height=\"258\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;258&quot; height=&quot;258&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>欢迎关注微信公众号：木可大大，所有文章都将同步在公众号上。</p>\n"
    },
    {
      "articleID": 11,
      "type": 2,
      "title": "我用 Python 爬取微信好友，最后发现一个大秘密",
      "publishTime": "2018年 05月 03日",
      "praise": "41",
      "tag": ["Python", "微信"],
      "author": "痴海",
      "authorImg": "https://user-gold-cdn.xitu.io/2018/3/24/16258541d05b503e?imageView2/1/w/100/h/100/q/85/interlace/1",
      "comment": [
        {
          "username": "痴海",
          "commentTime": "8小时前",
          "commentText": "需要代码的，可以关注我的公众号「痴海」，后台回复「微信爬虫」就可以获取。",
          "admire":"0",
          "commentImg":"https://user-gold-cdn.xitu.io/2018/3/24/16258541d05b503e?imageView2/1/w/100/h/100/q/85/interlace/1"
        },
        {
          "username": "小媛姐姐",
          "commentTime": "9小时前",
          "commentText": "你是Koc?",
          "admire":"0",
          "commentImg":"https://avatars3.githubusercontent.com/u/18644385?v=4"
        },
        {
          "username": "a870439570",
          "commentTime": "10小时前",
          "commentText": "作者没有标明原文出处，之前看到过。",
          "admire":"2",
          "commentImg":"https://user-gold-cdn.xitu.io/2018/1/4/160c14ff0032045c?imageView2/1/w/100/h/100/q/85/interlace/1"
        }
      ],
      "preview":"你身处的环境是什么样，你就会成为什么样的人。现在人们日常生活基本上离不开微信，但微信不单单是一个即时通讯软件，微信更像是虚拟的现实世界。你所处的朋友圈是怎么样，慢慢你的思想也会变的怎么样。最近在学习 itchat,然后就写了一个爬虫，爬取了我所有的微信好友的数据。并对其中的一些数据进行分析，发现了一些很有趣的事。",
      "content":"<div><div><img title=\"\" alt=\"\" class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16323e32c5504c2f?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"592\" data-height=\"516\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16323e32c5504c2f?imageView2/0/w/1280/h/960/ignore-error/1\"><div></div></div>\n<h1 data-id=\"heading-0\">前言</h1>\n<p>你身处的环境是什么样，你就会成为什么样的人。现在人们日常生活基本上离不开微信，但微信不单单是一个即时通讯软件，微信更像是虚拟的现实世界。你所处的朋友圈是怎么样，慢慢你的思想也会变的怎么样。最近在学习 itchat,然后就写了一个爬虫，爬取了我所有的微信好友的数据。并对其中的一些数据进行分析，发现了一些很有趣的事。</p>\n<h1 data-id=\"heading-1\">微信好友爬虫</h1>\n<p>此次的爬虫程序用到的库有很多，其中爬取微信数据用到的事 itchat。需要你先去下安装。安装完成以后，你就可以通过 itchat.login() 这个函数登陆你自己的微信。它回弹出一个网页登陆的二维码，你用手机扫描登陆即可。</p>\n<p>然后通过 itchat.get_friends() 这个函数就可以获取到自己好友的相关信息，这些信息是一个 json 数据返回。然后我们就可以根据这些返回的信息，进行正则匹配抓取我们想要的信息，在进行分析。</p>\n<pre code-lang=\"\" class=\"hljs bash\"><code class=\"hljs bash\" lang=\"bash\">import itchat\nitchat.login()\n<span class=\"hljs-comment\">#爬取自己好友相关信息， 返回一个json文件</span>\nfriends = itchat.get_friends(update=True)[0:]\n</code></pre>\n<h1 data-id=\"heading-2\">我的微信好友的男女比例</h1>\n<div><img title=\"\" alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16323e32c5ed618a?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"827\" data-height=\"629\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;827&quot; height=&quot;629&quot;&gt;&lt;/svg&gt;\"><div></div></div>\n<p>观察返回的数据，很容易就可以根据关键字发现性别是存放在一个字典里面，它的 key 是「Sex」，男性值为 1，女性为 2，其他是不明性别的（就是没有填的）。</p>\n<p>在代码里我定义了一个函数 parse_friends() 通过一个 for 循环，把获取到的数据通过 for 循环保存到 text 字典里。然后再通过 draw() 函数画出柱状图。柱状图使用的是 plt 库，之前也写过一篇文章，感兴趣的同学可以去查看。</p>\n<div><img title=\"\" alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16323e32c6fbfbd7?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"866\" data-height=\"537\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;866&quot; height=&quot;537&quot;&gt;&lt;/svg&gt;\"><div></div></div>\n<div><img title=\"\" alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16323e32cb8b1cb0?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"765\" data-height=\"327\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;765&quot; height=&quot;327&quot;&gt;&lt;/svg&gt;\"><div></div></div>\n<p>最后打印的结果：</p>\n<div><img title=\"\" alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16323e32cc79a2b1?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"707\" data-height=\"210\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;707&quot; height=&quot;210&quot;&gt;&lt;/svg&gt;\"><div></div></div>\n<p>不得不多说我微信的 1K 多的好友男女比列非常的不协调，男多女少啊。这让我回想起以前高中一个班 50 个人，女生就 7 个，然后我们班的女生从此就有一个女团称呼「七仙女」。</p>\n<h1 data-id=\"heading-3\">我的微信好友个性签名的自定义词云图</h1>\n<p>为了进一步分析我的好友大致都有什么特征，我把好友的个性签名一起抓取，分析制作成词云。</p>\n<p>个性签名是保存在 Signature 这个 key 中，由于有些签名包含些表情，最初抓取会变成 emoji、span、class 等等这些无关的词。所有需要先替换掉，另外，还有类似 &lt;&gt;/= 之类的符号，也需要写个简单的正则替换掉，再把所有拼起来，得到 text 字串。</p>\n<div><img title=\"\" alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16323e32cd18cc28?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"858\" data-height=\"164\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;858&quot; height=&quot;164&quot;&gt;&lt;/svg&gt;\"><div></div></div>\n<p>得到的数据最后保存到当前目录名为「text.txt」文本中。</p>\n<div><img title=\"\" alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16323e32f316b658?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"845\" data-height=\"188\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;845&quot; height=&quot;188&quot;&gt;&lt;/svg&gt;\"><div></div></div>\n<p>分析好友签名的函数我定义成:parse_signature()，完整代码如下：</p>\n<div><img title=\"\" alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16323e32f33ffba6?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"863\" data-height=\"265\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;863&quot; height=&quot;265&quot;&gt;&lt;/svg&gt;\"><div></div></div>\n<p>抓取整理了签名的数据，接下来就是制作出词云。这里使用的是 wordCloud 来进行词云的制作。之前的文章也有介绍过词云的制作，感兴趣的同学可以查看这篇文章。</p>\n<p>词云的制作我定义了一个:draw_signature() 函数，完整代码如下</p>\n<div><img title=\"\" alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16323e32f3dccea2?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"864\" data-height=\"241\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;864&quot; height=&quot;241&quot;&gt;&lt;/svg&gt;\"><div></div></div>\n<p>运行上面的代码后得到了如下的图，由于好友数量比较多，我分别找了两张图制作出图云。</p>\n<div><img title=\"\" alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16323e32f51e554d?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"782\" data-height=\"674\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;782&quot; height=&quot;674&quot;&gt;&lt;/svg&gt;\"><div></div></div>\n<div><img title=\"\" alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16323e32f74c2f60?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"641\" data-height=\"810\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;641&quot; height=&quot;810&quot;&gt;&lt;/svg&gt;\"><div></div></div>\n<p>努力，奋斗，世界，生活，自己。这些词在我们 1K 多人的好友中出现的最多。大家都非常的优秀，都非常的上进。</p>\n<div><img title=\"\" alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/16323e3301404743?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"455\" data-height=\"275\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;455&quot; height=&quot;275&quot;&gt;&lt;/svg&gt;\"><div></div></div>\n<p>我的签名：人生必有痴，而有后成。现在的我痴迷于各种优秀的人，每天都在向他们学习。希望大家一生当中也有痴迷的一面。</p>\n<p>需要完整的代码可以私信我，我发给你。</p></div><p><br></p>"
    },
    {
      "articleID": 12,
      "type": 2,
      "title": "搭建数据追踪系统",
      "publishTime": "2018年 05月 03日",
      "praise": "9",
      "tag": ["MySQL", "后端"],
      "author": "xiangdong",
      "authorImg": "https://avatars.githubusercontent.com/u/8702821?v=3",
      "comment": [],
      "preview":"操作系统：CentOS 7.2 64位 Zipkin是一款开源的分布式实时数据追踪系统（Distributed Tracking System），基于 Google Dapper的论文设计而来。其主要功能是聚集来自各个异构系统的实时监控数据。 安装完成之后，检查是否安装成功 ==Zipkin 默认",
      "content":"<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/163265e00e06caff?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"200\" data-height=\"119\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/163265e00e06caff?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-0\">环境说明</h3>\n<p>操作系统：\tCentOS 7.2 64位</p>\n<h4 class=\"heading\" data-id=\"heading-1\">1. Zipkin简介</h4>\n<p>Zipkin是一款开源的分布式实时数据追踪系统（Distributed Tracking System），基于 Google Dapper的论文设计而来。其主要功能是聚集来自各个异构系统的实时监控数据。</p>\n<h4 class=\"heading\" data-id=\"heading-2\">2. 应用场景</h4>\n<ol>\n<li>\n<p>故障快速定位\n通过分析调用链，可以将一次请求的逻辑轨迹完整清晰的展示出来，通过在开发中在业务日志中添加调用链ID，可以通过调用链结合业务日志快速定位错误信息。</p>\n</li>\n<li>\n<p>服务可用性\n通过分析各个环节的平均时延，QPS等信息，可以找到系统的薄弱环节，对一些模块做调整，例如数据冗余、链路可用等。</p>\n</li>\n<li>\n<p>性能分析\n在调用链的各个环节分别添加调用时延，可以分析系统的性能瓶颈，进行有针对性的优化。</p>\n</li>\n</ol>\n<h4 class=\"heading\" data-id=\"heading-3\">3. 安装JDK</h4>\n<blockquote>\n<p>安装数据追踪软件Zipkin所需要的JDK环境</p>\n</blockquote>\n<p>执行以下命令安装JDK</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">yum install java-1.8.0-openjdk* -y\n</code></pre><p>安装完成之后，检查是否安装成功</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">java -version\n</code></pre><h4 class=\"heading\" data-id=\"heading-4\">4. 安装Zipkin</h4>\n<p>新建存放ZIPkin的目录并进入此目录</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">mkdir -p /data/release/zipkin &amp;&amp; <span class=\"hljs-built_in\">cd</span> <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$_</span>\"</span>\n</code></pre><p>下载Zipkin</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">wget -O zipkin.jar <span class=\"hljs-string\">'https://search.maven.org/remote_content?g=io.zipkin.java&amp;a=zipkin-server&amp;v=LATEST&amp;c=exec'</span>\n</code></pre><p>启动Zipkin</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">java -jar zipkin.jar\n</code></pre><p>==Zipkin 默认监听 9411 端口， 使用浏览器访问 http://IP:9411 即可看到 Zipkin 自带的图形化界面。如果没有看到Zipkin的图形化界面，请确保外网的9411端口是否已开==</p>\n<h4 class=\"heading\" data-id=\"heading-5\">3. 安装mysql</h4>\n<blockquote>\n<p>Zipkin支持的持久化方案比较多，如： MySQL、 Elasticsearch。我们使用MySQL 5.7来作为持久化方案。</p>\n</blockquote>\n<h5 class=\"heading\" data-id=\"heading-6\">1. 下载MySQL 5.7</h5>\n<p>在执行以下操作之前，可以使用 Ctrl + C 退出上个步骤的 Java 进程并下载rmp包。</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">wget http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm\n</code></pre><p>安装rpm包</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">rpm -Uvh mysql57-community-release-el7-9.noarch.rpm\n</code></pre><p>安装MySQL</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">yum install mysql-community-server -y\n</code></pre><p>启动MySQL</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">systemctl start mysqld.service\n</code></pre><h5 class=\"heading\" data-id=\"heading-7\">2. 设置MySQL密码</h5>\n<p>获取 root 临时密码</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">grep <span class=\"hljs-string\">'temporary password'</span> /var/<span class=\"hljs-built_in\">log</span>/mysqld.log | awk <span class=\"hljs-string\">'{print $NF}'</span>\n</code></pre><p>使用上一步的获得的临时密码登入 MySQL</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">mysql -uroot -p\n</code></pre><p>更改MySQL的root密码为<strong>dettRoot$123</strong></p>\n<pre><code class=\"hljs bash\" lang=\"bash\">ALTER USER <span class=\"hljs-string\">'root'</span>@<span class=\"hljs-string\">'localhost'</span> IDENTIFIED BY <span class=\"hljs-string\">'dettRoot$123'</span>;\n</code></pre><p>退出MySQL，回到Bash shell</p>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-built_in\">exit</span>;\n</code></pre><h5 class=\"heading\" data-id=\"heading-8\">3. 初始化Zipkin数据库脚本</h5>\n<p>编写初始化脚本</p>\n<p>在目录/data/release/zipkin下创建脚本文件zipkin_init.sql</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">touch zipkin_init.sql\n</code></pre><p>然后添加如下脚本代码：</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">CREATE TABLE IF NOT EXISTS zipkin_spans (\n  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT <span class=\"hljs-string\">'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit'</span>,\n  `trace_id` BIGINT NOT NULL,\n  `id` BIGINT NOT NULL,\n  `name` VARCHAR(255) NOT NULL,\n  `parent_id` BIGINT,\n  `debug` BIT(1),\n  `start_ts` BIGINT COMMENT <span class=\"hljs-string\">'Span.timestamp(): epoch micros used for endTs query and to implement TTL'</span>,\n  `duration` BIGINT COMMENT <span class=\"hljs-string\">'Span.duration(): micros used for minDuration and maxDuration query'</span>\n) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;\n\nALTER TABLE zipkin_spans ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `id`) COMMENT <span class=\"hljs-string\">'ignore insert on duplicate'</span>;\nALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`, `id`) COMMENT <span class=\"hljs-string\">'for joining with zipkin_annotations'</span>;\nALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`) COMMENT <span class=\"hljs-string\">'for getTracesByIds'</span>;\nALTER TABLE zipkin_spans ADD INDEX(`name`) COMMENT <span class=\"hljs-string\">'for getTraces and getSpanNames'</span>;\nALTER TABLE zipkin_spans ADD INDEX(`start_ts`) COMMENT <span class=\"hljs-string\">'for getTraces ordering and range'</span>;\n\nCREATE TABLE IF NOT EXISTS zipkin_annotations (\n  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT <span class=\"hljs-string\">'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit'</span>,\n  `trace_id` BIGINT NOT NULL COMMENT <span class=\"hljs-string\">'coincides with zipkin_spans.trace_id'</span>,\n  `span_id` BIGINT NOT NULL COMMENT <span class=\"hljs-string\">'coincides with zipkin_spans.id'</span>,\n  `a_key` VARCHAR(255) NOT NULL COMMENT <span class=\"hljs-string\">'BinaryAnnotation.key or Annotation.value if type == -1'</span>,\n  `a_value` BLOB COMMENT <span class=\"hljs-string\">'BinaryAnnotation.value(), which must be smaller than 64KB'</span>,\n  `a_type` INT NOT NULL COMMENT <span class=\"hljs-string\">'BinaryAnnotation.type() or -1 if Annotation'</span>,\n  `a_timestamp` BIGINT COMMENT <span class=\"hljs-string\">'Used to implement TTL; Annotation.timestamp or zipkin_spans.timestamp'</span>,\n  `endpoint_ipv4` INT COMMENT <span class=\"hljs-string\">'Null when Binary/Annotation.endpoint is null'</span>,\n  `endpoint_ipv6` BINARY(16) COMMENT <span class=\"hljs-string\">'Null when Binary/Annotation.endpoint is null, or no IPv6 address'</span>,\n  `endpoint_port` SMALLINT COMMENT <span class=\"hljs-string\">'Null when Binary/Annotation.endpoint is null'</span>,\n  `endpoint_service_name` VARCHAR(255) COMMENT <span class=\"hljs-string\">'Null when Binary/Annotation.endpoint is null'</span>\n) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;\n\nALTER TABLE zipkin_annotations ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `span_id`, `a_key`, `a_timestamp`) COMMENT <span class=\"hljs-string\">'Ignore insert on duplicate'</span>;\nALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`, `span_id`) COMMENT <span class=\"hljs-string\">'for joining with zipkin_spans'</span>;\nALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`) COMMENT <span class=\"hljs-string\">'for getTraces/ByIds'</span>;\nALTER TABLE zipkin_annotations ADD INDEX(`endpoint_service_name`) COMMENT <span class=\"hljs-string\">'for getTraces and getServiceNames'</span>;\nALTER TABLE zipkin_annotations ADD INDEX(`a_type`) COMMENT <span class=\"hljs-string\">'for getTraces'</span>;\nALTER TABLE zipkin_annotations ADD INDEX(`a_key`) COMMENT <span class=\"hljs-string\">'for getTraces'</span>;\nALTER TABLE zipkin_annotations ADD INDEX(`trace_id`, `span_id`, `a_key`) COMMENT <span class=\"hljs-string\">'for dependencies job'</span>;\n\nCREATE TABLE IF NOT EXISTS zipkin_dependencies (\n  `day` DATE NOT NULL,\n  `parent` VARCHAR(255) NOT NULL,\n  `child` VARCHAR(255) NOT NULL,\n  `call_count` BIGINT\n) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;\n\nALTER TABLE zipkin_dependencies ADD UNIQUE KEY(`day`, `parent`, `child`);\n</code></pre><p>登录MySQL</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">mysql -u root --password=<span class=\"hljs-string\">'dettRoot$123'</span>\n</code></pre><p>创建Zipkin数据库</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">create database zipkin\n</code></pre><p>切换数据库</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">use zipkin\n</code></pre><p>初始化表及索引</p>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-built_in\">source</span> /data/release/zipkin/zipkin_init.sql\n</code></pre><p>检查是否有生成zipkin_annotations, zipkin_dependencies, zipkin_spans 三张数据表</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">show tables;\n</code></pre><p>退出 MySQL, 回到 Bash shell</p>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-built_in\">exit</span>;\n</code></pre><h5 class=\"heading\" data-id=\"heading-9\">5. 启动 Zipkin</h5>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-built_in\">cd</span> /data/release/zipkin\n\nSTORAGE_TYPE=mysql MYSQL_HOST=localhost MYSQL_TCP_PORT=3306 MYSQL_DB=zipkin MYSQL_USER=root MYSQL_PASS=<span class=\"hljs-string\">'dettRoot$123'</span> \n\nnohup java -jar zipkin.jar &amp;\n</code></pre><h4 class=\"heading\" data-id=\"heading-10\">6. 创建具有数据上报能力的Demo</h4>\n<h5 class=\"heading\" data-id=\"heading-11\">1. 搭建 NodeJS 环境</h5>\n<pre><code class=\"hljs bash\" lang=\"bash\">curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -\n\nyum install nodejs -y\n</code></pre><h5 class=\"heading\" data-id=\"heading-12\">2. 创建Demo目录</h5>\n<p>创建/data/release/service_a目录</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">mkdir -p /data/release/service_a &amp;&amp; <span class=\"hljs-built_in\">cd</span> <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$_</span>\"</span>\n</code></pre><p>使用NPM安装相关依赖,在 /data/release/service_a 目录下创建并编辑 package.json，参考下面的内容。</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">touch package.json\n</code></pre><p>package.json</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">{\n  <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"service_a\"</span>,\n  <span class=\"hljs-string\">\"version\"</span>: <span class=\"hljs-string\">\"1.0.0\"</span>,\n  <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"\"</span>,\n  <span class=\"hljs-string\">\"main\"</span>: <span class=\"hljs-string\">\"index.js\"</span>,\n  <span class=\"hljs-string\">\"scripts\"</span>: {},\n  <span class=\"hljs-string\">\"author\"</span>: <span class=\"hljs-string\">\"\"</span>,\n  <span class=\"hljs-string\">\"license\"</span>: <span class=\"hljs-string\">\"ISC\"</span>,\n  <span class=\"hljs-string\">\"dependencies\"</span>: {\n    <span class=\"hljs-string\">\"express\"</span>: <span class=\"hljs-string\">\"^4.15.3\"</span>,\n    <span class=\"hljs-string\">\"zipkin\"</span>: <span class=\"hljs-string\">\"^0.7.2\"</span>,\n    <span class=\"hljs-string\">\"zipkin-instrumentation-express\"</span>: <span class=\"hljs-string\">\"^0.7.2\"</span>,\n    <span class=\"hljs-string\">\"zipkin-transport-http\"</span>: <span class=\"hljs-string\">\"^0.7.2\"</span>\n  }\n}\n</code></pre><p>安装相关依赖</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">npm install\n</code></pre><p>创建并编辑 app.js</p>\n<blockquote>\n<p>在 /data/release/service_a 目录下创建 app.js，参考下面的内容。</p>\n</blockquote>\n<pre><code class=\"hljs bash\" lang=\"bash\">touch app.js\n</code></pre><p>APP.js</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">const express = require(<span class=\"hljs-string\">'express'</span>);\nconst {Tracer, ExplicitContext, BatchRecorder} = require(<span class=\"hljs-string\">'zipkin'</span>);\nconst {HttpLogger} = require(<span class=\"hljs-string\">'zipkin-transport-http'</span>);\nconst zipkinMiddleware = require(<span class=\"hljs-string\">'zipkin-instrumentation-express'</span>).expressMiddleware;\n\nconst ctxImpl = new ExplicitContext();\nconst recorder = new BatchRecorder({\n    logger: new HttpLogger( {\n        endpoint: <span class=\"hljs-string\">'http://127.0.0.1:9411/api/v1/spans'</span>\n    })\n});\n\nconst tracer = new Tracer({ctxImpl, recorder});\n\nconst app = express();\n\napp.use(zipkinMiddleware({\n  tracer,\n  serviceName: <span class=\"hljs-string\">'service-a'</span>\n}));\n\napp.use(<span class=\"hljs-string\">'/'</span>, (req, res, next) =&gt; {\n    res.send(<span class=\"hljs-string\">'hello world'</span>);\n});\n\napp.listen(3000, () =&gt; {\n  console.log(<span class=\"hljs-string\">'service-a listening on port 3000!'</span>)\n});\n</code></pre><p>启动服务</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">node app.js\n</code></pre><h4 class=\"heading\" data-id=\"heading-13\">7. 部署完成</h4>\n<p>查看采集到的追踪数据</p>\n<blockquote>\n<p>使用浏览器访问 http://IP:9411，即可看到刚才访问产生的追踪数据。</p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-14\">附1 . 关于微信公众号</h4>\n<p>微信公众号ID：<strong>jsj201501</strong></p>\n<p>微信公众号名称：瞎说开发那些事</p>\n<p>感谢您的关注和阅读，希望这篇文章能为您带来帮助。</p>\n<p>欢迎转载与分享，也请注明出处。</p>\n<p>如果您有需要了解的关于<strong>Java开发、RPA</strong>的等内容，也可以给我留言或发邮件 （shexd1001@gmail.com）。</p>\n<p></p><figure><img alt=\"公众号二维码\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/163265e00e19466e?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"344\" data-height=\"344\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;344&quot; height=&quot;344&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h4 class=\"heading\" data-id=\"heading-15\">附2 . 关于本文作者</h4>\n<p>本文作者：折(she)  向东</p>\n<p>微信号：wxxdong2102</p>\n<p>识别以下二维码，可以与作者进行更为深入的交流。</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/3/163265e00e392903?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"426\" data-height=\"413\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;426&quot; height=&quot;413&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n"
    },
    {
      "articleID": 13,
      "type": 2,
      "title": "Java高级面试题及答案【第二部分】",
      "publishTime": "2018年 05月 03日",
      "praise": "56",
      "tag": ["Spring", "服务器"],
      "author": "Java知音",
      "authorImg": "https://user-gold-cdn.xitu.io/2018/5/2/1631ff7ca0d7d3a4?imageView2/1/w/100/h/100/q/85/interlace/1",
      "comment": [
        {
          "username": "小刀在掘金",
          "commentTime": "14小时前",
          "commentText": "期待之后的面试系列",
          "admire":"3",
          "commentImg":"https://thirdwx.qlogo.cn/mmopen/vi_32/P57VCUFpmkI81s8uBHOMiaVItRmolrZGic7XePYeqq8W8v2BvVd5yqZhqA7ziaAzwF51ADMxINiaibfkchMt5oDIkiaQ/132"
        }
      ],
      "preview":"InnoDB引擎是MySQL数据库的一个重要的存储引擎,和其他存储引擎相比,InnoDB引擎的优点是支持兼容ACID的事务(类似于PostgreSQL),以及参数完整性(有外键)等。现在Innobase实行双认证授权.MySQL5.5.5以后默认的存储引擎都是InnoDB引擎。",
      "content":"<h2 data-id=\"heading-0\"><b>谈一谈对MySQL InnoDB的认识</b></h2><p><b>介绍：</b></p><p>InnoDB引擎是MySQL数据库的一个重要的存储引擎,和其他存储引擎相比,InnoDB引擎的优点是支持兼容ACID的事务(类似于PostgreSQL),以及参数完整性(有外键)等。现在Innobase实行双认证授权.MySQL5.5.5以后默认的存储引擎都是InnoDB引擎。</p><p><b>特点是：</b></p><p>1、具有较好的事务支持：支持4个事务隔离级别，支持多版本读</p><p>2、行级锁定：通过索引实现，全表扫描仍然会是表锁，注意间隙锁的影响</p><p>3、读写阻塞与事务隔离级别相关</p><p>4、具有非常高效的缓存特性：能缓存索引，也能缓存数据</p><p>5、整个表和主键以Cluster方式存储，组成一颗平衡树</p><p>6、所有Secondary Index都会保存主键信息</p><p><b>适用场景：</b></p><p>1、需要事务支持（具有较好的事务特性）</p><p>2、行级锁定对高并发有很好的适应能力，但需要确保查询是通过索引完成</p><p>3、数据更新较为频繁的场景</p><p>4、数据一致性要求较高</p><p>5、硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，尽可能减少磁盘IO</p><p><br></p><h2 data-id=\"heading-1\"><b>谈一谈数据库事务的隔离级别？</b></h2><p>1、Read uncommitted（读未提交）就是一个事务可以读取另一个未提交事务的数据。</p><p>2、Read committed（读提交）就是一个事务要等另一个事务提交后才能读取数据。</p><p>3、Repeatable read（重复读）就是在开始读取数据（事务开启）时，不再允许修改操作。</p><p>4、Serializable（序列化）在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。是最高的事务隔离级别，但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p><div><blockquote>事务的作用就是保证数据的一致性、完整性。事务隔离级别越高，在并发下会产生的问题就越少，但同时付出的性能消耗也将越大，因此很多时候必须在并发性和性能之间做一个权衡。所以设立了几种事务隔离级别，以便让不同的项目可以根据自己项目的并发情况选择合适的事务隔离级别，对于在事务隔离级别之外会产生的并发问题，在代码中做补偿。</blockquote></div><p><br></p><h2 data-id=\"heading-2\"><b>MySQL主备同步的基本原理</b></h2><p>MySQL支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</p><p>MySQL复制是基于主服务器在二进制日志中跟踪所有对数据库的更改。因此，要进行复制，必须在主服务器上启用二进制日志。每个从服务器从主服务器接收主服务器已经记录到日志的数据。</p><p>当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，并在本机上执行相同的更新。然后封锁并等待主服务器通知新的更新。从服务器执行备份不会干扰主服务器，在备份过程中主服务器可以继续处理更新。</p><p><br></p><h2 data-id=\"heading-3\"><b>Java语言中一个显著的特点就是引入了垃圾回收机制，这个大家都清楚，垃圾回收的概念这里也不做介绍，重点是垃圾回收是在什么时候开始？对什么东西，做了什么事情？</b></h2><p><b>GC何时开始：</b></p><p>所有的回收器类型都是基于分代技术来实现的，那就必须要清楚对象按其生命周期是如何划分的。</p><ul><li><p>年轻代：划分为三个区域：原始区(Eden)和两个小的存活区(Survivor)，两个存活区按功能分为From和To。绝大多数的对象都在原始区分配，超过一个垃圾回收操作仍然存活的对象放到存活区。垃圾回收绝大部分发生在年轻代。</p></li><li><p>年老代：存储年轻代中经过多个回收周期仍然存活的对象，对于一些大的内存分配，也可能直接分配到永久代。<br></p></li><li><p>持久代：存储类、方法以及它们的描述信息，这里基本不产生垃圾回收。</p></li></ul><p><b>有了以上这些铺垫之后开始回答GC何时开始：</b></p><p>Eden内存满了之后，开始Minor GC（从年轻代空间回收内存被称为 Minor GC）；升到老年代的对象所需空间大于老年代剩余空间时开始Full GC（但也可能小于剩余空间时，被HandlePromotionFailure参数强制Full GC）</p><p><b>对什么东西操作，即垃圾回收的对象是什么：</b></p><p>从root开始搜索没有可达对象，而且经过第一次标记、清理后，仍然没有复活的对象。</p><p><b>做了什么东西：</b></p><p>主要做了清理对象，整理内存的工作。具体的引申如下</p><p><b>垃圾回收器的类型：</b></p><ul><li><p>串行垃圾回收器（Serial Garbage Collector）</p></li><li><p>并行垃圾回收器（Parallel Garbage Collector）</p></li><li><p>并发标记扫描垃圾回收器（CMS Garbage Collector）</p></li><li><p>G1垃圾回收器（G1 Garbage Collector）</p></li></ul><p><b>垃圾回收算法：</b></p><ul><li><p>引用计数法</p></li><li><p>标记清除法</p></li><li><p>复制算法</p></li><li><p>标记压缩算法</p></li><li><p>分代算法</p></li><li><p>分区算法</p></li></ul><blockquote>以上这些，可以自己了解一下，这里列举几篇相关文章：<br><u><a href=\"https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njc5NjM1NQ%3D%3D%26mid%3D2247484719%26idx%3D1%26sn%3Dc0f3a3d518dd89a08acad5f0ef0cdca6%26chksm%3Debd63a03dca1b315cf60bbdcd034ad22d5a0c1afe194d185fe0cf5b19ce15fb3e70630f3c9b9%26scene%3D21%23wechat_redirect\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JVM的内存区域划分<br></a></u><u><a href=\"https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njc5NjM1NQ%3D%3D%26mid%3D2247484237%26idx%3D1%26sn%3D79d99a5bc17453e5cdd3ca1f9ad97d13%26chksm%3Debd63c61dca1b5776136bf20f63e4654facf4e025e9ef01d94c7662a8916613fc86d345d3307%26scene%3D21%23wechat_redirect\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JVM知识点梳理<br></a></u><u><a href=\"https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njc5NjM1NQ%3D%3D%26mid%3D2247484011%26idx%3D1%26sn%3D2efb8e99d2ce18b6a8f640978c09ab16%26chksm%3Debd63d47dca1b4516161db13f20e8ef3cc2b3c055fbb06ca81e92fa5cf96215304a3067ce5c7%26scene%3D21%23wechat_redirect\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JVM内存分配与回收<br></a></u><a href=\"https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njc5NjM1NQ%3D%3D%26mid%3D2247484008%26idx%3D1%26sn%3D64340424e740f49329e9ed0ea58c03f6%26chksm%3Debd63d44dca1b452a491c76d088305fcb4b9ab50c29596dc3bb7941139cd6b31057a5f21900e%26scene%3D21%23wechat_redirect\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><u>JVM内存管理机制<br></u></a><a href=\"https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njc5NjM1NQ%3D%3D%26mid%3D2247484144%26idx%3D1%26sn%3D5b579333a2503296e9a3d0dcbe4b19fc%26chksm%3Debd63ddcdca1b4ca95dbf66b9a4de5c44fe3cf362678b89890feaf53122b55403f5c5deb7490%26scene%3D21%23wechat_redirect\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><u>Java虚拟机学习 - 垃圾收集器</u></a></blockquote><p><br></p><h2 data-id=\"heading-4\"><b>类在虚拟机中的加载过程</b></h2><p><b>加载Loading：</b></p><p>通过一个类的全限定名来获取一个二进制字节流、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p><p><b>验证Verification：</b></p><p>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机的自身安全。</p><p><b>准备Preparation：</b></p><p>正式为类变量分配内存并设置类变量初始值。</p><p><b>解析Resolution：</b></p><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p><b>初始化Initialization：</b></p><p>类加载过程的最后一步，到了这个阶段才真正开始执行类中定义的Java程序代码。</p><p><b>使用Using：</b></p><p>根据你写的程序代码定义的行为执行。</p><p><b>卸载Unloading：</b></p><p>GC负责卸载，这部分一般不用讨论。</p><blockquote>以上这些抛砖引玉，欢迎留言更清晰的类加载过程，相关文章可以阅读：<br><u><a href=\"https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njc5NjM1NQ%3D%3D%26mid%3D2247484617%26idx%3D1%26sn%3D4cbfe7fb7e3e15bb043caf2284f5223a%26chksm%3Debd63be5dca1b2f395e70b081888cb62e11d75cd01ad025e9a26ebe2d2163048d8e533853785%26scene%3D21%23wechat_redirect\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">类加载器详解<br></a></u><u><a href=\"https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njc5NjM1NQ%3D%3D%26mid%3D2247484796%26idx%3D1%26sn%3Dc71933213a5435f3a7dfd1ddea34dfc8%26chksm%3Debd63a50dca1b346ed41498c71f11e1081a675d6f0d4a95e68325e57155cb44f2d1bf4e1efa7%26scene%3D21%23wechat_redirect\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">详解java类的生命周期<br></a></u><a href=\"https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njc5NjM1NQ%3D%3D%26mid%3D2247484958%26idx%3D1%26sn%3D2b233fb7edf92a8d49fc13b381e8a20d%26chksm%3Debd63932dca1b02478eb82b01e82a355f2bb6b94bfd220b036e2372701bd1f828c08ca4e06b3%26scene%3D21%23wechat_redirect\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><u>谈谈我对面向对象以及类与对象的理解</u></a></blockquote><p><br></p><h2 data-id=\"heading-5\"><b>强引用、软引用、弱引用、虚引用与GC的关系</b></h2><p>强引用：new出的对象之类的引用，只要强引用还在，永远不会回收。</p><p>软引用：引用但非必须的对象，内存溢出异常之前回收。 </p><p>弱引用：非必须的对象，对象只能生存到下一次垃圾收集发生之前。 </p><p>虚引用：对生存时间无影响，在垃圾回收时得到通知。</p><blockquote>这个相对好理解了，相关阅读如下：<br><a href=\"https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njc5NjM1NQ%3D%3D%26mid%3D2247484796%26idx%3D2%26sn%3Dc3eda1000a5fc8e973d3a1ef242523c1%26chksm%3Debd63a50dca1b346ecefc62b403dcb3654b4c24379106ef25aad9759c492839666cac59fe324%26scene%3D21%23wechat_redirect\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><u>Java 如何有效地避免OOM：善于利用软引用和弱引用</u></a></blockquote><p><br></p><h2 data-id=\"heading-6\"><b>说一下spring中Bean的作用域</b></h2><p><b>singleton：</b></p><p>    Spring IoC容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。Singleton作用域是Spring中的缺省作用域。</p><p><b>prototype：</b></p><p>    每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而singleton全局只有一个对象。</p><p><b>request：</b></p><p>    在一次Http请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前Http Request内有效。</p><p><b>session：</b></p><p>    在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效。</p><p><b>global Session：</b></p><p>    在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。</p><p><br></p><h2 data-id=\"heading-7\"><b>说一下spring中Bean的生命周期</b></h2><ul><li><p>实例化一个Bean，也就是我们通常说的new。</p></li><li><p>按照Spring上下文对实例化的Bean进行配置，也就是IOC注入。</p></li><li><p>如果这个Bean实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的是Spring配置文件中Bean的ID。</p></li><li><p>如果这个Bean实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()，传递的是Spring工厂本身（可以用这个方法获取到其他Bean）。</p></li><li><p>如果这个Bean实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文。</p></li><li><p>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用After方法，也可用于内存或缓存技术。</p></li><li><p>如果这个Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</p></li><li><p>如果这个Bean关联了BeanPostProcessor接口，将会调用postAfterInitialization(Object obj, String s)方法。</p></li><li><p>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean接口，会调用其实现的destroy方法。</p></li><li><p>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p></li></ul><p><br></p><h2 data-id=\"heading-8\"><b>对Spring中依赖注入两种方式的认识</b></h2><p>两种注入方式为：构造方法注入和设值注入</p><ol><li><p>设值注入与传统的JavaBean的写法更相似，程序员更容易理解、接受，通过setter方式设定依赖关系显得更加直观、明显;</p></li><li><p>对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而会产生浪费。而使用设置注入，则避免这下问题;<br></p></li><li><p>在某些属性可选的情况下，多参数的构造器更加笨拙，官方更鼓励使用设值注入。<br></p></li><li><p>构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。</p></li><li><p>对于依赖关系无须变化的Bean，构造注入更有用处，因为没有setter方法，所有的依赖关系全部在构造器内设定，因此，不用担心后续代码对依赖关系的破坏。</p></li><li><p>构造注入使依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系。对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。</p></li><li><p>设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。</p></li><li><p>建议采用以设值注入为主，构造注入为辅的注入策略。对于依赖关系无须变化的注入，尽量采用构造注入;而其他的依赖关系的注入，则考虑采用set注入。</p></li></ol><p><br></p><h2 data-id=\"heading-9\"><b>Spring框架中都用到了哪些设计模式？</b></h2><ul><li><p>代理模式：在AOP和remoting中被用的比较多。</p></li><li><p>单例模式：在spring配置文件中定义的bean默认为单例模式。</p></li><li><p>模板方法模式：用来解决代码重复的问题。</p></li><li><p>前端控制器模式：Spring提供了DispatcherServlet来对请求进行分发。</p></li><li><p>依赖注入模式：贯穿于BeanFactory / ApplicationContext接口的核心理念。</p></li><li><p>工厂模式：BeanFactory用来创建对象的实例。</p></li></ul><p><br></p><h2 data-id=\"heading-10\"><b>BeanFactory 和ApplicationContext的区别</b></h2><p>BeanFactory和ApplicationContext都是接口，并且ApplicationContext是BeanFactory的子接口。</p><p>BeanFactory是Spring中最底层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能。而ApplicationContext是Spring的一个更高级的容器，提供了更多的有用的功能。</p><p>ApplicationContext提供的额外的功能：国际化的功能、消息发送、响应机制、统一加载资源的功能、强大的事件机制、对Web应用的支持等等。</p><blockquote>加载方式的区别：BeanFactory采用的是延迟加载的形式来注入Bean；ApplicationContext则相反的，它是在Ioc启动时就一次性创建所有的Bean,好处是可以马上发现Spring配置文件中的错误，坏处是造成浪费。</blockquote><p><br></p><p><i>这一篇先总结这些，欢迎关注我的公众号“Java知音”，只推送有价值的文章！</i></p><p><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/2/1631fff4dbce4e27?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;\"></p><p><br></p>"
    },
    {
      "articleID": 14,
      "type": 2,
      "title": "大型跨境电商JVM调优经历",
      "publishTime": "2018年 05月 26日",
      "praise": "37",
      "tag": ["JVM","Java"],
      "author": "scholers",
      "authorImg": "https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er5sxy8gHOdq0CFvbiak4gMZD6VBx7v4ng10Ij3nnha9yEPNicGJziaoNC6Ie9BSJPLFw3ibIy50pW5Tw/132",
      "comment": [],
      "preview":"某大型跨境电商业务发展非常快，线上机器扩容也很频繁，但是对于线上机器的运行情况，特别是jvm内存的情况，一直没有一个统一的标准来给到各个应用服务的owner。经过618大促之后，和运维的同学讨论了下，希望将线上服务器的jvm参数标准化，可以以一个统一的方式给到各个应用，提升线上服务器的稳定性，同时减少大家都去调整jvm参数的时间",
      "content":"<p><br><br>前提：<br>某大型跨境电商业务发展非常快，线上机器扩容也很频繁，但是对于线上机器的运行情况，特别是jvm内存的情况，一直没有一个统一的标准来给到各个应用服务的owner。经过618大促之后，和运维的同学讨论了下，希望将线上服务器的jvm参数标准化，可以以一个统一的方式给到各个应用，提升线上服务器的稳定性，同时减少大家都去调整jvm参数的时间。<br>参考了之前在淘宝天猫工作的公司的经历：经过大家讨论，根据jdk的版本以及线上机器配置，确定了一个推荐的默认jvm模版：<br><br>最终推荐的jvm模版：<br>jdk版本 机器配置 建议jvm参数 备注<br>jdk1.7 6V8G -server -Xms4g -Xmx4g -Xmn2g -Xss768k -XX:PermSize=512m -XX:MaxPermSize=512m -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSClassUnloadingEnabled -XX:+DisableExplicitGC -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=68 -verbose:gc -XX:+PrintGCDetails -Xloggc:{CATALINA_BASE}/logs/gc.log -XX:+PrintGCDateStamps -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath={CATALINA_BASE}/logs 前台<br>jdk1.7 8V8G -server -Xms4g -Xmx4g -Xmn2g -Xss768k -XX:PermSize=512m -XX:MaxPermSize=512m -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSClassUnloadingEnabled -XX:+DisableExplicitGC -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=68 -verbose:gc -XX:+PrintGCDetails -Xloggc:{CATALINA_BASE}/logs/gc.log -XX:+PrintGCDateStamps -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath={CATALINA_BASE}/logs 前台<br>jdk1.7 4V8G -server -Xms4g -Xmx4g -Xmn2g -Xss768k -XX:PermSize=512m -XX:MaxPermSize=512m -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSClassUnloadingEnabled -XX:+DisableExplicitGC -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=68 -verbose:gc -XX:+PrintGCDetails -Xloggc:{CATALINA_BASE}/logs/gc.log -XX:+PrintGCDateStamps -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath={CATALINA_BASE}/logs 前台<br>jdk1.7 6V8G -server -Xms4g -Xmx4g -XX:MaxPermSize=512m \\<br>-verbose:gc -XX:+PrintGCDetails -Xloggc￼{CATALINA_BASE}/logs/gc.log -XX:+PrintGCTimeStamps \\ 后台<br><br><br>某互联网（bat）公司的推荐配置：<br>  <br><img alt=\"\" class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639ba09aa2f62c0?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1192\" data-height=\"586\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639ba09aa2f62c0?imageView2/0/w/1280/h/960/ignore-error/1\"><br> <br><br>配置说明：<br>1. 堆设置<br>o -Xms:初始堆大小<br>o -Xmx:最大堆大小<br>o -XX:NewSize=n:设置年轻代大小<br>o -XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4<br>o -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5<br>o -XX:MaxPermSize=n:设置持久代大小<br>2. 收集器设置<br>o -XX:+UseSerialGC:设置串行收集器<br>o -XX:+UseParallelGC:设置并行收集器<br>o -XX:+UseParalledlOldGC:设置并行年老代收集器<br>o -XX:+UseConcMarkSweepGC:设置并发收集器<br>3. 垃圾回收统计信息<br> -XX:+PrintGC<br> -XX:+PrintGCDetails<br> -XX:+PrintGCTimeStamps<br> -Xloggc:filename<br>\" <br>4. 并行收集器设置<br> -XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。<br> -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间<br> -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)<br>5. 并发收集器设置<br>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。<br> -XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。<br>（4）<br><br>参数解释：<br><br>-Xms3072m -Xmx3072m <br>针对JVM堆的设置，通过-Xms -Xmx限定其最小、最大值<br>-Xmn1024m设置年轻代大小为1024m<br>整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小（perm）。<br><br>-Xss768k 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。<br><br>-XX:PermSize=512m -XX:MaxPermSize=512m<br>持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。<br>设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4<br><br>-XX:+UseConcMarkSweepGC<br>CMS收集器也被称为短暂停顿并发收集器。它是对年老代进行垃圾收集的。CMS收集器通过多线程并发进行垃圾回收，尽量减少垃圾收集造成的停顿。CMS收集器对年轻代进行垃圾回收使用的算法和Parallel收集器一样。这个垃圾收集器适用于不能忍受长时间停顿要求快速响应的应用。<br><br>-XX:+UseParNewGC对年轻代采用多线程并行回收，这样收得快；<br><br>-XX:+CMSClassUnloadingEnabled<br>如果你启用了CMSClassUnloadingEnabled ，垃圾回收会清理持久代，移除不再使用的classes。这个参数只有在 UseConcMarkSweepGC  也启用的情况下才有用。<br><br>-XX:+DisableExplicitGC禁止System.gc()，免得程序员误调用gc方法影响性能；<br><br>-XX:+UseCMSInitiatingOccupancyOnly<br>标志来命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期。而是，当该标志被开启时，JVM通过CMSInitiatingOccupancyFraction的值进行每一次CMS收集，而不仅仅是第一次。然而，请记住大多数情况下，JVM比我们自己能作出更好的垃圾收集决策。因此，只有当我们充足的理由(比如测试)并且对应用程序产生的对象的生命周期有深刻的认知时，才应该使用该标志。<br><br>-XX:CMSInitiatingOccupancyFraction=68<br>默认CMS是在tenured generation(年老代）占满68%的时候开始进行CMS收集，如果你的年老代增长不是那么快，并且希望降低CMS次数的话，可以适当调高此值；<br><br>-XX:+UseParNewGC：对年轻代采用多线程并行回收，这样收得快；<br><br><br>-XX:HeapDumpPath<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:/usr/aaa/dump/heap_trace.txt<br>上面的的参数打Heap Dump信息<br>    <br>\" -XX:+HeapDumpOnOutOfMemoryError<br>此参数可以控制OutOfMemoryError时打印堆的信息<br><br><br>大家可能注意到了，这里推荐采用cms方式进行垃圾回收；<br>CMS是一种以获取最短回收停顿时间为目标的收集器，可以有效减少服务器停顿的时间；<br>CMS的GC线程对CPU的占用率会比较高，但在多核的服务器上还是展现了优越的特性，目前也被部署在国内的各大电商网站上。所以这里强烈推荐！<br><br>cms的概念：<br>CMS收集器也被称为短暂停顿并发收集器。它是对年老代进行垃圾收集的。CMS收集器通过多线程并发进行垃圾回收，尽量减少垃圾收集造成的停顿。CMS收集器对年轻代进行垃圾回收使用的算法和Parallel收集器一样。这个垃圾收集器适用于不能忍受长时间停顿要求快速响应的应用。CMS采用了多种方式尽可能降低GC的暂停时间,减少用户程序停顿。停顿时间降低的同时牺牲了CPU吞吐量 。这是在停顿时间和性能间做出的取舍，可以简单理解为\"空间(性能)\"换时间。<br><br>调整的节奏：<br>由于怕影响线上应用，所以调整的步骤分三步：<br>第一步：部分影响少量机器试点，对比未调整的机器，观察调整后的结果；<br>第二步：调整部分应用的参数，进行压测，观察高并发压测之后的效果；<br>第三步：调整部分核心应用的jvm参数，通过818大促来实际检验效果；<br>目前818大促已经结果。正好做一个个总结。<br><br>一:长期表现，<br>第一个变化：fgc的次数减少，减少了大概一倍以上；<br>mobile工程，调整前基本上一天1-2辆次，调整后基本上就是2-3天一次：<br><br><img alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639ba0ae7900730?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"608\" data-height=\"365\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;608&quot; height=&quot;365&quot;&gt;&lt;/svg&gt;\"><br> <br>online（另外一个工程）：可以明显看到fgc的统计频率少了很多；<br><br><img alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639ba0ae802f5d2?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"579\" data-height=\"336\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;579&quot; height=&quot;336&quot;&gt;&lt;/svg&gt;\"><br> <br><br><br>第二个变化：fgc的时间减少<br><br><img alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639ba0ae947a401?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"586\" data-height=\"326\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;586&quot; height=&quot;326&quot;&gt;&lt;/svg&gt;\"><br> <br><img alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639ba0ae82efce5?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"864\" data-height=\"479\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;864&quot; height=&quot;479&quot;&gt;&lt;/svg&gt;\"><br> <br><br><br><br>原来一次fgc要将近500ms，现在只要100ms不到了。<br>也证明了cms最大的好处就是减少fgc的停顿时间。<br><br>二：压测及大促表现<br>fgc的时间基本上是大大缩短，yanggc的时间变长，次数变化不大；<br>数据来源：测试团队的压测总结<br><br></p><table><tbody><tr><td><p><a href=\"https://link.juejin.im?target=http%3A%2F%2Fhzayq-haitao-online4.server.163.org%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">xxxx-online4.server.org<br>CMS</a></p></td><td><p><a href=\"https://link.juejin.im?target=http%3A%2F%2Fhzadg-haitao-online1.server.163.org%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">xxxx-online1.server.org<br>CMS</a></p></td><td><p><a href=\"https://link.juejin.im?target=http%3A%2F%2Fhzadg-haitao-online34.server.163.org%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">xxxx-online34.server.org<br>默认垃圾收集器</a></p></td><td><p>说明</p></td><td> </td></tr><tr><td><p>fullgc次数</p></td><td><p>1</p></td><td><p>1</p></td><td><p>1</p></td><td> </td></tr><tr><td><p>fullgc总时间</p></td><td><p>343</p></td><td><p>250</p></td><td><p>1219</p></td><td> </td></tr><tr><td><p>默认垃圾收集器/CMS fullgc 时间</p></td><td><p>3.55</p></td><td><p>4.88</p></td><td> </td><td><p><b>CMS fullgc</b><b>时间比默认垃圾收集器时间明显要少</b><b>。</b></p></td></tr><tr><td><p>fullgc时间点</p></td><td><p>2:48:36</p></td><td><p>3:14:36</p></td><td><p>5:30:36</p></td><td> </td></tr><tr><td><p>fullgc时使用率CPU%</p></td><td><p>40%</p></td><td><p>10%</p></td><td><p>16%</p></td><td> </td></tr><tr><td><p>fullgc时的load Average</p></td><td><p>1.19</p></td><td><p>0.49</p></td><td><p>1.21</p></td><td> </td></tr><tr><td> </td><td> </td><td> </td><td> </td><td> </td></tr><tr><td><p>younggc总次数</p></td><td><p>1094</p></td><td><p>1098</p></td><td><p>1078</p></td><td> </td></tr><tr><td><p>younggc总时间</p></td><td><p>44093</p></td><td><p>44632</p></td><td><p>30387</p></td><td> </td></tr><tr><td><p>younggc平均时间</p></td><td><p>40.30</p></td><td><p>40.65</p></td><td><p>28.19</p></td><td> </td></tr><tr><td><p>younggc最大时间</p></td><td><p>1332</p></td><td><p>1268</p></td><td><p>928</p></td><td> </td></tr><tr><td><p>CMS/默认垃圾收集器（younggc总时间）</p></td><td><p>1.45</p></td><td><p>1.47</p></td><td> </td><td><p>CMS younggc时间比默认垃圾收集器耗时</p></td></tr><tr><td><p>CMS/默认垃圾收集器（younggc平均时间）</p></td><td><p>1.43</p></td><td><p>1.44</p></td><td> </td><td><p>CMS younggc时间比默认垃圾收集器耗时</p></td></tr><tr><td><p>CMS/默认垃圾收集器（younggc最大时间）</p></td><td><p>1.44</p></td><td><p>1.37</p></td><td> </td><td><p>CMS younggc时间比默认垃圾收集器最差情况要差</p></td></tr></tbody></table><p></p><p></p><p></p><p>&lt;!--EndFragment--&gt;<br><br>三：关于哨兵上统计full gc的次数的解释，哨兵上<br>我们可以安全的说：<br>1. Full GC == Major GC指的是对老年代/永久代的stop the world的GC<br>2. Full GC的次数 = 老年代GC时 stop the world的次数<br>3. Full GC的时间 = 老年代GC时 stop the world的总时间<br>4. CMS 不等于Full GC，我们可以看到CMS分为多个阶段，只有stop the world的阶段被计算到了Full GC的次数和时间，而和业务线程并发的GC的次数和时间则不被认为是Full GC<br><br>Full GC的次数说的是stop the world的次数，所以一次CMS至少会让Full GC的次数+2，因为CMS Initial mark和remark都会stop the world，记做2次。而CMS可能失败再引发一次Full GC<br>如果CMS并发GC过程中出现了concurrent mode failure的话那么接下来就会做一次mark-sweep-compact的full GC，这个是完全stop-the-world的。 <br><br>正是这个特征，使得CMS的每个并发GC周期总共会更新full GC计数器两次，initial mark与final re-mark各一次；如果出现concurrent mode failure，则接下来的full GC自己算一次。 <br><br>四：遇到的几个问题：<br>问题一：堆栈溢出；<br>-Xss256k这个参数调整了，远涛反馈可能会影响trace的调用。 报如下错误：<br>Java.lang.StackOverflowError<br>at net.sf.jsqlparser.util.deparser.ExpressionDeParser.visitBinaryExpression(ExpressionDeParser.java:278)<br>at net.sf.jsqlparser.util.deparser.ExpressionDeParser.visit(ExpressionDeParser.java:246)<br>at net.sf.jsqlparser.expression.operators.conditional.OrExpression.accept(OrExpression.java:37)<br>at net.sf.jsqlparser.util.deparser.ExpressionDeParser.visitBinaryExpression(ExpressionDeParser.java:278)<br>at net.sf.jsqlparser.util.deparser.ExpressionDeParser.visit(ExpressionDeParser.java:246)<br>因为这个参数是设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下，减小这个值能生成更多的线程。<br>所以今天去掉某台inventory机器的-Xss256k参数，看一下是不是这个导致的<br><br>问题二：初始化标记阶段耗时过长：<br>一般的建议是cms阶段两次STW的时间不超过200ms,如果是CMS Initial mark阶段导致的时间过长：<br>在初始化标记阶段（CMS Initial mark），为了最大限度地减少STW的时间开销，我们可以使用：<br>-XX:+CMSParallelInitialMarkEnabled<br>开启初始标记过程中的并行化，进一步提升初始化标记效率；<br>问题三：remark阶段stw的时间过长<br>如下图：<br><br><br><img alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639ba0ae8c99b1e?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"291\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;291&quot;&gt;&lt;/svg&gt;\"><br> <br>可以采用的方式是：<br>   在CMS GC前启动一次ygc，目的在于减少old gen对ygc gen的引用，降低remark时的开销-----一般CMS的GC耗时 80%都在remark阶段<br>-XX:+CMSScavengeBeforeRemark<br>jmap分析：<br>  <br><img alt=\"\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639ba0ae9fdb188?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"864\" data-height=\"366\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;864&quot; height=&quot;366&quot;&gt;&lt;/svg&gt;\"><br> <br><br>问题四：nio框架占用DirectMemory导致的OutOfMemoryError<br>处理方式：使用XX:+DisableExplicitGC<br>增加DirectMemory的大小；<br>1、DirectMemory不属于java堆内存、分配内存其实是调用操作系统的Os:malloc()函数。<br>2、容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值(-Xmx指定)一样。注意 ibm jvm默认Direct Memory与-Xmx无直接关系。<br>3、Direct Memory 内存的使用避免Java堆和Native堆中来回复制数据。从某些场景中提高性能。<br>4、直接ByteBuffer对象会自动清理本机缓冲区，但这个过程只能作为Java堆GC的一部分来执行，因此它们不会自动响应施加在本机堆上的压力。<br>5、GC仅在Java堆被填满，以至于无法为堆分配请求提供服务时发生，或者在Java应用程序中显示调用System.gc()函数来释放内存（一些NIO框架就是用这个方法释放占用的DirectMemory）。<br>6、该区域使用不合理，也是会引起OutOfMemoryError。<br>7、在需要频繁创建Buffer的场合，由于创建和销毁DirectBuffer的代价比较高昂，是不宜使用DirectBuffer的，但是如果能将DirectBuffer进行复用，那么 ，在读写频繁的情况下，它完全可以大幅改善性能。（对DirectBuffer的读写比普通Buffer快，但是对他的创建和销毁比普通Buffer慢）。<br><br><br><br><br><br><br><br></p><p><br></p>"
    },
    {
      "articleID": 15,
      "type": 2,
      "title": "Nginx服务器开箱体验",
      "publishTime": "2018年 05月 26日",
      "praise": "15",
      "tag": ["Docker","后端"],
      "author": "CodeSheep",
      "authorImg": "https://user-gold-cdn.xitu.io/2018/1/3/160bad2fb2119c8c?imageView2/1/w/100/h/100/q/85/interlace/1",
      "comment": [],
      "preview":"Nginx是高性能的轻量级WEB服务器，由于其提供HTTP代理和反向代理、负载均衡、缓存等一系列重要特性，从而广泛应用于当今的WEB服务之中，学习其很有必要。笔者也是从一个初学者开始学习并记录，希望后续渐渐深入。",
      "content":"<hr>\n<h1 class=\"heading\" data-id=\"heading-0\">概述</h1>\n<p>Nginx是高性能的轻量级WEB服务器，由于其提供HTTP代理和反向代理、负载均衡、缓存等一系列重要特性，从而广泛应用于当今的WEB服务之中，学习其很有必要。笔者也是从一个初学者开始学习并记录，希望后续渐渐深入。</p>\n<blockquote>\n<p>对了，为什么不用Docker来启动Nginx呢？因为不想啊！</p>\n</blockquote>\n<hr>\n<h1 class=\"heading\" data-id=\"heading-1\">实验环境</h1>\n<ul>\n<li>CentOS 7.4 64Bit</li>\n<li>Nginx 1.14.0 稳定版</li>\n</ul>\n<hr>\n<h1 class=\"heading\" data-id=\"heading-2\">下载Nginx</h1>\n<pre><code class=\"hljs bash\" lang=\"bash\">wget http://nginx.org/download/nginx-1.14.0.tar.gz\n</code></pre><hr>\n<h1 class=\"heading\" data-id=\"heading-3\">安装Nginx</h1>\n<ul>\n<li><strong>安装第三方库</strong></li>\n</ul>\n<pre><code class=\"hljs bash\" lang=\"bash\">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel\nyum -y install pcre-devel\n</code></pre><p>安装成功以后可以查看pcre版本： <code>pcre-config —version</code></p>\n<p></p><figure><img alt=\"查看pcre版本\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639c91581c2728d?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"435\" data-height=\"77\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;435&quot; height=&quot;77&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li><strong>解压安装包</strong></li>\n</ul>\n<pre><code class=\"hljs bash\" lang=\"bash\">tar zxvf nginx-1.14.0.tar.gz\n</code></pre><ul>\n<li><strong>从configure脚本自动生成Makefile</strong></li>\n</ul>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-built_in\">cd</span> /root/nginx-1.14.0\n./configure --prefix=/usr/<span class=\"hljs-built_in\">local</span>/webserver/nginx\n</code></pre><p>这里的 <code>—prefix</code> 选项是指定Nginx的安装路径，这里我是指定安装到路径：<code>/usr/local/webserver/nginx</code></p>\n<ul>\n<li><strong>编译安装</strong></li>\n</ul>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-built_in\">cd</span> /root/nginx-1.14.0\nmake &amp;&amp; make install\n</code></pre><p>编译安装过程如下，直到完成</p>\n<p></p><figure><img alt=\"编译安装过程如下\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639c915a570e57a?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"793\" data-height=\"887\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;793&quot; height=&quot;887&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li><strong>查看Nginx版本</strong></li>\n</ul>\n<pre><code class=\"hljs bash\" lang=\"bash\">/usr/<span class=\"hljs-built_in\">local</span>/webserver/nginx/sbin/nginx -v\n</code></pre><p></p><figure><img alt=\"查看Nginx版本\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639c915c2195b18?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"665\" data-height=\"91\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;665&quot; height=&quot;91&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<ul>\n<li><strong>查看安装后的目录</strong></li>\n</ul>\n<p>总共四个目录：<code>conf</code>、<code>html</code>、<code>logs</code>、<code>sbin</code></p>\n<p></p><figure><img alt=\"查看安装后的目录\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639c915b604be1b?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"514\" data-height=\"158\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;514&quot; height=&quot;158&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<hr>\n<h1 class=\"heading\" data-id=\"heading-4\">启动Nginx</h1>\n<pre><code class=\"hljs bash\" lang=\"bash\">/usr/<span class=\"hljs-built_in\">local</span>/webserver/nginx/sbin/nginx\n</code></pre><p>浏览器访问Nginx成功（注意：由于我的机子上80端口被占用了，因此我将Nginx起在81端口上了）：</p>\n<p></p><figure><img alt=\"浏览器访问成功\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639c91585b255a6?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"896\" data-height=\"317\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;896&quot; height=&quot;317&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<hr>\n<h1 class=\"heading\" data-id=\"heading-5\">常用指令</h1>\n<ul>\n<li>测试nginx测试文件是否正确</li>\n</ul>\n<pre><code class=\"hljs bash\" lang=\"bash\">/usr/<span class=\"hljs-built_in\">local</span>/webserver/nginx/sbin/nginx -t\n</code></pre><ul>\n<li>指定配置文件启动</li>\n</ul>\n<pre><code class=\"hljs bash\" lang=\"bash\">/usr/<span class=\"hljs-built_in\">local</span>/webserver/nginx/sbin/nginx -c /usr/<span class=\"hljs-built_in\">local</span>/nginx/conf/nginx.conf\n</code></pre><ul>\n<li>重启nginx</li>\n</ul>\n<pre><code class=\"hljs bash\" lang=\"bash\">/usr/<span class=\"hljs-built_in\">local</span>/webserver/nginx/sbin/nginx <span class=\"hljs-_\">-s</span> reload            <span class=\"hljs-comment\"># 重新载入配置文件</span>\n/usr/<span class=\"hljs-built_in\">local</span>/webserver/nginx/sbin/nginx <span class=\"hljs-_\">-s</span> reopen          <span class=\"hljs-comment\">#重启 Nginx</span>\n</code></pre><ul>\n<li>停止nginx</li>\n</ul>\n<pre><code class=\"hljs bash\" lang=\"bash\">/usr/<span class=\"hljs-built_in\">local</span>/webserver/nginx/sbin/nginx <span class=\"hljs-_\">-s</span> stop              <span class=\"hljs-comment\"># 停止 Nginx</span>\n</code></pre><hr>\n<h1 class=\"heading\" data-id=\"heading-6\">Nginx服务器配置实例与实验</h1>\n<p>准备配置文件 <code>nginx.conf</code> 如下：</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">// 全局配置\nuser  nobody  nobody;\nworker_processes  3;\nerror_log  logs/error.log;\npid  logs/nginx.pid;\n\n// events块配置\nevents {\n    use epoll;\n    worker_connections  1024;\n}\n\n// http块配置\nhttp {\n    include  mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  <span class=\"hljs-string\">'$remote_addr - $remote_user [$time_local] \"$request” '</span>\n                      <span class=\"hljs-string\">'$status $body_bytes_sent \"$http_referer” '</span>\n                      <span class=\"hljs-string\">'\"$http_user_agent\" \"$http_x_forwarded_for”’;\n\n    access_log  logs/access.log  main;\n    sendfile  on;\n    keepalive_timeout  65;\n\n    // 虚拟主机1：基于域名codesheep.com\n    server {\n        listen       8088;\n        server_name  codesheep;\n\n        access_log  /codesheep/webserver/server1/log/access.log;\n        error_page  404  /404.html;\n\n        location /server1/location1 {\n            root   /codesheep/webserver;\n            index  index.server1-location1.htm;\n        }\n\n        location /server1/location2 {\n            root   /codesheep/webserver;\n            index  index.server1-location2.htm;\n        }\n\n    }\n\n    // 虚拟主机2：基于IP地址：192.168.31.177\n    server {\n        listen       8089;\n        server_name  192.168.31.177;\n\n        access_log  /codesheep/webserver/server2/log/access.log;\n        error_page  404  /404.html;\n\n        location /server2/location1 {\n            root   /codesheep/webserver;\n            index  index.server2-location1.htm;\n        }\n\n        location /srv2/loc2 {\n            alias   /codesheep/webserver/server2/location2/;\n            index  index.server2-location2.htm;\n        }\n\n        location = /404.html {\n            root /codesheep/webserver/;\n            index 404.html;\n        }\n    }\n}\n</span></code></pre><p>很明显，在上述配置文件中配置了两个虚拟主机：一个 <strong>基于域名</strong> 、 <strong>一个基于IP地址</strong></p>\n<p>为了验证该配置的正确性，我们对照此配置，构建一个与其对应的静态站点，其目录结构如下：</p>\n<p></p><figure><img alt=\"站点结构\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639c91581a21ec4?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>现在可以启动Nginx服务器，并在浏览器中进行测试</p>\n<ul>\n<li><strong>测试站点server1的访问</strong></li>\n</ul>\n<p></p><figure><img alt=\"server1/location1\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639c915824ede26?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"992\" data-height=\"366\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;992&quot; height=&quot;366&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img alt=\"server1/location2\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639c915b32ea9e8?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1011\" data-height=\"373\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1011&quot; height=&quot;373&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>这就说明配置文件中虚拟主机1配置生效！</p>\n<blockquote>\n<p>注意：这里域名www.codesheep.com之所以能被解析识别，是因为本地配置了DNS服务器！</p>\n</blockquote>\n<ul>\n<li><strong>测试站点server2的访问</strong></li>\n</ul>\n<p></p><figure><img alt=\"server2/location1\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639c915d7703817?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1038\" data-height=\"378\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1038&quot; height=&quot;378&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img alt=\"srv2/loc2\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639c915822b92ac?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"968\" data-height=\"368\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;968&quot; height=&quot;368&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>这就说明配置文件中虚拟主机2配置生效！</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-7\">后记</h2>\n<p>作者更多的原创文章：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Flink.juejin.im%2F%3Ftarget%3Dhttps%253A%252F%252Flink.juejin.im%252F%253Ftarget%253Dhttps%25253A%25252F%25252Flink.juejin.im%25252F%25253Ftarget%25253Dhttps%2525253A%2525252F%2525252Flink.juejin.im%2525252F%2525253Ftarget%2525253Dhttps%252525253A%252525252F%252525252Flink.juejin.im%252525252F%252525253Ftarget%252525253Dhttps%25252525253A%25252525252F%25252525252Flink.juejin.im%25252525252F%25252525253Ftarget%25252525253Dhttps%2525252525253A%2525252525252F%2525252525252Fjuejin.im%2525252525252Fuser%2525252525252F59551ecdf265da6c2518cd5c%2525252525252Fposts\" rel=\"nofollow noopener noreferrer\">在掘金作者主页</a></p>\n<p>如果有兴趣，可以看看作者一些关于容器化、微服务化方面的文章：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F52fa63b222ac\" rel=\"nofollow noopener noreferrer\">RPC框架实践之：Apache Thrift</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fda80ea881424\" rel=\"nofollow noopener noreferrer\">微服务调用链追踪中心搭建</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F9bc87b5380e8\" rel=\"nofollow noopener noreferrer\">利用K8S技术栈打造个人私有云连载文章</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F9e47ffaf5e31\" rel=\"nofollow noopener noreferrer\">Docker容器可视化监控中心搭建</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fa40c36beee63\" rel=\"nofollow noopener noreferrer\">利用ELK搭建Docker容器化应用日志中心</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fe9ce05b44150\" rel=\"nofollow noopener noreferrer\">Spring Boot应用监控实战</a></li>\n</ul>\n<hr>\n<p></p><figure><img alt=\"CodeSheep\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/26/1639c9157e14aa58?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"270\" data-height=\"270\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;270&quot; height=&quot;270&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n"
    },
    {
      "articleID": 16,
      "type": 3,
      "title": "AndroidStudio gradle安装配置详解-透过现象看本质",
      "publishTime": "2018年 05月 27日",
      "praise": "4",
      "tag": ["Android","gradle"],
      "author": "jamesehng",
      "authorImg": "https://user-gold-cdn.xitu.io/2017/10/20/07a90a9a7d9494e2617aeb9489bb074e?imageView2/1/w/100/h/100/q/85/interlace/1",
      "comment": [
        {
          "username": "oXor",
          "commentTime": "10分钟前",
          "commentText": "组件化和插件化的开发里程总结 https://juejin.im/entry/5afd6df06fb9a07aca7a6252",
          "admire":"0",
          "commentImg":"https://wx.qlogo.cn/mmopen/8h9QXaJ70ibekD8IvchQ0DatVb3IbOJAaEwWx3WibvxPH3n8srvyyXDUiaAicuLhrlrTNd3TC23uuxqTCA96gAZXhw/0"
        },
        {
          "username": "mundane",
          "commentTime": "22分钟前",
          "commentText": "图好像破了",
          "admire":"0",
          "commentImg":"https://user-gold-cdn.xitu.io/2018/3/14/1622417ccb6eb1a3?imageView2/1/w/100/h/100/q/85/interlace/1"
        },
        {
          "username": "jamesehng",
          "commentTime": "1小时前",
          "commentText": "时间仓促，如有错误，欢迎指正~",
          "admire":"0",
          "commentImg":"https://user-gold-cdn.xitu.io/2017/10/20/07a90a9a7d9494e2617aeb9489bb074e?imageView2/1/w/100/h/100/q/85/interlace/1"
        }
      ],
      "preview":"相信很多人第一次安装androidstudio跑工程时候，会遇到一个问题：android sutdio第一次打开一个工程巨慢怎么办？ 或者是gradle project sync filded错误 有没有想过androidstudio是如何找到我们的gardle的？",
      "content":"<h1 class=\"heading\" data-id=\"heading-0\">背景</h1>\n<p>相信很多人第一次安装androidstudio跑工程时候，会遇到一个问题：android sutdio第一次打开一个工程巨慢怎么办？ 或者是gradle project sync filded错误</p>\n<p>有没有想过androidstudio是如何找到我们的gardle的？</p>\n<h1 class=\"heading\" data-id=\"heading-1\">原理</h1>\n<h2 class=\"heading\" data-id=\"heading-2\">关于gradle的配置分为几个部分</h2>\n<p>1.gardle的下载和配置以及原理\n2.gradle插件的下载和配置以及原理\n3.gradle配置文件的语法和原理</p>\n<h2 class=\"heading\" data-id=\"heading-3\">我们这次主要讨论前两个问题</h2>\n<p>关于gradle插件和gradle版本，官网曾有概述：</p>\n<p>The Android Studio build system is based on Gradle, and the Android plugin for Gradle adds several features that are specific to building Android apps. Although the Android plugin is typically updated in lock-step with Android Studio, the plugin (and the rest of the Gradle system) can run independent of Android Studio and be updated separately.</p>\n<p>大意就是gradle插件的版本号跟随androidstudio的版本和gradle版本号有一定的对应关系，希望大家都使用最新的版本。</p>\n<h1 class=\"heading\" data-id=\"heading-4\">gradle的安装和配置原理</h1>\n<h2 class=\"heading\" data-id=\"heading-5\">androidstudio是如何加载我们的gradle的？</h2>\n<p>1.Android Studio打开一个工程时，首先会读取gradle-wrapper.properties 文件，从而知道这个工程需要哪个版本的gradle ,然后就会去保存gradle的文件夹GRADLE_USER_HOME 去找看存不存在这个版本的gradle。\n2.不存在则会去distributionUrl 去下载</p>\n<p>涉及gradle-wrapper.properties这个文件，我们先介绍一下（了解的可以略过）</p>\n<h2 class=\"heading\" data-id=\"heading-6\">其中gradle-wrapper.properties的内容如下：</h2>\n<pre><code class=\"hljs bash\" lang=\"bash\">distributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-3.1-bin.zip\n</code></pre><h2 class=\"heading\" data-id=\"heading-7\">distributionUrl</h2>\n<p>distributionUrl是要下载的gradle的地址，使用哪个版本的gradle，就在这里修改。</p>\n<p>gradle的3种版本：</p>\n<p>gradle-xx-all.zip是完整版，包含了各种二进制文件，源代码文件，和离线的文档。例如，https://services.gradle.org/distributions/gradle-3.1-all.zip</p>\n<p>gradle-xx-bin.zip是二进制版，只包含了二进制文件（可执行文件），没有文档和源代码。例如，https://services.gradle.org/distributions/gradle-3.1-bin.zip</p>\n<p>gradle-xx-src.zip是源码版，只包含了Gradle源代码，不能用来编译你的工程。例如，https://services.gradle.org/distributions/gradle-3.1-src.zip</p>\n<p>如果只是为了编译，可以不用完整版，只需要二进制版即可，例如，gradle-3.1-bin.zip。</p>\n<h2 class=\"heading\" data-id=\"heading-8\">其他4个属性</h2>\n<p>zipStoreBase和zipStorePath组合在一起，是下载的gradle-3.1-bin.zip所存放的位置。\nzipStorePath是zipStoreBase指定的目录下的子目录。</p>\n<p>distributionBase和distributionPath组合在一起，是解压gradle-3.1-bin.zip之后的文件的存放位置。\ndistributionPath是distributionBase指定的目录下的子目录。</p>\n<p>下载位置可以和解压位置不一样。</p>\n<p>zipStoreBase和distributionBase有两种取值：GRADLE_USER_HOME和PROJECT。</p>\n<p>其中，GRADLE_USER_HOME表示用户目录。\n在windows下是%USERPROFILE%/.gradle，例如C:\\Users&lt;user_name&gt;.gradle\\。\n在linux下是$HOME/.gradle，例如~/.gradle。</p>\n<p>PROJECT表示工程的当前目录，即gradlew所在的目录。</p>\n<h2 class=\"heading\" data-id=\"heading-9\">举例：各项属性的整体含义</h2>\n<p>例1，gradle-wrapper.properties的内容如下：</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">distributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-3.1-bin.zip\n</code></pre><p>各项属性的整体含义，如下：</p>\n<p>（1） 去 https://services.gradle.org/distributions/gradle-3.1-bin.zip 下载gradle的3.1版本，只包含binary的版本。</p>\n<p>（2） 下载的gradle-3.1-bin.zip存放到C:\\Users&lt;user_name&gt;.gradle\\wrapper\\dists目录中。\n（注：具体还有2级目录，即全路径为C:\\Users&lt;user_name&gt;.gradle\\wrapper\\dists\\gradle-3.1-bin&lt;url-hash&gt;\\，gradle-3.1-bin目录是根据下载的gradle的文件名来定的，目录名是根据distribution url路径字符串计算md5值得来的，具体参考PathAssembler.java中的rootDirName()和getHash()，PathAssembler.java的位置见本文最后的参考路径）</p>\n<p>（3） 解压gradle-3.1-bin.zip，将解压后的文件存放到C:\\Users&lt;user_name&gt;.gradle\\wrapper\\dists中。（注：具体还有2级目录，同上）</p>\n<h1 class=\"heading\" data-id=\"heading-10\">解决方案</h1>\n<p>既然搞清楚了原理，也知道打开慢的原因是卡在下载gradle这一步，那么我们就自己下载gralde，然后配置上去\n(1) 修改gradle-wrapper.properties\n修改gradle-wrapper.properties 中的 distributionUrl，改成我们想要的版本，只改后面的版本就可以了，前面的部分不要改。具体版本看下面链接：</p>\n<p>Gradle下载地址：https://services.gradle.org/distributions/</p>\n<p>(2) 打开项目\n这个时候AS将自动下载gradle，并创建好目录。这时直接干掉Android Studio并退出，因为这一步是为了得到AS自动创建的下载目录，定位到下面的目录：\nLinux:</p>\n<p>~/.gradle/wrapper/dists</p>\n<p>windows:</p>\n<p>C:\\users{user name}.gradle\\wrapper\\dists</p>\n<p>进入对应的gradle版本文件夹下，会发现有一个一串乱码的文件夹\n(2) 下载gradle\n从上面的Gradle下载地址，下载对应版本的gradle，本例中为gradle-2.4-all.zip,然后删除上图中的gradle-2.4-all.zip.part文件，将下载的gradle-2.4-all.zip复制到上图中一串乱码的文件夹下，注意不要解压。这样我们就跳过了下载gradle这一步。</p>\n<p>(3) 重新开启Android Studio,打开工程，ok，一下子就打开了.</p>\n<h1 class=\"heading\" data-id=\"heading-11\">androidstudio的gradle设置也会影响gardle加载</h1>\n<p></p><figure><img alt=\"这里写图片描述\" class=\"lazyload inited\" src=\"https://img-blog.csdn.net/20180527184739842?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzMjE0NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-12\">逐个选项介绍</h2>\n<ul>\n<li>\n<p>若选中<code>Use default gradle wrapper(recommended)</code>,则设置的Gradle位置为<code>Service directory path</code>中的路径；</p>\n</li>\n<li>\n<p>若选中<code>Use local gradle distribution</code>，则设置的Gradle位置为<code>Gradle home</code>中的路径。</p>\n</li>\n</ul>\n<p>注：Service directory path是全局级的，Use default gradle wrapper(recommended)与Use local gradle distribution是项目级的，优先级高于全局级的设置。</p>\n<p>Service directory path个人理解其实就是gradle-wrapper.properties文件中，变量GRADLE_USER_HOME的具体值，可以设置，当然也有默认值，根据操作系统不同，默认值也会不同：\n在windows下是%USERPROFILE%/.gradle，例如C:\\Users&lt;user_name&gt;.gradle\\。\n在linux下是$HOME/.gradle，例如~/.gradle</p>\n<p>offline work是在一次成功编译之后使用，可以提高编译速度（前提是本地没有需要新加载的依赖包）</p>\n<h1 class=\"heading\" data-id=\"heading-13\">加载顺序（有待商榷，欢迎讨论）</h1>\n<p>1.根据gradle-wrapper.properties确定gradle版本号\n2.选中Use default gradle wrapper(recommended)，默认根据gradle-wrapper.properties文件加载：首先会读取gradle-wrapper.properties 文件，从而知道这个工程需要哪个版本的gradle ,然后就会去保存gradle的文件夹GRADLE_USER_HOME 去找看存不存在这个版本的gradle。不存在则会去distributionUrl 去下载\n3.选中Use local gradle distribution，直接根据这个目录去加载</p>\n<h1 class=\"heading\" data-id=\"heading-14\">gardle插件</h1>\n<p>gradle插件和gradle是两个独立的东西，gradle插件版本是由项目最外层的build.gradle文件决定的</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">buildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath <span class=\"hljs-string\">'com.android.tools.build:gradle:2.1.0'</span>\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // <span class=\"hljs-keyword\">in</span> the individual module build.gradle files\n    }\n}\n</code></pre><p>修改gradle插件版本之后，sync一下代码就可以了</p>\n<p>Android Studio Gradle插件版本和Gradle版本之间有一定的对应关系。</p>\n<p>Gradle插件版本一般继承自Android Studio的版本</p>\n<p>直接看官网</p>\n<p></p><figure><img alt=\"这里写图片描述\" class=\"lazyload inited\" src=\"https://img-blog.csdn.net/20180527190021633?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzMjE0NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>建议：不要写版本号+这种形式</p>\n<h2 class=\"heading\" data-id=\"heading-15\">对用关系</h2>\n<p></p><figure><img alt=\"这里写图片描述\" class=\"lazyload inited\" src=\"https://img-blog.csdn.net/20180527190059631?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzMjE0NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h1 class=\"heading\" data-id=\"heading-16\">总结</h1>\n<p>gardle的安装和配置是每个Android程序员都会遇到的，但是多多少少都会有一些困惑，理清他们背后的逻辑，对于我们的开发有很大的帮助。</p>\n<p>参考：\nhttps://blog.jetbrains.com/idea/2013/04/gradle-improvements-at-121/\nhttps://blog.csdn.net/u013553529/article/details/55011602\nhttps://www.jianshu.com/p/33089ca7c98e\nhttps://blog.csdn.net/fuchaosz/article/details/51567808</p>\n<p>转载请注明原创地址！</p>\n"
    },
    {
      "articleID": 17,
      "type": 3,
      "title": "[译] google会背叛并杀死Android吗？",
      "publishTime": "2018年 05月 25日",
      "praise": "98",
      "tag": ["Google","Android"],
      "author": "ronaldong",
      "authorImg": "https://avatars.githubusercontent.com/u/7367829?v=3",
      "comment": [
        {
          "username": "小小的我该干嘛呢",
          "commentTime": "4小时前",
          "commentText": "哇",
          "admire":"0",
          "commentImg":"https://user-gold-cdn.xitu.io/2018/5/27/1639f9979c937279?imageView2/1/w/100/h/100/q/85/interlace/1"
        },
        {
          "username": "票撇浪子",
          "commentTime": "11小时前",
          "commentText": "作为开发人员，这不是好事吗",
          "admire":"0",
          "commentImg":"https://thirdwx.qlogo.cn/mmopen/vi_32/ic71ArTrYHlRe3DQeiagf8A6xE0zuMxd5jjHuq5l0Qp7e1o6HQQQl7XCIakf2U0S0IrGk886kjEm3aBtWEF3bnzQ/132"
        }
      ],
      "preview":"Android是目前为止世界上最流行的平台，支持超过20亿台移动设备。毫无疑问，这是一个巨大的成功。 尽管如此，我怀疑Android的发展前景可能不如过去那么乐观。 我第一次产生这种想法大约始于一年前。当时谷歌宣布Kotlin编程语言将正式支持Android开发。 这个公告引发了Android开发",
      "content":"<blockquote>\n<ul>\n<li>原文地址：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.techyourchance.com%2Fwill-google-betray-kill-android%2F\" rel=\"nofollow noopener noreferrer\">Will Google Betray and Kill Android\n</a></li>\n<li>原文作者：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.techyourchance.com%2Fabout%2F\" rel=\"nofollow noopener noreferrer\">Vasiliy Zukanov</a></li>\n</ul>\n</blockquote>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/5/25/16394ebce301acd6?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"720\" src=\"https://user-gold-cdn.xitu.io/2018/5/25/16394ebce301acd6?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>Android是目前为止世界上最流行的平台，支持超过20亿台移动设备。毫无疑问，这是一个巨大的成功。</p>\n<p>尽管如此，我怀疑Android的发展前景可能不如过去那么乐观。</p>\n<p>我第一次产生这种想法大约始于一年前。当时谷歌宣布Kotlin编程语言将正式支持Android开发。 这个公告引发了Android开发者们极大的热情，但我却无法加入这一浪潮。</p>\n<p>我试图去了解Kotlin将如何与Android互惠互利，但我所能看到的仅仅是一个已经分散、混乱的开发生态系统的进一步碎片化。</p>\n<p>我曾希望谷歌会与我们分享更多的信息，但他们没有。他们只是说Kotlin得到了官方的支持，因为它是“更好的”开发语言，会集中精力推广它，并将Kotlin示例添加到了官方文档中。</p>\n<p>一个最直接明显的问题 -Java在Android上的路线图是什么？ - 仍未得到答复。</p>\n<h2 class=\"heading\" data-id=\"heading-0\">我为什么会写这篇文章：</h2>\n<p>有些时候，我想与我博客的读者们分享一些悲观的想法。 所以，我写了一篇文章：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.techyourchance.com%2Fkotlin-vs-java-whole-story%2F\" rel=\"nofollow noopener noreferrer\">通过一系列的量化分析来说明Kotlin的引入可能会对Android产生副作用</a>。 令人惊讶的是，这篇文章吸引了不少读者的关注并收到了很多反馈。</p>\n<p>我分析了这些反馈，并指出大家对于JetBrains为什么要发明和推广Kotlin似乎存在着误解。 许多开发人员专注于技术方面，却忘记了JetBrains如果没有明确的商业模式就不会在Kotlin上投入如此巨大的资源。没问题，我也是这样写的。</p>\n<p>下一步我想分享一些我认为Google会采用Kotlin的原因，但我陷入了数月的困境。</p>\n<p>最开始我认为Google采用Kotlin是因为他们与Oracle在Android上使用了Java这一问题上存在持续的法律纠纷。我觉得Kotlin可以帮助谷歌摆脱这个纠纷。然而，在详细研究了甲骨文与谷歌的诉讼之后，我觉得我想错了。</p>\n<p>我的心中逐渐产生了另一种更可怕的假设 - 谷歌采用Kotlin并伤害我们以更好地对抗甲骨文的诉讼。</p>\n<p>接下来我将与你们分享我这个可怕的推测。</p>\n<p>请记住，这篇文章是我系列文章中的第三篇。 它建立在我的第一篇文章的内容基础上，这篇文章解释了<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.techyourchance.com%2Fwhy-google-adopted-kotlin-for-android%2F\" rel=\"nofollow noopener noreferrer\">谷歌为什么采用Kotlin</a>，第二篇文章<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.techyourchance.com%2Fshocking-truth-about-oracle-vs-google-android-lawsuit%2F\" rel=\"nofollow noopener noreferrer\">总结了甲骨文与谷歌的诉讼</a>。 我假设你已经阅读了本系列的前两篇文章。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">Google negotiated Java license with Oracle:</h2>\n<p>甲骨文与谷歌官司中的一个令人惊讶又觉得有趣的证据是软件工程师Tim Lindholm给“Android之父”安迪鲁宾发送的一封电子邮件：</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/25/1639508f735846bb?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"970\" data-height=\"630\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;970&quot; height=&quot;630&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>请允许我解释下这里到底发生了什么事情：</p>\n<blockquote>\n<p>也就是说，Alan Eustace认为从Android里移除Java API 是很难威胁到Safra Katz的。 但是我们认为在谈判中提出Java API 的替代方案是有价值的，这样我们就能获得使用Java API 的更好的条款和价格。 在我们看来，Obj-C提供了一种可信的替代方案。 我们想知道的是你为什么讨厌这个想法的原因，不管你认为我们在理解这个方案时错过了什么。</p>\n</blockquote>\n<p>这里提到了两个人：Google高级执行官Alan Eustace和Oracle的高级主管Safra Katz。 这封电子邮件的日期大约是在Oracle收购Sun后大约六个月的时间，在Oracle起诉谷歌之前大约两个月。</p>\n<p>在我对Oracle与Google诉讼的评论中，我提到Google肯定知道Java API是受版权保护的，并且获得了Sun的许可。事实证明，在Sun被收购之后，他们还与甲骨文进行了谈判。</p>\n<p>请注意Google是如何威胁Oracle要从Android中移除Java API 的。 他们并不打算真正这么做，但他们认为这样的威胁可以让他们获得更好的Java使用许可证条款和价格。 现在请记住这个策略。</p>\n<p>这封电子邮件中最引人注目的部分是：</p>\n<blockquote>\n<p>（拉里和谢尔格）实际上要求我们去做的是调查替换Android和Chrome中的java语言的技术方案。 我们已经完成了其中一些，并认为他们都很糟糕。</p>\n</blockquote>\n<p>我在解释Google为什么采用Kotlin时，描述了谷歌的一位中层管理人员和一位高管之间关于是否采用Kotlin的虚拟对话。 我用它来告诉你，谷歌之所以采用Kotlin是因为它“更好”或者“开发者社区要求他们这么做”这种想法是荒谬的。我还表示，Kotlin的采用可能需要Google的高层管理人员，甚至是董事会的批准。</p>\n<p>现在你知道了，谷歌创始人拉里佩奇和谢尔盖布林甚至在甲骨文起诉谷歌之前就直接参与了Android中使用了Java语言这个问题。\n今天，当Google处于数十亿美元的诉讼中时，我认为Google公司里的人是不会讨论Kotlin是一种“更简洁的编程语言”这个话题的。</p>\n<blockquote>\n<p>我们得出结论，我们需要根据我们的需求通过谈判协商来获得Java的使用许可协议。</p>\n</blockquote>\n<p>但是，但是，但是......谷歌这么多年来一直说Java API是不受版权保护的。 他们说，贪婪的甲骨文没有理由起诉他们！那么他们为什么会得出结论：他们需要通过谈判来获得Java的使用许可协议呢？难道是谷歌急于向甲骨文捐赠数亿美元，或者是他们向我们和法院撒谎吗？</p>\n<p>谷歌曾经在诉讼中辩护称他们认为API的版权将“终结我们今天所知的软件行业”。 事实证明，早在甲骨文起诉Google之前，API就有了版权概念，正因为如此，软件行业才会发展至今。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">OpenJDK:</h2>\n<p>Tim Lindholm在撰写上述电子邮件的时候OpenJDK已经三岁了。\nGoogle是可以将这个开源的Java API实现集成到Android中的。 但是，顶级的Google高管寻找到了Java的替代品，并试图操纵Oracle高管给予他们折扣。 本电子邮件中甚至没有提到要把OpenJDK作为选项。</p>\n<p>为什么谷歌不直接免费使用Oracle的开源OpenJDK，而是去与甲骨文谈判获得Java API的使用许可证？</p>\n<p>OpenJDK是根据GPL + Classpath Exception获得许可的，而Android主要是在Apache下获得许可的。 将OpenJDK整合到Android并不能帮助到谷歌，谷歌高管对此非常了解，因此在这次讨论中甚至没有提出这个选择。</p>\n<p>然而，大约六年之后，随着Android Nougat的发布，OpenJDK被引入了Android。 是什么让Google改变主意？</p>\n<p>OpenJDK和Android的许可协议都不会改变，所以OpenJDK并不是Google的安全选择。 只是在那个时候，谷歌已经实在是没有办法去说服美国联邦巡回上诉法院相信Java API是没有版权的。最高法院拒绝了谷歌的请求，要求审理此案。与此相比，与OpenJDK相关的风险不再那么大，所以Google决定整合它。</p>\n<p>但是请不要误会 - 谷歌与Android中的OpenJDK相关的风险仍然很大。</p>\n<p>首先，甲骨文可以向法院请求Android  Nougat版本之后的系统禁止使用OpenJDK，甲骨文肯定会赢得诉讼，并获得禁令。 即使谷歌能够说服法庭需要进行另一项单独的审判来确定Android  Nougat版本之后的系统的侵权损害赔偿，甲骨文很可能不会退缩。</p>\n<p>虽然谷歌有机会摆脱Android中的OpenJDK，但它不可能仅凭这一点就希望能打赢数十亿美元的官司并掌控Android的未来。</p>\n<p>所以，谷歌看上了Kotlin。</p>\n<h2 class=\"heading\" data-id=\"heading-3\">Kotlin如何帮助Google：</h2>\n<p>还记得Google在2010年与Oracle进行Java许可证谈判时使用的策略吗？ 他们试图证明他们可以把Android迁移到别的技术上，希望甲骨文能够给予他们折扣。 今天，我们知道它并不像预期的那样有效。</p>\n<p>我的一个推测是：谷歌想通过Kotlin来进行一次炒作，借此来证明他们这次是认真的。这样的话，如果谷歌决定与甲骨文达成和解，这可能是和解谈判的一个很好的筹码，甚至可能是唯一的筹码。因为就这起诉讼而言，谷歌似乎落于下风。</p>\n<p>我个人认为这个解释的可能性非常低。甲骨文明确表示，他们希望获得公平的Android份额，但谷歌曾用Android做过的所有事情都表明他们不会让任何人参与进来。看起来甲骨文和谷歌的地位相差太远，无法成为一个可行的解决方案选项。</p>\n<p>即使Kotlin只是一个谈判的的筹码，谷歌仍然需要证明他们可以将Android从Java迁移到Kotlin。</p>\n<p>除非…</p>\n<p>从理论上讲，谷歌可以重新实现Kotlin API以消除Android对Java API的依赖。 如果Java API不再使用，Google将能够从Android中删除OpenJDK。</p>\n<p>Android会在删除OpenJDK后放弃对Java应用程序的支持吗？ 我不这么认为。</p>\n<p>以Facebook为例，他们的代码库中很可能早就已经积累了一百万行Java代码。 将如此庞大的项目迁移到Kotlin将是一项非常困难和长期的工程，这将耗资数百万美元。 在可预见的未来，我认为Facebook不会达到这个水平。Google是不可能放弃对类似于Facebook等其他应用程序的支持的，因此它别无选择，只能继续使用Java来支持Java应用程序。</p>\n<p>在删除OpenJDK之后，Andorid可以在编译之前将Java编译为Kotlin，或直接编译为使用Kotlin API的代码，从而解决Java API缺失的问题。这实现起来并不困难。</p>\n<p>所以，谷歌采用Kotlin是为了从Android平台移除有争议的Java API。</p>\n<h2 class=\"heading\" data-id=\"heading-4\">Google的世界末日场景：</h2>\n<p>据我所知，如果甲骨文胜诉，理论上，他们可以在Android中获得份额，无论它是否会继续使用Java API。</p>\n<p>甲骨文表示，Google侵犯了他们的版权，并创造了一个基本上将Java从移动市场中淘汰的竞争产品。 即使谷歌此时删除侵权部分，法院仍可以判定谷歌需要对甲骨文核心业务的长期损害负责。在这种情况下，即使侵权行为停止，甲骨文也可以获得Android的份额。</p>\n<p>这对谷歌来说是一个世界末日的场景，因为甲骨文将获得Android的份额，谷歌将无法做任何事情。</p>\n<p>除非......不会再有Android。</p>\n<h2 class=\"heading\" data-id=\"heading-5\">Fuchsia:</h2>\n<p>关于Android的一个最神秘的话题是Google的新“秘密”操作系统Fuchsia是否真的打算取代Android。</p>\n<p>如果Fuchsia真的取代了Android，这对于Android生态系统的参与者来说影响将是巨大的，但Google不会与我们分享任何信息。我和其他许多Android开发人员向Google的官方代表询问了Android和Fuchsia的路线图，但据我所知，没有人能够回答这个问题。</p>\n<p>所以，让我回答一下关于Android的一个大问题：什么是Fuchsia？</p>\n<p>Fuchsia是谷歌给自己买的的一份保险。如果谷歌最终被判侵权，甲骨文将获得Android生态系统或利润的份额，那么Google将杀死Android并迁移到Fuchsia。</p>\n<p>但是，Fuchsia要想取代Android，至少必须满足三个前提条件：</p>\n<ol>\n<li>Fuchsia必须拥有足够多熟练的开发人员，以形成开发者生态系统。</li>\n<li>必须有设备能够真正运行Fuchsia。</li>\n<li>Fuchsia必须支持Android应用程序。</li>\n</ol>\n<p>我相信取代一个世界上最流行的操作系统将远不止于以上三个条件。 我选择专注于这三个先决条件的原因是：他们中的每一个都是强制性的，而且可能需要很长的时间才能实现。</p>\n<p>所以，即使谷歌决定杀死Android转而去支持Fuchsia，我们仍然会有好几年的时间，因为在短时间内无法实现上述目标。</p>\n<p>除非... Google今天已经在努力满足这些条件。</p>\n<h2 class=\"heading\" data-id=\"heading-6\">Flutter:</h2>\n<p>Flutter是谷歌新发布的移动开发SDK，支持Android和iOS。它是用一种名为Dart的语言编写的，它在底层不使用Java API。</p>\n<p>Steve Yegge（一个将会盗取谷歌的Android系统的人）曾在他的帖子中说过这样一段话：</p>\n<blockquote>\n<p>谷歌是不会被竞争对手所超越的，他们回答说：“哦，是吗？你是不可能与我们竞争的，因为我们要与自己竞争！”，于是他们推出了Flutter，说这是一种与原生Android竞争的技术栈，但是他们没有完完全全的做到这一点，只是Android团队拒绝承认罢了。</p>\n</blockquote>\n<p>这篇文章精确地表达了Flutter所处的荒谬环境。也就是说，我不认为Google确实在与自己竞争。</p>\n<p>那么，让我回答另一个与Android相关的问题：Google为什么启动并推广Flutter？</p>\n<p>Flutter也是用于编写Fuchsia应用程序的官方SDK，这不是什么秘密。 如果他们决定在有朝一日杀死Android而选择Fuchsia，鉴于谷歌需要建立一个由熟练的开发人员组成的生态系统，那么让Android开发人员提前了解Fuchsia上的应用程序开发是有道理的。</p>\n<h2 class=\"heading\" data-id=\"heading-7\">Project Treble:</h2>\n<p>谷歌的Project Treble的官方文档的开头有这样一段话：</p>\n<blockquote>\n<p>The Android 8.0 release includes Project Treble, a major re-architect of the Android OS framework designed to make it easier, faster, and less costly for manufacturers to update devices to a new version of Android. Treble is for all new devices launching with Android 8.0 and beyond (the new architecture is already running on the Developer Preview for Pixel phones).</p>\n</blockquote>\n<p>因此，Google投入了相当大的资源，以减少设备制造商们更新设备至新版本的Android系统的成本。 哇，Google对这些原始设备制造商真的是太好了。</p>\n<p>你已经知道会发生什么，对吧？</p>\n<p>事实上，我可以向您解释Google是如何抓住每一次机会去为OEM厂商提供帮助的。 我可以告诉你，原始设备制造商停止发布旧设备的更新与Treble无关。 我甚至可以告诉你，Treble并不是真的与这一切有关。</p>\n<p>说回到Fuchsia。</p>\n<p>Android生态系统深受碎片化问题的困扰。 我在这里说的并不是Flutter所导致的Android开发方式的碎片化， 我指的是那些影响Android系统本身以及运行它的硬件的碎片化问题。</p>\n<p>每一家设备制造商都占据一定的Android市场份额，他们可以根据其需求对Android系统进行更改。例如，设备制造商可以在Android系统里添加使其相机拍摄出来的图像超清晰的专有代码。 如果底层硬件暴露出一些特殊的功能，那么它同样需要在特定的Android系统里考虑到这些。</p>\n<p>所有这些问题都是由于这些变化会导致不同的Android版本之间不兼容。三星手机将无法运行Pixel的的Android版本和副版本。这使得在同一台设备上切换不同版本的Android系统成为了不可能，更不用说完全不同的操作系统了。</p>\n<p>如果谷歌这时候将Fuchsia发布出来，那么就没有设备可以运行它了。 Fuchsia可能需要数月甚至数年才能得到硬件制造商的正确支持。</p>\n<p>因此，用另一个操作系统来替换一个已有的操作系统是非常困难的任务。</p>\n<p>幸运的是，Google对软件工程的基本定理是这样描述的：</p>\n<blockquote>\n<p>We can solve any problem by introducing an extra level of indirection.</p>\n</blockquote>\n<p>目前还不清楚这种“indirection”与Project Treble有何关系。</p>\n<p>因此，Project Treble并不是关于如何帮助硬件制造商或者关心Android用户的。 它完全是为了确保硬件制造商标准化他们的平台，让他们为Fuchsia做好准备。 我不知道Google是否计划将Fuchsia推向运行Android的设备。然而，很显然，他们希望移动设备能够在启动时支持Fuchsia。</p>\n<p>我认为我可以肯定地说今天制造的绝大多数设备都已经支持Fuchsia。</p>\n<p>此时，您可能倾向于指出Android和Fuchsia之间的技术差异。这些操作系统的确基于不同的技术栈。不过，我可以向你保证，谷歌有数十亿条理由让Fuchsia与Android设备兼容。</p>\n<p>因此，前面提到的第二个先决条件已经满足了。</p>\n<h2 class=\"heading\" data-id=\"heading-8\">Android applications on Fuchsia:</h2>\n<p>为了杀死Android，Google需要确保Fuchsia支持Android应用程序。 这一点不需要我过多的解释。</p>\n<p>我计划这部分内容的时间比较长，因为我需要解释Fuchsia如何支持Android应用程序。 我想表明这不是不可行的，谷歌可能已经朝着这个方向前进。</p>\n<p>幸运的是，我不再需要解释这些了。 我可以向你展示9天前的这条推文：</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/25/16395aae257e9f3d?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"600\" data-height=\"621\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;600&quot; height=&quot;621&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>说实话，我还没有认真研究过这段提交的代码，我不完全确定它与我在研究的问题是完全相关的。但是，我不认为这是一个巧合。</p>\n<p>那么，前面提到的第一个和第三个先决条件似乎也已经满足了。</p>\n<h2 class=\"heading\" data-id=\"heading-9\">谷歌何时会杀死Android：</h2>\n<p>Android社区里有很多淡化Kotlin，Flutter和Fuchsia的声音。 我个人认为，这种情况绝对至关重要，并会给Android生态系统的所有参与者带来巨大的个人和商业风险。</p>\n<p>在这篇文章中，我与你分享了我思考这个问题的过程 ：从 谷歌为什么采用Kotlin？ 到Android的Java的路线图是什么？ 然后到在Android上正在发生着什么事情？</p>\n<p>现在我认为最重要的问题是： Google何时会杀死Android？</p>\n<p>从技术的角度来看，我估计谷歌可以在一两年内用Fuchsia代替Android。</p>\n<p>但是请记住，这一过程与技术无关，也与用户、开发者、设备制造商无关。 唯一起作用的因素是谷歌希望避免侵犯版权的责任，如果甲骨文赢得了诉讼的话。</p>\n<p>因此，法庭处理这起诉讼的进程才是决定Android命运的时间表。</p>\n<p>如果最高法院同意听取案件并恢复联邦巡回法院的一项决定，那么Google甚至可能关闭Fuchsia和Flutter项目，而Android将会依然生存下去。</p>\n<h2 class=\"heading\" data-id=\"heading-10\">Is Oracle that evil:</h2>\n<p>在这一点上，你可能倾向于把所有的这一切怪罪于甲骨文。至少这是我最初的反应，因为我认为Oracle是软件行业的魔鬼。</p>\n<p>然后，我问自己：过去甲骨文对我的职业造成了什么伤害？</p>\n<p>似乎没有，作为Android开发人员，我甚至没有参与过Oracle的生态系统。</p>\n<p>但是为什么我对甲骨文很反感呢？</p>\n<p>我认真思考了一下，并得出了一个结论：我即将成为谷歌公关的牺牲品。 多年来，我一直听到一些甲骨文是如何使坏和做恶的的事情，但我从来没有停下来认真想过这个观点。</p>\n<p>在了解了甲骨文与谷歌官司的细节之后，我确信甲骨文是正确的。 法院才是那个判定谷歌是否真的有罪的人，但毫无疑问有足够的证据证明甲骨文的行为是正当的。</p>\n<p>然后，我想到了如果Google在2005年或2006年或者是2010年从Sun获得了使用Java Api的许可证，Android生态系统将会是什么样子。它会对我们开发者设备制造商和最重要的Android用户造成什么危害？ 我实在想不出。</p>\n<p>但是，我确实看到Google决定剥夺了我们所有人的许多潜在利益。想象一下，Sun或Oracle是Android生态系统的一部分。</p>\n<p>那么我们就不会在等待多年之后才能在Android上支持Java 8。 我们将成为更大的Java生态系统的一部分，并将获得所有相关的好处。 实际上，我们将成为最大的Java开发人员群体，并且可以影响整个Java生态系统的演变。</p>\n<p>我曾经认为甲骨文是邪恶的。今天，我认为Android开发者，原始设备制造商和用户错过了许多，因为谷歌没有将Oracle视为合作伙伴，而这一切都是由于Google的贪婪所造成的。实际上这是一个非常合理的要求，因为如果您阅读了Oracle与谷歌诉讼中的证据，就会立刻明白Sun的Java生态系统是Android成功的主要因素。</p>\n<h2 class=\"heading\" data-id=\"heading-11\">结束语：</h2>\n<p>在最近的三篇文章中，我与您分享了一些关于Android的现状和未来的非常令人不安的理论。</p>\n<p>这些理论可能是全部错误的或者是部分错误的。</p>\n<p>我的这些想法解释了过去几年Android发生的一切，并回答了今天最棘手的问题。 也就是说，一个好的理论不仅解释过去，而且能预测未来。</p>\n<p>一个预言已经实现，因为看起来Google确实正在努力使Fuchsia支持Android应用程序。</p>\n<p>下面是我的的一些额外的预测：</p>\n<ol>\n<li>Kotlin不会使用Java API</li>\n<li>OpenJDK将从Android中删除</li>\n<li>Compiled Java code will either use Kotlin’s APIs or be directly compiled into native code</li>\n<li>谷歌将继续推广Flutter</li>\n<li>Google可能会试图在Flutter中使用Kotlin以进一步推广Kotlin</li>\n<li>支持Treble的Android设备将能够运行Fuchsia</li>\n<li>Android将会被杀死</li>\n</ol>\n<p>我不相信上述所有的预测都会成真。然而，如果你看到1至6中的某个预测实现了，那么请注意它增加了预测7实现的可能性。</p>\n<p>Android生态系统可能还会有其他的发展，我会尽力关注他们。在这一点上，你可能想知道该怎么做，我也不知道。</p>\n<p>正如我所说，根据这一理论，Android生态系统的每个参与者都面临着个人或者业务风险，它取决于您参与的具体情况。</p>\n<p>虽然我不能提出具体的建议，但我认为以下两个建议可能是有用的：</p>\n<ol>\n<li>考虑你个人的风险因素</li>\n<li>对谷歌的官方公告持怀疑的态度并批判性地思考。</li>\n</ol>\n<p>相信我，我也希望我的整个理论最终是废话。</p>\n"
    },
    {
      "articleID": 18,
      "type": 3,
      "title": "使用Kotlin高效地开发Android App(四）",
      "publishTime": "2018年 05月 25日",
      "praise": "87",
      "tag": ["Kotlin","Android"],
      "author": "Tony沈哲",
      "authorImg": "https://avatars.githubusercontent.com/u/198292?v=3",
      "comment": [
        {
          "username": "zilchzz",
          "commentTime": "2天前",
          "commentText": "厉害。",
          "admire":"0",
          "commentImg":"https://wx.qlogo.cn/mmopen/FMfD7NRqCxh7Y6ooAoicaU96hAc8U7iax7ic2EEXVvZok0CD1gmJr1pWicdFJjb4hugrPFfofbGW46UfWAV6ZCMT5zrFOeAbqP7B/0"
        }
      ],
      "preview":"在Kotlin的世界里，我们可以重载算数运算符，包括一元运算符、二元运算符和复合赋值运算符。 使用operator修饰符来修饰函数名的函数，这些函数可以是成员函数也可以是扩展函数。 例如，在RxKotlin的disposable.kt中有这样一个方法。 所以可以重载复合运算符 , 那如何使用它呢？",
      "content":"<p></p><figure><img alt=\"奔跑的少女.jpg\" class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/5/25/16394f2a01f37451?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"900\" data-height=\"720\" src=\"https://user-gold-cdn.xitu.io/2018/5/25/16394f2a01f37451?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-0\">一. 运算符重载</h2>\n<p>在Kotlin的世界里，我们可以重载算数运算符，包括一元运算符、二元运算符和复合赋值运算符。</p>\n<p>使用operator修饰符来修饰<code>特定</code>函数名的函数，这些函数可以是成员函数也可以是扩展函数。</p>\n<p>例如，在RxKotlin的disposable.kt中有这样一个方法。</p>\n<pre><code class=\"hljs kotlin\" lang=\"kotlin\"><span class=\"hljs-keyword\">operator</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> CompositeDisposable.<span class=\"hljs-title\">plusAssign</span><span class=\"hljs-params\">(disposable: <span class=\"hljs-type\">Disposable</span>)</span></span> {\n    add(disposable)\n}\n</code></pre><p>它满足两个条件：</p>\n<ol>\n<li>使用operator进行修饰</li>\n<li>使用了plusAssign作为函数名</li>\n</ol>\n<p>所以可以重载复合运算符<code>+=</code> , 那如何使用它呢？</p>\n<pre><code class=\"hljs kotlin\" lang=\"kotlin\">compositeDisposable += RxBus.<span class=\"hljs-keyword\">get</span>().register(PaySuccessEvent::<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">java</span>) </span>{ getServices() }\n</code></pre><p>它等价于下面的代码</p>\n<pre><code class=\"hljs kotlin\" lang=\"kotlin\">compositeDisposable.add(\n    RxBus.<span class=\"hljs-keyword\">get</span>().register(PaySuccessEvent::<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">java</span>) </span>{ getServices() }\n)\n</code></pre><p>我们会发现，重载了运算符之后代码会显得更加简洁和优雅。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">二. 简化的lambda表达式</h2>\n<p>在<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5ade9ce3f265da0b80705e22\" rel=\"nofollow noopener noreferrer\">使用Kotlin高效地开发Android App(一）</a>中，曾经介绍过尾随闭包，它可以算是一种简化的lambda表达式。</p>\n<p>对于UI控件的点击事件，可以查看我同事的文章<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F6829ae8b044f\" rel=\"nofollow noopener noreferrer\">View.OnClickListener在Kotlin中的进化</a></p>\n<p>由最初的Java版本</p>\n<pre><code class=\"hljs java\" lang=\"java\">view.setOnClickListener(<span class=\"hljs-keyword\">new</span> View.OnClickListener() {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onClick</span><span class=\"hljs-params\">(View v)</span> </span>{\n        v.setVisibility(View.VISIBLE);\n        ...\n    }\n});\n</code></pre><p>使用Kotlin不断地进行简化，最后变成：</p>\n<pre><code class=\"hljs kotlin\" lang=\"kotlin\">view.setOnClickListener {\n    it.visibility = View.VISIBLE\n    ...\n}\n</code></pre><p>再举一个RxJava的例子。</p>\n<pre><code class=\"hljs java\" lang=\"java\">        Observable.just(<span class=\"hljs-string\">\"just a test\"</span>)\n                .subscribe(<span class=\"hljs-keyword\">new</span> Consumer&lt;String&gt;() {\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">accept</span><span class=\"hljs-params\">(String s)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n\n                System.out.println(s);\n            }\n        }, <span class=\"hljs-keyword\">new</span> Consumer&lt;Throwable&gt;() {\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">accept</span><span class=\"hljs-params\">(Throwable throwable)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n                throwable.printStackTrace();\n            }\n        });\n</code></pre><p>如果使用Java的lambda进行简化，可以这样写。</p>\n<pre><code class=\"hljs java\" lang=\"java\">        Observable.just(<span class=\"hljs-string\">\"just a test\"</span>)\n                .subscribe(s -&gt; {\n                    System.out.println(s);\n                }, throwable -&gt; {\n                    throwable.printStackTrace();\n                });\n</code></pre><p>同样的代码，使用Kotlin来写的话会更加简单。</p>\n<pre><code class=\"hljs kotlin\" lang=\"kotlin\">        Observable.just(<span class=\"hljs-string\">\"just a test\"</span>)\n                .subscribe(\n                        { System.<span class=\"hljs-keyword\">out</span>.println(it) },\n                        { it.printStackTrace() }\n                )\n</code></pre><h2 class=\"heading\" data-id=\"heading-2\">三. String的处理</h2>\n<p>Java在使用String.format函数时，需要记住%d、%s等转换符。Kotlin大概是参考了Groovy的语法吧，使用<code>${变量名}</code>即可，简单方便。</p>\n<p>同样类似Groovy，Kotlin也有三个双引号来表示多行文本的输出。</p>\n<p>例如：</p>\n<pre><code class=\"hljs kotlin\" lang=\"kotlin\">        <span class=\"hljs-keyword\">var</span> jsonString: String = <span class=\"hljs-string\">\"\"\"\n            {\n                \"username\":\"tony\",\n                \"password\":\"123456\"\n            }\n            \"\"\"</span>\n        println(jsonString)\n</code></pre><p>执行结果：</p>\n<pre><code class=\"hljs kotlin\" lang=\"kotlin\">            {\n                <span class=\"hljs-string\">\"username\"</span>:<span class=\"hljs-string\">\"tony\"</span>,\n                <span class=\"hljs-string\">\"password\"</span>:<span class=\"hljs-string\">\"123456\"</span>\n            }\n</code></pre><h2 class=\"heading\" data-id=\"heading-3\">四. RxJava 和 LiveData、Lifecycle</h2>\n<p>LiveData和Lifecycle是Google在2017年新出的<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fdeveloper.android.com%2Ftopic%2Flibraries%2Farchitecture%2Fguide.html%23recommended_app_architecture\" rel=\"nofollow noopener noreferrer\">Android Architecture Components</a>的中的一部分。</p>\n<blockquote>\n<p>LiveData组件用于持有可观测的数据，它掌握着组件的生命周期信息，在组件出现活跃状态时提供更新，一般用于创建响应式UI。</p>\n</blockquote>\n<blockquote>\n<p>Lifecycle组件用于创建能够感知自身生命周期、能够基于自身状态调整行为的activity和fragment。组件可以经历多种状态——初始化、已创建、已启动、已恢复、已销毁，在状态发生改变时会调用生命周期方法来执行各种动作。</p>\n</blockquote>\n<p>借助Kotlin的扩展函数和RxJava的特性，以及参考了https://github.com/YvesCheung/LiveDataToRxJava这个库。</p>\n<p>我做了一个LiveData的扩展库\ngithub地址：https://github.com/fengzhizi715/LiveDataExtension</p>\n<p>主要功能：</p>\n<ul>\n<li>\n<p>支持LiveData转换成Observable、Flowable。通过LiveData增加的扩展函数toObservable()、toFlowable()实现。</p>\n</li>\n<li>\n<p>支持RxJava的Observable、Flowbale、Completable、Single、Maybe转换成LiveData。通过它们的扩展函数toLiveData()实现。</p>\n</li>\n<li>\n<p>支持RxJava的Observable、Flowbale、Completable、Single、Maybe绑定Lifecycle。通过它们的扩展函数bindLifecycle()实现。</p>\n</li>\n</ul>\n<p>例如在LoginViewModel中，login()函数大致可能是这样写的，替换了之前使用的RxLifecycle。当然，使用RxLifecycle的作用也是为了避免内存泄露。由于在我们的App架构中已经使用了Android Architecture Components，所以可以考虑替换RxLifecycle。</p>\n<pre><code class=\"hljs kotlin\" lang=\"kotlin\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">login</span><span class=\"hljs-params\">(owner: <span class=\"hljs-type\">LifecycleOwner</span>)</span></span>: Observable&lt;LoginResponse&gt; {\n        <span class=\"hljs-keyword\">val</span> param = LoginParam()\n        param.phoneNo = phoneNumber.value.toString()\n        param.zoneCode = zoneCode\n        param.validationCode = verificationCode.value.toString()\n\n        <span class=\"hljs-keyword\">return</span> RetrofitManager.<span class=\"hljs-keyword\">get</span>()\n                .apiService()\n                .login(param)\n                .compose(RxJavaUtils.observableToMain())\n                .bindLifecycle(owner)\n    }\n</code></pre><h1 class=\"heading\" data-id=\"heading-4\">总结</h1>\n<p>Kotlin许多简化的写法能够带来开发效率的提升，代码也会显得更加整洁和优雅。</p>\n<p>该系列的相关文章：</p>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5afb95616fb9a07acd4de5b0\" rel=\"nofollow noopener noreferrer\">使用Kotlin高效地开发Android App(三）</a></p>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5ae31d85518825671c0e4b83\" rel=\"nofollow noopener noreferrer\">使用Kotlin高效地开发Android App(二）</a></p>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5ade9ce3f265da0b80705e22\" rel=\"nofollow noopener noreferrer\">使用Kotlin高效地开发Android App(一）</a></p>\n"
    },
    {
      "articleID": 19,
      "type": 3,
      "title": "饿了么UETool原理初探",
      "publishTime": "2018年 05月 21日",
      "praise": "112",
      "tag": ["Element","Android"],
      "author": "zjw-swun",
      "authorImg": "https://avatars.githubusercontent.com/u/11499027?v=3",
      "comment": [
        {
          "username": "EthanCo",
          "commentTime": "3天前",
          "commentText": "厉害厉害",
          "admire":"0",
          "commentImg":"https://avatars.githubusercontent.com/u/13689464?v=3"
        }
      ],
      "preview":"一样都是静态显示view边距以及相关状态，但是！有了UEtool，不仅能看见view的各种属性，你还能动态改！也就是说你不仅能看你还能摸，有了这个工具，我再也不用为了改1，2个dp的边距我再编译运行了！设计同学也能更好调整UI了。 以UETool官方Demo的捕捉控件功能例吧。",
      "content":"<blockquote>\n<p>最近看见一个好库<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Feleme%2FUETool\" rel=\"nofollow noopener noreferrer\">github.com/eleme/UEToo…</a></p>\n</blockquote>\n<h1 class=\"heading\" data-id=\"heading-0\">1.饿了么UETool效果图&amp;&amp;用途</h1>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/5/21/1638311676e0791e?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1172\" data-height=\"1042\" src=\"https://user-gold-cdn.xitu.io/2018/5/21/1638311676e0791e?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>自从我把这个工具给我们设计同学安利之后，她们就爱的不要不要的，用过安卓系统开发者选项的同学知道，有一个查看边界的按钮，但是有时候呢，觉得功能不够，因为开发者选项显示边距的和android studio的Layout Inspector 或者DDMS 的uiautomator工具</p>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/5/21/1638315ded089c73?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"516\" data-height=\"348\" src=\"https://user-gold-cdn.xitu.io/2018/5/21/1638315ded089c73?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure>\n一样都是静态显示view边距以及相关状态，但是！有了UEtool，不仅能看见view的各种属性，你还能动态改！也就是说你不仅能看你还能摸，有了这个工具，我再也不用为了改1，2个dp的边距我再编译运行了！设计同学也能更好调整UI了。<p></p>\n<h1 class=\"heading\" data-id=\"heading-1\">2.饿了么UETool原理初探</h1>\n<p>以UETool官方Demo的捕捉控件功能例吧。</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/21/163831de0dbe7c93?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"582\" data-height=\"1118\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;582&quot; height=&quot;1118&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure>\n如何快速分析一个我们完全陌生的app呢，那上工具，第一步先看看目前activity是谁<p></p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/21/163831f78829d013?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1154\" data-height=\"124\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1154&quot; height=&quot;124&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure>\n<code>adb shell dumpsys window w | findstr mCurrent</code>或者\n<code>adb shell dumpsys window w | grep mCurrent</code>\n该命令能区分activity和popupwindow （win用findstr mac/linux用 grep）<p></p>\n<p>好目标就是<code>me.ele.uetool.TransparentActivity</code></p>\n<p>第二步，看目标View</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/21/1638322fa70eabdf?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"790\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;790&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>这就是捕捉控件功能对应的特殊ViewGroup了，它有一个成员变量叫<code>AttrsDialog</code>是一个自定义Dialog,展示的就是View属性列表的RecyclerView，我们重点看它的adapter</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">  public static class Adapter extends RecyclerView.Adapter {\n\n        private List&lt;Item&gt; items = new ItemArrayList&lt;&gt;();\n        private AttrDialogCallback callback;\n\n        public void <span class=\"hljs-built_in\">set</span>AttrDialogCallback(AttrDialogCallback callback) {\n            this.callback = callback;\n        }\n\n        public void notifyDataSetChanged(Element element) {\n            items.clear();\n            <span class=\"hljs-keyword\">for</span> (String attrsProvider : UETool.getInstance().getAttrsProvider()) {\n                try {\n                    IAttrs attrs = (IAttrs) Class.forName(attrsProvider).newInstance();\n                    items.addAll(attrs.getAttrs(element));\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            notifyDataSetChanged();\n        }\n</code></pre><p>好来一个下一个断点，我们跳过复杂的封装逻辑，直接看运行的函数看调用栈</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/21/163832940755c689?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"690\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;690&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure>\n这里我们看见了数据源其实就是element,这个element存有一个View成员变量<p></p>\n<pre><code class=\"hljs bash\" lang=\"bash\">public class UETCore implements IAttrs {\n\n    @Override\n    public List&lt;Item&gt; getAttrs(Element element) {\n        List&lt;Item&gt; items = new ArrayList&lt;&gt;();\n\n        View view = element.getView();\n\n        items.add(new SwitchItem(<span class=\"hljs-string\">\"Move\"</span>, element, SwitchItem.Type.TYPE_MOVE));\n\n        IAttrs iAttrs = AttrsManager.createAttrs(view);\n        <span class=\"hljs-keyword\">if</span> (iAttrs != null) {\n            items.addAll(iAttrs.getAttrs(element));\n        }\n\n        items.add(new TitleItem(<span class=\"hljs-string\">\"COMMON\"</span>));\n        items.add(new TextItem(<span class=\"hljs-string\">\"Class\"</span>, view.getClass().getName()));\n        items.add(new TextItem(<span class=\"hljs-string\">\"Id\"</span>, Util.getResId(view)));\n        items.add(new TextItem(<span class=\"hljs-string\">\"ResName\"</span>, Util.getResourceName(view.getResources(), view.getId())));\n        items.add(new TextItem(<span class=\"hljs-string\">\"Clickable\"</span>, Boolean.toString(view.isClickable()).toUpperCase()));\n        items.add(new TextItem(<span class=\"hljs-string\">\"Focused\"</span>, Boolean.toString(view.isFocused()).toUpperCase()));\n        items.add(new AddMinusEditItem(<span class=\"hljs-string\">\"Width（dp）\"</span>, element, EditTextItem.Type.TYPE_WIDTH, px2dip(view.getWidth())));\n        items.add(new AddMinusEditItem(<span class=\"hljs-string\">\"Height（dp）\"</span>, element, EditTextItem.Type.TYPE_HEIGHT, px2dip(view.getHeight())));\n        items.add(new TextItem(<span class=\"hljs-string\">\"Alpha\"</span>, String.valueOf(view.getAlpha())));\n        Object background = Util.getBackground(view);\n        <span class=\"hljs-keyword\">if</span> (background instanceof String) {\n            items.add(new TextItem(<span class=\"hljs-string\">\"Background\"</span>, (String) background));\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (background instanceof Bitmap) {\n            items.add(new BitmapItem(<span class=\"hljs-string\">\"Background\"</span>, (Bitmap) background));\n        }\n        items.add(new AddMinusEditItem(<span class=\"hljs-string\">\"PaddingLeft（dp）\"</span>, element, EditTextItem.Type.TYPE_PADDING_LEFT, px2dip(view.getPaddingLeft())));\n        items.add(new AddMinusEditItem(<span class=\"hljs-string\">\"PaddingRight（dp）\"</span>, element, EditTextItem.Type.TYPE_PADDING_RIGHT, px2dip(view.getPaddingRight())));\n        items.add(new AddMinusEditItem(<span class=\"hljs-string\">\"PaddingTop（dp）\"</span>, element, EditTextItem.Type.TYPE_PADDING_TOP, px2dip(view.getPaddingTop())));\n        items.add(new AddMinusEditItem(<span class=\"hljs-string\">\"PaddingBottom（dp）\"</span>, element, EditTextItem.Type.TYPE_PADDING_BOTTOM, px2dip(view.getPaddingBottom())));\n\n        <span class=\"hljs-built_in\">return</span> items;\n    }\n</code></pre><p>有View对象当然dialog显示View各个属性没问题，那么很奇怪，这个view是MainActivity的，这个新开的<code>TransparentActivity</code>是怎么拿到数据源的呢\n莫慌，看这个函数栈，注意到<code>EditAttrLayout</code> 类的triggerActionUp方法的element</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">@Override\n        public void triggerActionUp(MotionEvent event) {\n            final Element element = getTargetElement(event.getX(), event.getY());\n            <span class=\"hljs-keyword\">if</span> (element != null) {\n                EditAttrLayout.this.element = element;\n                invalidate();\n                <span class=\"hljs-keyword\">if</span> (dialog == null) {\n                    dialog = new AttrsDialog(getContext());\n                    dialog.setAttrDialogCallback(new AttrsDialog.<span class=\"hljs-function\"><span class=\"hljs-title\">AttrDialogCallback</span></span>() {\n                        @Override\n                        public void <span class=\"hljs-function\"><span class=\"hljs-title\">enableMove</span></span>() {\n                            mode = new MoveMode();\n                            dialog.dismiss();\n                        }\n                    });\n                    dialog.setOnDismissListener(new DialogInterface.<span class=\"hljs-function\"><span class=\"hljs-title\">OnDismissListener</span></span>() {\n                        @Override\n                        public void onDismiss(DialogInterface dialog) {\n                            element.reset();\n                            invalidate();\n                        }\n                    });\n                }\n                dialog.show(element);\n            }\n        }\n</code></pre><p>好发现关键句<code>getTargetElement(event.getX(), event.getY());</code>\n点进去会跳到父类CollectViewsLayout的getTargetElement方法</p>\n<pre><code class=\"hljs bash\" lang=\"bash\"> protected Element getTargetElement(<span class=\"hljs-built_in\">float</span> x, <span class=\"hljs-built_in\">float</span> y) {\n        Element target = null;\n        <span class=\"hljs-keyword\">for</span> (int i = elements.size() - 1; i &gt;= 0; i--) {\n            final Element element = elements.get(i);\n            <span class=\"hljs-keyword\">if</span> (element.getRect().contains((int) x, (int) y)) {\n                <span class=\"hljs-keyword\">if</span> (element != childElement) {\n                    childElement = element;\n                    parentElement = element;\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (parentElement != null) {\n                    parentElement = parentElement.getParentElement();\n                }\n                target = parentElement;\n                <span class=\"hljs-built_in\">break</span>;\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (target == null) {\n            Toast.makeText(getContext(), getResources().getString(R.string.uet_target_element_not_found, x, y), Toast.LENGTH_SHORT).show();\n        }\n        <span class=\"hljs-built_in\">return</span> target;\n    }\n</code></pre><p>element和elements有直接关系再看到elements <code>List&lt;Element&gt; elements</code>怎么来的呢？list数据填充无非2种常用的要么add要么addAll直接<code>command +f</code>或者<code>ctrl + f</code>搜索elements.add就发现了数据源设置的函数</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">private void traverse(View view) {\n        <span class=\"hljs-keyword\">if</span> (UETool.getInstance().getFilterClasses().contains(view.getClass().getName())) <span class=\"hljs-built_in\">return</span>;\n        <span class=\"hljs-keyword\">if</span> (view.getAlpha() == 0 || view.getVisibility() != View.VISIBLE) <span class=\"hljs-built_in\">return</span>;\n        <span class=\"hljs-keyword\">if</span> (getResources().getString(R.string.uet_disable).equals(view.getTag())) <span class=\"hljs-built_in\">return</span>;\n        elements.add(new Element(view));\n        <span class=\"hljs-keyword\">if</span> (view instanceof ViewGroup) {\n            ViewGroup parent = (ViewGroup) view;\n            <span class=\"hljs-keyword\">for</span> (int i = 0; i &lt; parent.getChildCount(); i++) {\n                traverse(parent.getChildAt(i));\n            }\n        }\n    }\n</code></pre><p>来搞个断点看调用栈，或者就在element 构造方法下断点就能省掉上面从element到elemnets的分析\n来看下图</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/21/1638338bca26257e?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"677\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;677&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>UETool拿到targetActivity也就是MainActivity，然后反射拿到decoreView，然后调用\nEditAttrLayout类的父类CollectViewsLayout类traverse方法。</p>\n<p>至此按时间顺序总结一下，<code>CollectViewsLayout</code>类的<code>onAttachedToWindow</code>通过反射拿到目标MainActivity的<code>decoreView</code>，去给<code>CollectViewsLayout</code>的成员变量<code>List&lt;Element&gt; elements</code> add包装了<code>decoreView</code>的Element，然后用户也就是我，点了UETool的<code>操作控件</code>按钮，UP事件的时候<code>AttrsDialog</code>的show方法调用<code>adapter.notifyDataSetChanged(element);</code>给Adapter设置被<code>UETCore</code>解开element各种属性的<code>List&lt;Item&gt;</code>作为数据源</p>\n<p>好了，原理简单初探到这里。饿了么大神的代码就这么大概摸完了，代码封装的很不错，建议有兴趣的同学可以看看，学习一下。</p>\n"
    },
    {
      "articleID": 20,
      "type": 3,
      "title": "项目实战之Rxjava、RxBinding在实际项目中的使用",
      "publishTime": "2018年 05月 24日",
      "praise": "146",
      "tag": ["RxJava","Android"],
      "author": "小刘哥可爱多",
      "authorImg": "https://lc-mhke0kuv.cn-n1.lcfile.com/ot9eKlbTeHanHwYUmKlZKnr38V7eJ3bRkgYRQKKq",
      "comment": [
        {
          "username": "helloworld10010",
          "commentTime": "11小时前",
          "commentText": "哇。好。爽",
          "admire":"0",
          "commentImg":"https://avatars1.githubusercontent.com/u/20741184?v=4"
        },
        {
          "username": "淡漠同志",
          "commentTime": "1天前",
          "commentText": "真正的干活，楼主威武",
          "admire":"0",
          "commentImg":"https://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLDpKia7Nz6Wic6ibbfic0K1Rvn3Gblk1YopicacR9vAzUQoiaENfoFZRTCF05lSHRLT1jQiaLlibvnzWLNdYQ/132"
        }
      ],
      "preview":"网上很多讲rxjava入门的文章，讲了什么是rxjava以及一些高大上的操作符，但是真正在项目中使用的场景很少讲，那本篇文章主要讲一下rxjava在实际项目中的应用场景，rxjava结合rxbinding在实际项目中的使用姿势了解一下。因为rxbind2 本身依赖rxjava2，所以项目中引入rxbinding就可以了，rxjava2就不用引入了。",
      "content":"<h4 class=\"heading\" data-id=\"heading-0\">前言</h4>\n<p>网上很多讲rxjava入门的文章，讲了什么是rxjava以及一些高大上的操作符，但是真正在项目中使用的场景很少讲，那本篇文章主要讲一下rxjava在实际项目中的应用场景，rxjava结合rxbinding在实际项目中的使用姿势了解一下。因为rxbind2 本身依赖rxjava2，所以项目中引入rxbinding就可以了，rxjava2就不用引入了。</p>\n<pre><code>implementation 'com.jakewharton.rxbinding2:rxbinding:2.1.1'\n</code></pre>\n<p>引入完了就看一下常用的使用场景吧：</p>\n<h4 class=\"heading\" data-id=\"heading-1\">1、优化搜索</h4>\n<p>基本上app里都有搜索这个功能需求吧，监听et的文本变化然后请求服务器拉取数据，如果不优化处理器的话，每次et的值发生变化都会请求服务器，在弱网环境下很可能出现数据错乱的问题。如果不用rxjava来处理，各种timer会把人写晕掉吧，那么看看rxjava怎么来优雅的处理：</p>\n<pre><code>//优化搜索功能\n    RxTextView.textChanges(mBinding.etSearch)\n            // 跳过一开始et内容为空时的搜索\n            .skip(1)\n            //debounce 在一定的时间内没有操作就会发送事件\n            .debounce(1000, TimeUnit.MILLISECONDS)\n            //下面这两个都是数据转换\n            //flatMap：当同时多个网络请求访问的时候，前面的网络数据会覆盖后面的网络数据\n            //switchMap：当同时多个网络请求访问的时候，会以最后一个发送请求为准，前面网路数据会被最后一个覆盖\n            .switchMap(new Function&lt;CharSequence, ObservableSource&lt;List&lt;String&gt;&gt;&gt;() {\n                @Override\n                public ObservableSource&lt;List&lt;String&gt;&gt; apply(CharSequence charSequence) throws Exception {\n                    String searchKey = charSequence.toString();\n                    System.out.println(\"binding=======搜索内容:\" + searchKey);\n                    //这里执行网络操作，获取数据\n                    List&lt;String&gt; list = new ArrayList&lt;String&gt;();\n                    list.add(\"小刘哥\");\n                    list.add(\"可爱多\");\n\n                    return Observable.just(list);\n                }\n            })\n            // .onErrorResumeNext()\n            //网络操作，获取我们需要的数据\n            .subscribeOn(Schedulers.io())\n            //界面更新在主线程\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() {\n                @Override\n                public void accept(List&lt;String&gt; strings) throws Exception {\n                    System.out.println(\"binding=======搜索到\" + strings.size() + \"条数据\");\n                }\n            });\n</code></pre>\n<p>注释写的很清楚了，不用解释了吧，需要注意的一点就是 .skip(1) 这个操作符不能少，不然页面一打开就会执行一次搜索的。</p>\n<h4 class=\"heading\" data-id=\"heading-2\">2、结合rxbinding防手抖</h4>\n<pre><code>    /**\n     * 防止多次点击--2秒内执行一次点击\n     */\n    RxView.clicks(mBinding.btClick)\n            .throttleFirst(2, TimeUnit.SECONDS)\n            .subscribe(c -&gt; System.out.println(\"binding=======点击了按钮\"));\n</code></pre>\n<p>假如一个页面有一个按钮，点击一次要请求一下服务器或者其他操作都可以，这里做了2秒内响应一次点击事件，很常用的场景。</p>\n<h4 class=\"heading\" data-id=\"heading-3\">3、长按事件</h4>\n<pre><code>    /**\n     * 长按事件\n     */\n    RxView.longClicks(mBinding.btClick)\n            .subscribe(c-&gt;System.out.println(\"binding=======长按了按钮\"));\n</code></pre>\n<p>长按事件，这个不用说了吧。</p>\n<h4 class=\"heading\" data-id=\"heading-4\">4、监听view的选中状态</h4>\n<pre><code>    /**\n     * checkbox 选中就修改textview\n     */\n    RxCompoundButton.checkedChanges(mBinding.checkbox)\n            .subscribe(new Consumer&lt;Boolean&gt;() {\n                @Override\n                public void accept(Boolean aBoolean) throws Exception {\n                    mBinding.tvCb.setText(aBoolean ? \"按钮选中了\" : \"按钮未选中\");\n                }\n            });\n</code></pre>\n<p>假如页面有一个cb,比如选中表示同意阅读了用户协议什么的，用来监听选中状态来做一些逻辑操作，几行代码就搞定。</p>\n<h4 class=\"heading\" data-id=\"heading-5\">5、注册、登录等获取验证码时的倒计时操作</h4>\n<pre><code>/**\n * 倒计时操作\n */\npublic void clickTimer(View view) {\n\n    // 2 秒后发送数据\n    Observable.timer(2, TimeUnit.SECONDS)\n            .subscribe(new Observer&lt;Long&gt;() {\n                @Override\n                public void onSubscribe(Disposable d) {\n\n                }\n\n                @Override\n                public void onNext(Long value) {\n                    System.out.println(\"binding=======value:\" + value);//0\n                }\n\n                @Override\n                public void onError(Throwable e) {\n\n                }\n\n                @Override\n                public void onComplete() {\n\n                }\n            });\n\n    //倒计时操作\n    final int count = 10;\n    Observable.interval(0, 1, TimeUnit.SECONDS)//设置0延迟，每隔一秒发送一条数据\n            .take(count + 1)//设置循环次数\n            .map(new Function&lt;Long, Long&gt;() {\n                @Override\n                public Long apply(Long aLong) throws Exception {\n\n                    return count - aLong;\n                }\n            })\n            .doOnSubscribe(new Consumer&lt;Disposable&gt;() {\n                @Override\n                public void accept(Disposable disposable) throws Exception {\n                    //在发送数据的时候设置为不能点击\n                    mBinding.btCutdown.setEnabled(false);\n\n                    //背景色\n                    mBinding.btCutdown.setBackgroundColor(Color.parseColor(\"#39c6c1\"));\n                }\n            })\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(new Observer&lt;Long&gt;() {\n                @Override\n                public void onSubscribe(Disposable d) {\n\n                }\n\n                @Override\n                public void onNext(Long value) {\n                    mBinding.btCutdown.setText(\"\" + value);\n                }\n\n                @Override\n                public void onError(Throwable e) {\n\n                }\n\n                @Override\n                public void onComplete() {\n                    mBinding.btCutdown.setText(\"重新获取\");\n                    mBinding.btCutdown.setEnabled(true);\n                    mBinding.btCutdown.setBackgroundColor(Color.parseColor(\"#d1d1d1\"));\n                }\n            });\n\n}\n</code></pre>\n<p>很简洁吧</p>\n<h4 class=\"heading\" data-id=\"heading-6\">6、注册登录等情况下，所有输入都合法再点亮登录按钮</h4>\n<pre><code>/**\n     * 注册登录等情况下，所有输入都合法再点亮登录按钮\n     */\n    Observable&lt;CharSequence&gt; name = RxTextView.textChanges(mBinding.etName).skip(1);\n    Observable&lt;CharSequence&gt; age = RxTextView.textChanges(mBinding.etAge).skip(1);\n\n    Observable.combineLatest(name, age, new BiFunction&lt;CharSequence, CharSequence, Boolean&gt;() {\n        @Override\n        public Boolean apply(CharSequence charSequence, CharSequence charSequence2) throws Exception {\n\n            boolean isNameEmpty = TextUtils.isEmpty(mBinding.etName.getText());\n            boolean isAgeEmpty = TextUtils.isEmpty(mBinding.etAge.getText());\n\n            return !isNameEmpty &amp;&amp; !isAgeEmpty;\n        }\n    })\n            .subscribe(new Consumer&lt;Boolean&gt;() {\n                @Override\n                public void accept(Boolean aBoolean) throws Exception {\n                    System.out.println(\"bt======\" + aBoolean);\n                    mBinding.btSubmit.setEnabled(aBoolean);\n                }\n            });\n</code></pre>\n<h4 class=\"heading\" data-id=\"heading-7\">7、使用interval做周期性操作</h4>\n<pre><code> /**\n * 每隔2秒 输出一次日志\n */\nDisposable mDisposable;\npublic void clickIntervar(View view) {\n\n    Observable.interval(2, TimeUnit.SECONDS)\n            .subscribe(new Observer&lt;Long&gt;() {\n                @Override\n                public void onSubscribe(Disposable d) {\n                    mDisposable =d;\n\n                }\n\n                @Override\n                public void onNext(Long value) {\n                    System.out.println(\"binding=======输出日志:\" + value);\n                    if (value == 5L) {\n                        System.out.println(\"binding=======dispose\");\n                        mDisposable.dispose();\n                    }\n                }\n\n                @Override\n                public void onError(Throwable e) {\n\n                }\n\n                @Override\n                public void onComplete() {\n\n                }\n            });\n}\n</code></pre>\n<h4 class=\"heading\" data-id=\"heading-8\">8、使用schedulePeriodically做轮询请求</h4>\n<pre><code>/**\n * 使用schedulePeriodically做轮询请求 3秒轮询一次\n */\nObservable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception {\n\n            Schedulers.newThread().createWorker()\n                    .schedulePeriodically(new Runnable() {\n                        @Override\n                        public void run() {\n                            e.onNext(\"net work-----\");\n                        }\n                    }, 0, 3, TimeUnit.SECONDS);\n\n        }\n    }).subscribe(new Consumer&lt;String&gt;() {\n        @Override\n        public void accept(String s) throws Exception {\n            System.out.println(\"binding=======net work\");\n        }\n    });\n</code></pre>\n<h4 class=\"heading\" data-id=\"heading-9\">9、网络出错重试</h4>\n<pre><code>/**\n * 网络错误重试\n * 这里just操作符 改为retrofit 网络请求返回的即可。\n */\nint mRetryCount;\n\npublic void clickRetry(View view) {\n    Observable.just(\"retry\")\n            .retryWhen(new Function&lt;Observable&lt;Throwable&gt;, ObservableSource&lt;?&gt;&gt;() {\n                @Override\n                public ObservableSource&lt;?&gt; apply(Observable&lt;Throwable&gt; throwableObservable) throws Exception {\n\n                    // 参数Observable&lt;Throwable&gt;中的泛型 = 上游操作符抛出的异常，可通过该条件来判断异常的类型\n                    return throwableObservable.flatMap(new Function&lt;Throwable, ObservableSource&lt;?&gt;&gt;() {\n                        @Override\n                        public ObservableSource&lt;?&gt; apply(Throwable throwable) throws Exception {\n\n                            // 判断异常信息  根据异常信息判断是否需要重试\n                            if (throwable instanceof IOException) {\n                                System.out.println(\"retry======y==\");\n                                // 重试\n                                // 判断重试次数 这里设置最多重试5次\n                                if (mRetryCount &lt; 5) {\n                                    mRetryCount++;\n                                    /**\n                                     * 1、通过返回的Observable发送的事件 = Next事件，从而使得retryWhen（）重订阅，最终实现重试功能\n                                     * 2、延迟1段时间再重试  采用delay操作符 = 延迟一段时间发送，以实现重试间隔设置\n                                     * 3、在delay操作符的等待时间内设置 = 每重试1次，增多延迟重试时间1s\n                                     */\n                                    int time = 1000 + mRetryCount * 1000;\n                                    return Observable.just(1).delay(time, TimeUnit.MILLISECONDS);\n                                } else {\n                                    System.out.println(\"retry======5==\");\n                                    return Observable.error(new Throwable(\"已重试5次 放弃治疗\"));\n                                }\n\n                            } else {\n                                // 不重试\n                                System.out.println(\"retry======n==\");\n                                return Observable.error(new Throwable(\"发生了非网络异常（非I/O异常）\"));\n                            }\n                        }\n                    });\n                }\n            })\n            .subscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(new Observer&lt;String&gt;() {\n                @Override\n                public void onSubscribe(Disposable d) {\n\n                }\n\n                @Override\n                public void onNext(String value) {\n                    System.out.println(\"retry======suc==\" + value);\n                }\n\n                @Override\n                public void onError(Throwable e) {\n                    System.out.println(\"retry======err==\" + e.toString());\n                }\n\n                @Override\n                public void onComplete() {\n\n                }\n            });\n\n}\n</code></pre>\n<h4 class=\"heading\" data-id=\"heading-10\">10、解决网络嵌套请求</h4>\n<pre><code>/**\n * 优化网络嵌套请求问题\n * 以下为了方便演示 写的伪代码\n */\npublic void clickRequest(View view) {\n    Observable&lt;String&gt; requestLogin = Observable.just(\"requestLogin\");\n    final Observable&lt;String&gt; request2 = Observable.just(\"request2\");\n\n    requestLogin.subscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n            .doOnNext(new Consumer&lt;String&gt;() {\n                @Override\n                public void accept(String s) throws Exception {\n                    System.out.println(\"flat=======loginsuccess\");\n                }\n            })\n            .observeOn(Schedulers.io())\n            .flatMap(new Function&lt;String, ObservableSource&lt;String&gt;&gt;() {\n                @Override\n                public ObservableSource&lt;String&gt; apply(String s) throws Exception {\n                    // 将网络请求1转换成网络请求2，即发送网络请求2\n                    return request2;\n                }\n            })\n            // （新被观察者，同时也是新观察者）切换到IO线程去发起登录请求\n            //  特别注意：因为flatMap是对初始被观察者作变换，所以对于旧被观察者，它是新观察者，所以通过observeOn切换线程\n            // 但对于初始观察者，它则是新的被观察者\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(new Consumer&lt;String&gt;() {\n                @Override\n                public void accept(String s) throws Exception {\n                    System.out.println(\"flat=======第二次请求成功\");\n                }\n            }, new Consumer&lt;Throwable&gt;() {\n                @Override\n                public void accept(Throwable throwable) throws Exception {\n                    System.out.println(\"flat=======loginerr\");\n                }\n            });\n}\n</code></pre>\n<h4 class=\"heading\" data-id=\"heading-11\">11、背压--这个就是记录一下</h4>\n<pre><code>/**\n * 背压 Flowable g观察者使用\n * 解决发送和订阅事件 流速不一致的问题\n * &lt;p&gt;\n * 注意：同步订阅中，被观察者 &amp; 观察者工作于同1线程，同步订阅关系中没有缓存区。\n * 被观察者在发送1个事件后，必须等待观察者接收后，才能继续发下1个事件.若Subscription.request没有设置，\n * 观察者接收不到事件，会抛出MissingBackpressureException异常。\n */\nSubscription mSubscription;\n\npublic void clickFlow(View view) {\n\n    Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {\n        @Override\n        public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {\n\n            /**\n             * 同步订阅：\n             * 同步订阅的情况下，调用e.requested()方法，获取当前观察者需要接收的事件数量.\n             * 根据当前观察者需要接收的事件数量来发送事件\n             *\n             * 异步订阅：\n             * 由于二者处于不同线程，所以被观察者 无法通过 FlowableEmitter.requested()知道观察者自身接收事件能力。\n             * 异步的反向控制：\n             */\n            long count = e.requested();\n            System.out.println(\"flowable======需要接收的事件数量=\" + count);\n\n            e.onNext(1);\n            e.onNext(2);\n            e.onNext(3);\n            e.onNext(4);\n            e.onNext(5);\n            e.onComplete();\n        }\n    }, BackpressureStrategy.ERROR)\n            .subscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(new Subscriber&lt;Integer&gt;() {\n                @Override\n                public void onSubscribe(Subscription s) {\n\n                    // 作用：决定观察者能够接收多少个事件,多出的事件放入缓存区.若不设置，则不接收事件.\n                    // 不过被观察者仍然在发送事件（存放在缓存区，大小为128），等观察者需要时 再取出被观察者事件（比如点击事件里）.\n                    // 但是 当缓存区满时  就会溢出报错\n                    // 官方默认推荐使用Long.MAX_VALUE，即s.request(Long.MAX_VALUE);\n                    mSubscription = s;\n                    s.request(2);\n                    // s.request(1); // 同步订阅 观察者连续要求接收事件的话，被观察者e.requested() 返回3\n                }\n\n                @Override\n                public void onNext(Integer integer) {\n\n                    System.out.println(\"flowable=======\" + integer);\n                }\n\n                @Override\n                public void onError(Throwable t) {\n\n                }\n\n                @Override\n                public void onComplete() {\n\n                }\n            });\n\n}\n</code></pre>\n<h4 class=\"heading\" data-id=\"heading-12\">12、补充一个动态权限</h4>\n<pre><code>添加依赖 compile 'com.tbruyelle.rxpermissions2:rxpermissions:0.9.5@aar'\n\n// 记得危险权限 清单文件里也需要配置。\n// 因为各个业务组件都可能使用到危险权限，我把权限统一写在了commonLibrary里\n RxPermissions permissions = new RxPermissions(this);\n    RxView.clicks(mBinding.btPermission)\n            .throttleFirst(1, TimeUnit.SECONDS)\n            .subscribeOn(AndroidSchedulers.mainThread())\n            .compose(permissions.ensure(Manifest.permission.CAMERA))\n            .subscribe(new Consumer&lt;Boolean&gt;() {\n                @Override\n                public void accept(Boolean aBoolean) throws Exception {\n                    if (aBoolean) {\n                        System.out.println(\"binding=======允许\");\n                    } else {\n                        System.out.println(\"binding=======拒绝\");\n                    }\n                }\n            });\n</code></pre>\n<h4 class=\"heading\" data-id=\"heading-13\">13、结合retrofit网络请求封装、统一错误预处理等</h4>\n<p>以上的使用场景是在现有项目中，而项目架构搭建的初期涉及到的网络封装、统一错误预处理等由于篇幅问题，要拿出来单独写了。网络返回的数据一般情况下是后台封装好的固定格式（比如错误码、错误信息由后台接口设定），这样处理起来还简单一点。但是有时候api返回的数据格式是原生的http响应格式，这样封装处理的话外面又要套一层response泛型类，处理起来稍微比第一种情况复杂一点。下篇博客再写吧。</p>\n<p>其他项目中使用到的场景，遇到了会更新在本博客……</p>\n<p>最后，国际惯例 贴出项目地址:<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Flxykad%2Farticle_demos\" rel=\"nofollow noopener noreferrer\">点我点我查看demo</a>，如果对你有帮助，麻烦动动小手start鼓励一下，谢谢。</p>\n"
    },
    {
      "articleID": 21,
      "type": 4,
      "title": "如何实现 AppStore App 的自动下载",
      "publishTime": "2018年 05月 27日",
      "praise": "22",
      "tag": ["APP","Apple"],
      "author": "Joy_xx",
      "authorImg": "https://user-gold-cdn.xitu.io/2017/6/9/832dde8b67f5596f74aaa8bbea74556b?imageView2/1/w/100/h/100/q/85/interlace/1",
      "comment": [],
      "preview":"这次的分享是关于如何在 AppStore 实现 App 的自动下载，理想中的目标是只需要一部手机，不需要人来干预，就可以模拟用户的真实下载，并在下载完成以后，可以自动更改手机参数，使之变为另外一部苹果手机，进行周而复始的下载工作。但是呢，本文的内容只包含如何去模拟用户的操作来完成下载，并不涉及抹机、IP 更换等内容。",
      "content":"<p>这次的分享是关于如何在 AppStore 实现 App 的自动下载，理想中的目标是只需要一部手机，不需要人来干预，就可以模拟用户的真实下载，并在下载完成以后，可以自动更改手机参数，使之变为另外一部苹果手机，进行周而复始的下载工作。但是呢，本文的内容只包含如何去模拟用户的操作来完成下载，并不涉及抹机、IP 更换等内容。</p>\n<p>最终效果见：https://pan.baidu.com/play/video#/video?path=%2F自动下载效果视频.mp4&amp;t=-1</p>\n<h2 class=\"heading\" data-id=\"heading-0\">为什么做这个呢？</h2>\n<p>可能会有人问，为什么要做这么一个项目。主要是两点原因吧，第一点呢，是出于个人兴趣，逆向其实在开发中的用处还是蛮大的，比如帮助我们分析 Apple 操作系统，帮我们做好安全防御。通过这么一个项目的实践，可以加深自己对逆向开发的理解，第二点呢，就是 App Search Optimization 是一个一直比较热门的话题，有白帽子和黑帽子 ASO 之分，通过关键字和标题优化等手段来进行 ASO 的属于白帽子 ASO，而通过刷榜程序来进行 ASO 的属于黑帽子 ASO，ASO 的刷榜脚本是价值不菲的，可能价值几十万甚至几百万。通过这个项目也是小试牛刀，了解下灰产的一些技术手段。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">什么是 ASO</h2>\n<p>ASO 的全称是 App Search Optimization，就是提升你 APP 在 AppStore 排行榜和搜索结果排名的过程。我们经常可以看到 AppStore 有一些奇怪的五星好评，也会遇到搜索关键字，排名第一的是一个看上去完全不相关的 App。这些都是 ASO 优化的手段，帮助提升产品的曝光量。</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/27/1639fa136358edd8?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"640\" data-height=\"365\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;640&quot; height=&quot;365&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>白帽子 ASO 常用的手段就是通过数据分析，来优化关键词、标题等，进而提高 App 的排名和曝光率。而黑帽子的手段则是，通过刷榜程序来实现 App 的大量搜索、下载、好评这一系列的过程来提升 App 的排名。</p>\n<p>常见的刷榜手段主要有两种，一种是机刷，就是通过触动精灵或者代码注入的方式来实现模拟用户的真实操作，进而完成搜索、下载、评论等操作。再一种协议刷，就是破解 AppStore 的登陆、下载相关的网络协议，通过模拟真实的网络请求来实现登陆、下载等行为。据说在刷榜过程中，苹果会校验你的 Apple ID、IP 等信息，所以需要购买大量的 Apple ID 和不断更换 IP 地址。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">如何实现 App 的自动下载</h2>\n<p>想要的效果：</p>\n<ol>\n<li>进入 AppStore，切换 tab 到搜索界面</li>\n<li>设置搜索关键字、搜索</li>\n<li>进入列表页后，点击 App 进入详情页点击下载</li>\n<li>根据提示完成登陆、下载，并在下载完成以后跳转到推荐 Tab</li>\n<li>进入推荐 Tab 后，退出登陆</li>\n</ol>\n<p>大概实现步骤：</p>\n<ol>\n<li>准备越狱手机和 Mac 电脑</li>\n<li>砸壳 dumpdecrypted，通常 PP助手、iTools 下载的 App 是经过砸壳的，同时 AppStore App 不需要砸壳</li>\n<li>头文件获取：AppStore class-dump，系统库的头文件的获取：dyld_cache class-dump</li>\n<li>定位关键函数：Reveal、Cycript、lldb</li>\n<li>tweak 的注入</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-3\">砸壳</h3>\n<p>我们的 App 上传到 AppStore 后，苹果会对 App 进行加密，要想去分析可执行文件，就必须要进行脱壳解密的操作，dumpdecrypted 是一款出色的脱壳工具，它的原理是将 App 运行起来，App 启动时，系统会对 Mach-O 文件进行加载，并完成对应的解密操作，dumpdecrypted 就可以在此时将解密后的 Mach-O dump 出来，从而达到解密的效果。</p>\n<p>如果为了省事可以直接从 PP 助手、iTools 上下载对应的 App，一般情况下是已经经过砸壳的。同时，对于 AppStore 这样的系统程序有些特殊，他们 并不需要进行砸壳，可以直接拿来进行分析。</p>\n<h3 class=\"heading\" data-id=\"heading-4\">获取头文件</h3>\n<p>拿到一个砸壳后的可执行文件后，就可以使用 class-dump 来获取可执行文件的所有头文件，class-dump 会对 Mach-O 的格式进行分析，并将信息提取出来形成我们想要的头文件。</p>\n<p>AppStore 的可执行文件也略有特殊，class dump之后会发现 AppStore 中包含的代码极少。App Store 的很多关键代码逻辑都不在 AppStore 这个可执行文件当中，而是在系统的动态库中，我们需要分析动态库的头文件信息进而定位到关键函数。可以获取对应系统dyld_cache 中的动态库，然后 dump 出头文件。AppStore UI 有关的逻辑都在 StoreKitUI 动态库中，这个动态库是分析的重点。</p>\n<h3 class=\"heading\" data-id=\"heading-5\">Reveal</h3>\n<p>Reveal 是一款 UI 调试工具，官方的定义是：See your iOS application's view hierarchy at runtime with advanced 2D and 3D visualisations，当然对于逆向安全人员，查看自己 App 的布局是完全不够的，我们可以在 Cydia 中下载 Reveal Loader，在同一网段下，通过 Mac 的 Reveal 和 iOS 上的 Reveal Loader 就可以查看任意 App 的 UI 布局。</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/27/1639fa1362c53bec?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1240\" data-height=\"718\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1240&quot; height=&quot;718&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>但是，有时候我们不仅想要去看这个 UI 布局，还想要去动态调试这个布局，去看它的 Controller 是谁，去挖掘界面下的真正的代码逻辑。这个就涉及到 Cycript 这个工具。</p>\n<h3 class=\"heading\" data-id=\"heading-6\">Cycript</h3>\n<p>Cycript 是由 Cydia 创始人 Saurik 推出的一款脚本语言，它混合了Objective-C 与 JavaScript 两种语法，很容易上手，我们可以通过 Cycript 来进行动态调试，比如查看函数运行的效果，寻找 View 的 Controller 等。</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/27/1639fa13619e8758?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1240\" data-height=\"710\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1240&quot; height=&quot;710&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>就拿上面 Reveal 详情页为例， Reveal 可以看到获取按钮是 SKUIOfferView，列表页是一个 SKUICollectionView ，那么就通过 Cycript 来看看控制这个 SKUICollectionView 的 Controller 是谁。首先通过 OpenSSH 来连接 iPhone，通过 cycript -p AppStore 来对 AppStore 进行注入调试，UIApp.keyWindow.recursiveDescription().toString() 来打印视图层级。（注：此截图和后面的地址对不上，因为不是同一次打印，大家了解下大概意思就成）</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/27/1639fa136399fedb?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1240\" data-height=\"697\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1240&quot; height=&quot;697&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>可以发现 SKUICollectionView，并且它的内存地址是 0x13fa00e00，可以通过 cycript 脚本来找到它的 Controller 是哪一个，有多种方案，比如通过它的 delegate 来找，或者通过 nextResponder 来找都可以。</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">\ncy<span class=\"hljs-comment\"># [#0x13fa00e00 delegate]</span>\n<span class=\"hljs-comment\">#\"&lt;SKUIStorePageSectionsViewController: 0x140167e00&gt;\"</span>\n\ncy<span class=\"hljs-comment\"># [#0x13fa00e00 nextResponder]</span>\n<span class=\"hljs-comment\">#\"&lt;UIView: 0x140f5f540; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x140f771c0&gt;&gt;\"</span>\ncy<span class=\"hljs-comment\"># [#0x140f5f540 nextResponder]</span>\n<span class=\"hljs-comment\">#\"&lt;SKUIStorePageSectionsViewController: 0x140167e00&gt;\"</span>\n</code></pre><p>同时也可以借助一些私有 API 来实现快速查找 ViewController，使用<code>[[[UIWindow keyWindow] rootViewController] _printHierarchy].toString()</code>，可以发现打印结果中同样可以找到 SKUIStorePageSectionsViewController</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">cy<span class=\"hljs-comment\"># [[[UIWindow keyWindow] rootViewController] _printHierarchy].toString()</span>\n`&lt;SKUITabBarController 0x157815400&gt;, state: appeared, view: &lt;UILayoutContainerView 0x156db38e0&gt;\n   | &lt;UINavigationController 0x15784d200&gt;, state: disappeared, view: &lt;UILayoutContainerView 0x156e6b240&gt; not <span class=\"hljs-keyword\">in</span> the window\n   |    | &lt;SKUIDocumentContainerViewController 0x1578d3c00&gt;, state: disappeared, view: &lt;UIView 0x1580e1aa0&gt; not <span class=\"hljs-keyword\">in</span> the window\n   |    |    | &lt;SKUIStackDocumentViewController 0x15812b740&gt;, state: disappeared, view: &lt;UIView 0x1580dc870&gt; not <span class=\"hljs-keyword\">in</span> the window\n   |    |    |    | &lt;SKUIStorePageSectionsViewController 0x1578ec000&gt;, state: disappeared, view: &lt;UIView 0x1580f1a30&gt; not <span class=\"hljs-keyword\">in</span> the window\n   |    |    |    |    | &lt;SKUIAccountButtonsViewController 0x158654180&gt;, state: disappeared, view: &lt;SKUIAccountButtonsView 0x158654f60&gt; not <span class=\"hljs-keyword\">in</span> the window\n   | &lt;UINavigationController 0x157849c00&gt;, state: disappeared, view: &lt;UILayoutContainerView 0x156ec4df0&gt; not <span class=\"hljs-keyword\">in</span> the window\n   | &lt;UINavigationController 0x157803600&gt;, state: disappeared, view: &lt;UILayoutContainerView 0x156e80de0&gt; not <span class=\"hljs-keyword\">in</span> the window\n   | &lt;UINavigationController 0x15703ea00&gt;, state: appeared, view: &lt;UILayoutContainerView 0x156f114a0&gt;\n   |    | &lt;SKUIDocumentContainerViewController 0x157ab2a00&gt;, state: disappeared, view: &lt;UIView 0x158a25930&gt; not <span class=\"hljs-keyword\">in</span> the window\n   |    |    | &lt;SKUIStackDocumentViewController 0x158a50690&gt;, state: disappeared, view: &lt;UIView 0x158a2b360&gt; not <span class=\"hljs-keyword\">in</span> the window\n   |    |    |    | &lt;SKUIStorePageSectionsViewController 0x1578e6000&gt;, state: disappeared, view: &lt;UIView 0x158a2d4b0&gt; not <span class=\"hljs-keyword\">in</span> the window\n   |    | &lt;SKUIDocumentContainerViewController 0x157b5fa00&gt;, state: appeared, view: &lt;UIView 0x158cf70e0&gt;\n   |    |    | &lt;SKUIStackDocumentViewController 0x158cf6690&gt;, state: appeared, view: &lt;UIView 0x158cf72b0&gt;\n   |    |    |    | &lt;SKUIStorePageSectionsViewController 0x157b4ae00&gt;, state: appeared, view: &lt;UIView 0x158cfb1e0&gt;\n   | &lt;UINavigationController 0x157028000&gt;, state: disappeared, view: &lt;UILayoutContainerView 0x156ef1300&gt; not <span class=\"hljs-keyword\">in</span> the window\n   |    | &lt;ASUpdatesViewController 0x156f169e0&gt;, state: disappeared, view: &lt;UIView 0x156dbd590&gt; not <span class=\"hljs-keyword\">in</span> the window`\n\n</code></pre><p>从上面的分析可以知道，SKUICollectionView 的控制器是 SKUIStorePageSectionsViewController，「获取」按钮的类是 SKUIOfferView，下一步是分析头文件，看看有没有可以比较明显的方法可以为我们所用。下载是最关键的一步，那么首先来看看 SKUIOfferView 类的情况，它的头文件大致如此。</p>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-comment\">#import &lt;StoreKitUI/SKUIItemOfferButtonDelegate-Protocol.h&gt;</span>\n<span class=\"hljs-comment\">#import &lt;StoreKitUI/SKUIViewElementView-Protocol.h&gt;</span>\n\n@class NSMapTable, NSMutableArray, NSString;\n@protocol SKUIOfferViewDelegate;\n\n@interface SKUIOfferView : SKUIViewReuseView &lt;SKUIItemOfferButtonDelegate, SKUIViewElementView&gt; {\n    unsigned long long _alignment;\n    NSMapTable *_buttonElements;\n    NSMapTable *_buyButtonDescriptorToButton;\n    struct UIEdgeInsets _contentInset;\n}\n- (void)_buttonAction:(id)arg1;\n\n- (void)itemOfferButtonWillAnimateTransition:(id)arg1;\n- (void)itemOfferButtonDidAnimateTransition:(id)arg1;\n- (struct CGSize)sizeThatFits:(struct CGSize)arg1;\n</code></pre><p>可以从头文件中看到一个 _buttonAction 方法，感觉上是 「获取」按钮点击后的响应方法，对于这种猜测，可以使用 Cycript 来进行调试，测试一下这个函数执行的效果到底如何\n在终端执行 <code>[#0x156c69cc0 _buttonAction:#0x156cb4d20]</code> 后查看效果如下，App 已经开始进行下载了，说明这个方法的效果我们猜对了，在调试过程中，可以多多使用 Cycript 提高效率。</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/27/1639fa13634a9af0?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1240\" data-height=\"955\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1240&quot; height=&quot;955&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-7\">lldb</h3>\n<p>上面我们使用 Cycript 测试了 _buttonAction 的效果，但是这个方法有一个参数，我们要搞清楚它正确的参数类型，传入正确的值。这时候可以借助 LLDB ，来帮助我们找到这个参数的正确类型。 可以使用 <code>b function</code> 来针对 _buttonAction 方法打断点，然后打印它的参数。</p>\n<p>传统的做法是使用LLDB 和 IDA 等工具找到 ASLR 和 基地址等信息，然后计算出符号的地址，这样做起来比较繁琐，还是可以继续使用一些私有方法快速定位  _buttonAction 的符号地址来进行断点。</p>\n<p>我们想要断点的方法是  _buttonAction，它所在的类是 SKUIOfferView，那么可以使用 LLDB 输入 <code>po [SKUIOfferView _shortMethodDescription]</code> 来看下效果：（更多强大的黑科技私有函数可以参考这里：http://iosre.com/t/powerful-private-methods-for-debugging-in-cycript-lldb/3414）</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">(lldb) po [SKUIOfferView _shortMethodDescription]\n&lt;SKUIOfferView: 0x1a096ddd8&gt;:\n<span class=\"hljs-keyword\">in</span> SKUIOfferView:\n\tClass Methods:\n\t\t+ (void) requestLayoutForViewElement:(id)arg1 width:(double)arg2 context:(id)arg3; (0x194719470)\n\t\t+ (CGSize) sizeThatFitsWidth:(double)arg1 viewElement:(id)arg2 context:(id)arg3; (0x1947197a8)\n\tProperties:\n\t\t@property (weak, nonatomic) &lt;SKUIOfferViewDelegate&gt;* delegate;  (@synthesize delegate = _delegate;)\n\t\t@property (nonatomic) long metadataPosition;  (@synthesize metadataPosition = _metadataPosition;)\n\t\t@property (<span class=\"hljs-built_in\">readonly</span>, nonatomic, getter=isShowingConfirmation) BOOL showingConfirmation;  (@synthesize showingConfirmation = _isShowingConfirmation;)\n\tInstance Methods:\n\t\t- (BOOL) <span class=\"hljs-built_in\">set</span>Image:(id)arg1 <span class=\"hljs-keyword\">for</span>ArtworkRequest:(id)arg2 context:(id)arg3; (0x19471a8c8)\n\t\t- (BOOL) updateWithItemState:(id)arg1 context:(id)arg2 animated:(BOOL)arg3; (0x19471a8d0)\n\t\t- (void) _buttonAction:(id)arg1; (0x19471bb5c)\n\t\t- (BOOL) _shouldHideNoticesWithBuyButtonDescriptor:(id)arg1 context:(id)arg2; (0x19471c368)\n\t\t- (void) _positionNoticeForItemOfferButton:(id)arg1; (0x19471c234)\n(SKUIViewReuseView ...)\n\n</code></pre><p>可以看到 <code>- (void) _buttonAction:(id)arg1; (0x19471bb5c)</code>，那么直接使用 <code>b 0x19471bb5c</code>为 _buttonAction 加断点即可。断点到以后，再打印它的参数，对于 Objective-C 来说消息有两个隐含参数，也就是 self 和 _cmd，那么我们想要的参数就在第三个位置，可以通过 <code>po $x2</code> 来查看它的具体信息（ARM64 下函数的参数是存放在 X0 到 X7 这 8 个寄存器里面的，如果超过8个参数,就会入栈）。</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">\nProcess 7839 stopped\n* thread <span class=\"hljs-comment\">#1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1 2.1 3.1</span>\n    frame <span class=\"hljs-comment\">#0: 0x000000019471bb5c StoreKitUI`-[SKUIOfferView _buttonAction:]</span>\nStoreKitUI`-[SKUIOfferView _buttonAction:]:\n-&gt;  0x19471bb5c &lt;+0&gt;:  stp    x24, x23, [sp, <span class=\"hljs-comment\">#-0x40]!</span>\n    0x19471bb60 &lt;+4&gt;:  stp    x22, x21, [sp, <span class=\"hljs-comment\">#0x10]</span>\n    0x19471bb64 &lt;+8&gt;:  stp    x20, x19, [sp, <span class=\"hljs-comment\">#0x20]</span>\n    0x19471bb68 &lt;+12&gt;: stp    x29, x30, [sp, <span class=\"hljs-comment\">#0x30]</span>\nTarget 0: (AppStore) stopped.\n(lldb) po <span class=\"hljs-variable\">$x0</span>\n&lt;SKUIOfferView: 0x1596aae00; frame = (279 74; 26 26); layer = &lt;CALayer: 0x1596676b0&gt;&gt;\n\n(lldb) po <span class=\"hljs-variable\">$x2</span>\n&lt;SKUIItemOfferButton: 0x1596ab260; baseClass = UIControl; frame = (0 0; 26 26); clipsToBounds = YES; alpha = 0.2; tintColor = UIDeviceRGBColorSpace 0.0862745 0.0156863 0.0156863 1; animations = { opacity=&lt;CABasicAnimation: 0x1592e7b20&gt;; }; layer = &lt;CALayer: 0x15967d9c0&gt;&gt;\n</code></pre><p>由上可知，参数类型是 SKUIItemOfferButton，也就是 SKUIOfferView 的 subView，其实点击的是 SKUIItemOfferButton，只是 SKUIItemOfferButton 将处理往上抛而已。</p>\n<h3 class=\"heading\" data-id=\"heading-8\">Tweak 注入</h3>\n<p>Cydia 创始人 Saurik 同时为我们提供了一个 Cydia Substrate 这么一个工具，官方的定义是：The powerful code modification platform behind Cydia。我们可以基于 Cydia Substrate 来开发具有各种功能的代码注入程序。</p>\n<p>Cydia Substrate 由 MobileHooker、MobileLoader、Safe mode 三个模块组成。MobileHooker 主要用来替换函数的实现，可以想象成 Runtime 的 Method Swizzle。MobileLoader 是用来加载第三方 dylib 的，我们写的破解程序会在目标程序启动时注入到目标程序。Safe mode 就是安全模式，我们写 tweak 的时候可能会造成 Crash，比如万一造成 SpringBoard 无限 Crash 手机岂不是就没法用了，所以提供了这么一个安全模式。</p>\n<p>MobileHooker 提供了一些函数来让我们完成 Hook 的工作，但是我们不直接使用 它们，我们使用基于他们封装的 Logos 工具，Logos 的语法很简单直观，易于上手。比如 %hook 可以指定要 Hook 的类、%orig 可以执行被钩住的函数的原始实现、%new 给一个现成的 class 添加新函数（效果与 class_addMethod 类似）。</p>\n<h3 class=\"heading\" data-id=\"heading-9\">Tweak AppStore</h3>\n<p>那我们来使用  Logos 实现下载的功能，当进入 SKUIStorePageSectionsViewController 页面后，找到下载按钮，然后点击下载，当下载按钮的文字由「获取」变为「打开」，代表下载已完成，然后继续执行后续操作。</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">%hook SKUIStorePageSectionsViewController\n- (void)viewDidAppear:(BOOL)animated {\t\n    %<span class=\"hljs-built_in\">log</span>;\n\t%orig;\n     \n    // 遍历所有子 View，找到 offerButton 、offerView\n\t[self findAllSubviews:self.view];\n\n\t<span class=\"hljs-keyword\">if</span> (offerButton &amp;&amp; offerView) {\n        // 执行下载操作\n\t    [offerView _buttonAction:offerButton];\n        // 每秒去 check 一下，是否下载完成\n\t    downloadTimer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];\n\t}\t\t\n}\n%new\n-(void)timerAction {\n\t<span class=\"hljs-keyword\">if</span> ([offerButton.title isEqualToString:@<span class=\"hljs-string\">\"打开\"</span>]) {\n        // 发送下载完成的通知\n\t\t[[NSNotificationCenter defaultCenter] postNotificationName:@<span class=\"hljs-string\">\"textChangedAction\"</span> object:nil];\n\n\t\tdownloadTimer = nil;\n\t}\n}\n%new\n-(void)findAllSubviews:(UIView *)view\n {\n    <span class=\"hljs-keyword\">for</span> (UIView *subView <span class=\"hljs-keyword\">in</span> view.subviews) {\n        <span class=\"hljs-keyword\">if</span> (subView.subviews.count) {\n            [self findAllSubviews:subView];\n        }\n        \n        <span class=\"hljs-keyword\">if</span> ([subView isKindOfClass:NSClassFromString(@<span class=\"hljs-string\">\"SKUIOfferView\"</span>)]) {\n\t\t\tofferView = (SKUIOfferView*)subView;\n\t\t}\n\t\t<span class=\"hljs-keyword\">if</span> ([subView isKindOfClass:NSClassFromString(@<span class=\"hljs-string\">\"SKUIItemOfferButton\"</span>)]) {\n\t\t\tofferButton = (SKUIItemOfferButton*)subView;\n\t\t}\n    }\n}\n%end\n</code></pre><p>其他的操作，与上述其实很类似，比如搜索、跳转都是利用静态或者动态分析找到关键函数，通过 tweak 来实现想要的效果即可。其中还有一个较难的点，就是弹窗提示我们登陆怎么办？如何实现自动登录功能？</p>\n<h3 class=\"heading\" data-id=\"heading-10\">Tweak SpringBoard</h3>\n<p>首先，想到的就是在 AppStore App 中注入代码，Hook UIAlertAction 和 UIAlertController 的代码，会发现并没有产生作用。AppStore 中的弹窗不是它来控制的，而是另外一个进程 SpringBoard，所以要想实现 Hook AppStore 的弹窗，必须对 SpringBoard 进行代码注入。</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/27/1639fa13637a9864?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1240\" data-height=\"862\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1240&quot; height=&quot;862&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>我们正常如果要实现一个这种弹窗，代码一般是这么写</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">UIAlertController *actionSheet = [UIAlertController alertControllerWithTitle:@<span class=\"hljs-string\">\"标题\"</span> message:@<span class=\"hljs-string\">\"注释信息\"</span> preferredStyle:UIAlertControllerStyleActionSheet];  \n\nUIAlertAction *action1 = [UIAlertAction actionWithTitle:@<span class=\"hljs-string\">\"标题1\"</span> style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {  \n    NSLog(@<span class=\"hljs-string\">\"点击了按钮 1\"</span>);  \n}];  \nUIAlertAction *action2 = [UIAlertAction actionWithTitle:@<span class=\"hljs-string\">\"取消\"</span> style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {  \n    NSLog(@<span class=\"hljs-string\">\"点击了按钮 2\"</span>);  \n}];  \n  \n[actionSheet addAction:action1];  \n[actionSheet addAction:action2];  \n\n[self presentViewController:actionSheet animated:YES completion:nil];  \n</code></pre><p>基于上面的代码分析可得，我们要想实现自动登录，就要实现自动点击「使用现有的 Apple ID」执行系统的原 action 操作，然后在账号和密码的 TextField 中填入账号密码，点击「好」执行系统的原始 action 操作。其实可以发现，要执行的 action 其实是在初始化 UIAlertAction 过程中，handler block 中加入的逻辑。那么我们就可以 Hook  <code>actionWithTitle:style:handler:</code> 然后将 handler 保存下来，当填写好账号密码后，主动触发 handler 即可。</p>\n<p>上面那种方法也可以奏效，但是需要自己额外处理下 alertView 的出现和消失， 为了简单可以直接尝试第二种方法，在分析 UIKit 框架中 UIAlertController 类的头文件时发现 <code>_dismissWithAction:</code>这个方法，然后我就试了一下发现可以完成 dismiss 和 执行 handler 两项功能，所以我就直接使用了这个 API 来模拟点击。核心代码如下：</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">typedef void(^CDUnknownBlockType)(UIAlertAction *action);\nCDUnknownBlockType <span class=\"hljs-built_in\">test</span>Block;\nstatic UIAlertAction *keepAction;\nstatic int atimers;\n\n%hook UIAlertController\n- (void)viewDidAppear:(BOOL)animated {\n\t%<span class=\"hljs-built_in\">log</span>;\n\t%orig;\n\n\t<span class=\"hljs-keyword\">if</span> ([keepAction.title isEqualToString:@<span class=\"hljs-string\">\"使用现有的 Apple ID\"</span>]) {\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\n\t\t\t((void ( *)(id, SEL, UIAlertAction*))objc_msgSend)(self, NSSelectorFromString(@<span class=\"hljs-string\">\"_dismissWithAction:\"</span>),keepAction);\n    \t});\n    } \n\n\t<span class=\"hljs-keyword\">if</span> ([keepAction.title isEqualToString:@<span class=\"hljs-string\">\"好\"</span>]) {\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n            \n        \t<span class=\"hljs-keyword\">if</span> (self.textFields.count &gt; 1) {\n\t\t\t\tself.textFields.firstObject.text = @<span class=\"hljs-string\">\"joyme0104@163.com\"</span>;\n\t\t\t\tself.textFields.lastObject.text = @<span class=\"hljs-string\">\"Joyme0304&amp;&amp;&amp;\"</span>;\n\n\t\t\t\t((void ( *)(id, SEL, UIAlertAction*))objc_msgSend)(self, NSSelectorFromString(@<span class=\"hljs-string\">\"_dismissWithAction:\"</span>),keepAction);\n\n\t\t\t}\n        });\n    }\n}\n%end\n\n%hook UIAlertAction\n+ (id)_actionWithTitle:(id)arg1 descriptiveText:(id)arg2 image:(id)arg3 style:(long long)arg4 handler:(CDUnknownBlockType)arg5 shouldDismissHandler:(CDUnknownBlockType)arg6 {\n\tid obj = %orig;\n\tUIAlertAction *action = (UIAlertAction *)obj;\n    <span class=\"hljs-keyword\">if</span> ([action.title isEqualToString:@<span class=\"hljs-string\">\"使用现有的 Apple ID\"</span>]) {\n        <span class=\"hljs-built_in\">test</span>Block = arg6;\n\t\tkeepAction = obj;\n    } \n\t<span class=\"hljs-keyword\">if</span> ([action.title isEqualToString:@<span class=\"hljs-string\">\"好\"</span>]) {\n\t\t<span class=\"hljs-built_in\">test</span>Block = arg6;\n\t\tkeepAction = obj;\n\t}\n\t<span class=\"hljs-built_in\">return</span> obj;\n}\n%end\n</code></pre><p>从代码可以看出我们在 Hook UIAlertAction 的 _actionWithTitle 方法时，并没有 Hook <code>actionWithTitle:style:handler:</code> ，因为我测试的时候发现在我操作过程中并没有触发，怀疑是苹果没有使用这个 API，直接使用了下面这个方法。</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">+ (id)_actionWithTitle:(id)arg1 descriptiveText:(id)arg2 image:(id)arg3 style:(long long)arg4 handler:(CDUnknownBlockType)arg5 shouldDismissHandler:(CDUnknownBlockType)arg6 {\n}\n</code></pre><h2 class=\"heading\" data-id=\"heading-11\">Thinking About The Future</h2>\n<p>适当增加对 App 安全的精力的投入，像现在业界的很多 App 都处于被破解的状态，网上随处可见各种 App 的破解版，比如爱奇艺会员破解、钉钉远程打卡等。从客户端角度出发，需要增加代码混淆、反调试等手段保证运行环境的安全，同时与后端人员合作增加保证网络数据链路、反作弊的手段。</p>\n<h2 class=\"heading\" data-id=\"heading-12\">Summary</h2>\n<p>本文首先介绍了常见的攻击手段：</p>\n<ol>\n<li>通过静态分析和动态分析掌握 App 的内部逻辑，通过代码注入实现我们想要的功能，比如自动下载、自动跳转等功能</li>\n<li>通过分析 App 的网络请求，破解网络协议，模拟真实的网络请求来达到某种目的，比如批量下载，批量评论等功能。</li>\n</ol>\n<p>然后介绍了 ASO 的影响因素都有哪些，以及黑帽子和白帽子都是怎么进行 ASO 优化的。最后重点写了如何一步步通过代码注入，实现 AppStore App 的自动登录。</p>\n"
    },
    {
      "articleID": 22,
      "type": 4,
      "title": "Flutter KO React Native? 让时间去决定吧...",
      "publishTime": "2018年 05月 24日",
      "praise": "30",
      "tag": ["Flutter","React Native"],
      "author": "知识小集",
      "authorImg": "https://user-gold-cdn.xitu.io/2018/3/3/161eb9e583f786b4?imageView2/1/w/100/h/100/q/85/interlace/1",
      "comment": [
        {
          "username": "E=mc^2酱",
          "commentTime": "2天前",
          "commentText": "1. Flutter目前没有热更框架 2. flutter国内被墙！",
          "admire":"0",
          "commentImg":"https://wx.qlogo.cn/mmopen/vi_32/PaAib7ArJj8OBEg7jHVVokMYibDwEVYn7XroCTb5liaqOicibcCAy59jfc37jPcvLuJlq26mTHN1Gszog8YnRlSIictg/0"
        }
      ],
      "preview":"最近 「 Flutter 自习室 」经常有同学问，Flutter 和 React Native 有什么区别？由于 Flutter 是 Google 对标 React Native 的跨平台移动开发方案，所以这两者之间还是有许多可比性的。当然由于两者推出的时间相隔大概 2 年，而 Flutter 还处于起步阶段，所以当前阶段，这两者的比较是不对等的。也许再过两年，Flutter 成长起来后，两者的比较会更可靠一些。不过既然有疑问，所以这里就整理一下目前网上的一些资料，来做个简单的对比。",
      "content":"<p>最近 <code>「 Flutter 自习室 」</code>经常有同学问，<code>Flutter</code> 和 <code>React Native</code> 有什么区别？由于 Flutter 是 Google 对标 React Native 的跨平台移动开发方案，所以这两者之间还是有许多可比性的。</p>\n<p>当然由于两者推出的时间相隔大概 2 年，而 Flutter 还处于起步阶段，所以当前阶段，这两者的比较是不对等的。也许再过两年，Flutter 成长起来后，两者的比较会更可靠一些。不过既然有疑问，所以这里就整理一下目前网上的一些资料，来做个简单的对比。</p>\n<p>我们先来看个对照表：</p>\n<p></p><figure><img class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/5/24/1638f910af896bdf?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"900\" data-height=\"728\" src=\"https://user-gold-cdn.xitu.io/2018/5/24/1638f910af896bdf?imageView2/0/w/1280/h/960/ignore-error/1\"><figcaption></figcaption></figure><p></p>\n<p>下面我们就根据这张对照表，展开简要说明一下。</p>\n<h2 class=\"heading\" data-id=\"heading-0\">UI 构建方式</h2>\n<p>这两个平台在用户界面的构建方式差异上很大。</p>\n<p>React Native 最终是以原生的 iOS 或 Android 组件来渲染界面。在某些情况下，我们可以使用 <code>Native Module</code> 的方式来自定义组件，在 JS 端通过 <code>NativeModules</code> 来引用 Native 组件。</p>\n<p>而 Flutter 是有自己专属的一套 <code>Widget</code>，并通过自己的渲染引擎来绘制界面。Android 上使用 <code>Material Designed Widget</code>，iOS 上使用 <code>Cupertino Widget</code>。</p>\n<p>Flutter 构建 UI 的方式还是让人心情复杂。其专有的 Widget 在自定义 UI 中增色不少，Flutter 团队也承诺将加强与 Native 组件的互操作性。不过，由于 Flutter 还在起步阶段，其 <code>Cupertino</code> 库还缺少很多基本组件，而 React Native 在这一方面已经比较成熟了。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">Native 视觉和感受</h2>\n<p>React Native 和 Flutter 都承诺提供原生组件的感观。在这一方面，对 React Native 的正面评价已经很多了，对 Flutter 的评价却很少，而且有些还是负面评价。</p>\n<p>当然，Flutter 开发社区还需要积累更多的最佳实践，以提供更好的跨平台交互体验。不过，现在 React Native 社区已经比较成熟了，而 Flutter 又是对标 React Native 的，所以这方面可以参考 React Native 社区的发展。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">性能</h2>\n<p>从技术上来讲，Flutter 的运行速度应该更快，因为 Flutter 没有与本地组件交互的 <code>Javascript Bridge</code>。那是否就意味着 Flutter 在性能上就一定优于 React Native 呢？事实经验是：No。</p>\n<p>目前 React Native 构建的 App 在性能上的表现已经很不错了，甚至可以和原生 App 媲美。在大部分情况下，React Native 都能平滑地运行，在很多具有挑战性的任务中（<code>60 fps</code>）都有很好的解决方案。</p>\n<p>当然，Flutter 将 <code>60 fps</code> 作为目标的。</p>\n<h2 class=\"heading\" data-id=\"heading-3\">成熟度</h2>\n<p>React Native 是在 2015 年发布的，经过 2 年多的发展，已经比较成熟，虽然至今没有发布 1.0 版本。React Native 社区发展也很成熟，并且为 React Native 社区贡献了大量的开源代码。</p>\n<p>而 Flutter 是在 2017 年 5 月发布的，而 Beta 版本也是今年 3 月份才发布，社区也刚刚发展，特别是在国内。所以，Flutter 还需要时间，才能成为跨平台移动开发广泛采用的解决方案。</p>\n<h2 class=\"heading\" data-id=\"heading-4\">JAVASCRIPT VS DART</h2>\n<p>毫无疑问，在编程语言之间进行选择是一个巨大的决定因素。从某种意义上讲，<code>Dart</code> 和 <code>Javascript</code> 不是一个量级的。</p>\n<p>截至 2018 年，JavaScript 是 GitHub 上最流行的语言。从前端到后端，从 PC 到移动端，Javascript 都表现出了其强大的实力。而 Dart，笔者在之前从未听说过这门语言（孤陋寡闻了），在 Google 之外，Dart 并不流行。</p>\n<p>有个笑谈，为什么 Flutter 会选择 Dart？因为 Dart 团队就在 Flutter 团队隔壁，有问题随时可以问。当然笑谈归笑谈，Dart 语言自身的特性，类型安全、富有表现力，对标 Javascript，对移动开发人员，特别是有 React Native 和 Javascript 基础的开发人员来说，还是很友好的，学习曲线相对平缓。</p>\n<p>至于 Flutter 为什么选择 Dart，可以参考 <strong>为什么Flutter会选择 Dart ？</strong> <code>http://www.infoq.com/cn/articles/why-flutter-uses-dart</code></p>\n<h2 class=\"heading\" data-id=\"heading-5\">行业使用</h2>\n<p>React Native 是由 Facebook 推出的，最初在 Facebook 自己的项目中使用，而后不少主流的应用程序也采用了 React Native 的方案，如下面几个：</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/24/1638f914f75cd112?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"900\" data-height=\"180\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;900&quot; height=&quot;180&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>国内很多公司也对 React Native 做了很多研究，并有相应的产出，如一些基于 React Native 发展出来的跨三端的技术。</p>\n<p>而 Flutter 在这方面却乏善可陈，拿得出手的并不多。有一款应用 Hamilton，是目前应用 Flutter 最成熟的应用，另外开源中国也基于 Flutter 开发了一个客户端，并且在 Github 上开源 <code>https://github.com/yubo725/FlutterOSC</code>，大家可以有兴趣研究一下。</p>\n<h2 class=\"heading\" data-id=\"heading-6\">生产效率</h2>\n<p>React Native 受欢迎的很大一个原因是它的生产效率。而 Flutter 的目标之一也是高效的开发。除了跨平台的优势之外，还有一些其它生产效率方面的特性，我们也可以来比较一下。</p>\n<h3 class=\"heading\" data-id=\"heading-7\">Hot Reload</h3>\n<p>如果你是 Native 开发，一定对 <code>Android</code> 和 <code>Xcode</code> 的编译效率无力吐槽。可能改几行代码，开始编译，然后就可以去接咖啡了，回来也许刚刚好，程序跑起来了，甚至更糟。跑起来后，还得从头走一下流程，进到你要调试的页面。</p>\n<p>而 Flutter 和 React Native 的一大优势正是在这一方面：它们都支持 Hot Reload。修改代码后，只需要重新加载资源，而且可以保持在同一页面上，甚至于保留原来的表单输入。</p>\n<h3 class=\"heading\" data-id=\"heading-8\">配置和设置</h3>\n<p>相较于 React Native，Flutter 的设置和配置更加简单。<code>Flutter doctor</code> 可以自动检查系统问题，整个设置过程更直接。</p>\n<h3 class=\"heading\" data-id=\"heading-9\">工具</h3>\n<p>React Native 的各种 IDE 工具已经很齐全，所以 Flutter 在这方面没有什么优势。不过，Flutter 的表现也不错，支持 <code>IntelliJ</code>、<code>Android Studio</code>、<code>Visual Studio Code</code>，且各种相关的插件也在不断发展中。</p>\n<h3 class=\"heading\" data-id=\"heading-10\">硬件相关的 API</h3>\n<p>React Native 现在已经提供了各种硬件相关的 API，如 Wi-Fi、GEO、相机、传感器等，这些第三方的解决方案都相对成熟。不过，React Native 的问题在于图形绘制这一块。如果我们想自定义一些图形绘制相关的组件，就必然会涉及到 Native 代码。</p>\n<p>而 Flutter 是自有的渲染引擎，可以更灵活的来定制各种图形组件。同时，除了蓝牙和 NFC 外，其它硬件相关的 API 也正在不断发展。从这方面讲，Flutter 后面或许会胜出。</p>\n<h3 class=\"heading\" data-id=\"heading-11\">生命周期管理和优化</h3>\n<p>生命周期的管理对于前端各个领域来说，也是一个大话题。在这一方面，React Native 做得更好，而且现在针对 React Native 的状态管理框架也很多。而 Flutter 目前只能使用 Widget 来继承实现无状态和有状态组件，同时没有工具来明确地保存应用程序的状态。不过，相信后面各种框架也会不断出现。</p>\n<h3 class=\"heading\" data-id=\"heading-12\">代码结构</h3>\n<p>在这不得不吐槽一下，Flutter 中通过代码来构建一个页面的结构和布局样式确实有点混乱。相比而言，React Native 中通过 JSX ，以声明式的结构来描述一个页面结构，同时分离页面结构和样式的方式，开发起来更加舒服一些。</p>\n<h2 class=\"heading\" data-id=\"heading-13\">社区</h2>\n<p>作为一个新生儿，Flutter 在开发者社区中得到广泛的关注。截止目前，Flutter 在 Github 上的 star 数已到 <code>24k</code> ，stackoverflow 上相关的问题数也很多。当然，比起 React Native 来，Flutter 还是显得比较稚嫩。</p>\n<p>不过，每一种新技术，都有一个成长过程，而且都会有自己的支持者和反对者。Flutter 要走的路，React Native 也走过。所以，给 Flutter 一些时间。</p>\n<h2 class=\"heading\" data-id=\"heading-14\">文档与路线图</h2>\n<p>Flutter 和 React Native 都没有明确的路线图。不过，React Native 有一个比较活跃的 <strong>Github 博客</strong> <code>http://facebook.github.io/react-native/blog/</code>，每月会有一些更新。而 Flutter 也维护了一个相关里程碑 <code>https://github.com/flutter/flutter/milestones</code>的页面，在这里可以了解 Flutter 的进展信息。</p>\n<p>文档方面，Flutter 还是更有优势的，文档很清楚。而 React Native 的文档感觉只是写给 React 开发者的，不懂的去看 React 的文档，特别是对很多组件的描述，都不是很细致，希望这个后面能改善吧。</p>\n<h2 class=\"heading\" data-id=\"heading-15\">小结</h2>\n<p>如果真要做比较，现阶段 React Native 无疑赢家。不过我觉得这种比较更像是大人和小孩之间的比较，毕竟 Flutter 处于起步阶段。所以，还是把裁判权留给时间吧。</p>\n<p>当然，Flutter 还有些潜在的问题，是需要我们关注的：</p>\n<ul>\n<li>Dart 相对 Javascript 来说，接受度还是太低；</li>\n<li>业界对 Flutter 的态度；</li>\n<li>如果你了解过 Google Graveyard，在采用 Google 的新技术之前，就可能会再三考虑。</li>\n</ul>\n<p>最后，「 小集 」团队在 Github 上开了一个 repo，来收集国内关于 Flutter 的开发资源 <code>https://github.com/awesome-tips/flutter-resources</code>，欢迎大家一起来维护。同时我们开通了微信群 「 知识小集 · Flutter 自习室 」，有兴趣的小伙伴可以先加好友 <code>coldlight_hh</code> (南峰子) 或者 <code>bob5201215</code> (zb)，然后邀请您入群。加好友时请注明 <strong>\"Flutter 自习室 入群\"</strong>。</p>\n<h2 class=\"heading\" data-id=\"heading-16\">参考</h2>\n<ol>\n<li><strong>Flutter vs React Native comparison for Q1 2018</strong> <code>https://agileengine.com/flutter-vs-react-native-comparison/</code></li>\n<li><strong>Flutter vs React Native – What Would You Prefer for Your Next Hybrid Mobile App?</strong> <code>https://dev.to/vipinjain/flutter-vs-react-native--what-would-you-prefer-for-your-next-hybrid-mobile-app-2i3m</code></li>\n<li><strong>Flutter vs React Native - What You Need To Know</strong> <code>https://medium.com/@openGeeksLab/flutter-vs-react-native-what-you-need-to-know-89451da3c90b</code></li>\n</ol>\n<blockquote>\n<p>知识小集是一个团队公众号，主要定位在移动开发领域，分享移动开发技术，包括 iOS、Android、小程序、移动前端、React Native、weex 等。每周都会有 <strong>原创</strong> 文章分享，我们的文章都会在公众号首发。欢迎关注查看更多内容。</p>\n</blockquote>\n<center><img title=\"知识小集\" width=\"200\" class=\"lazyload inited loaded\" src=\"https://user-gold-cdn.xitu.io/2018/5/8/1633d1278e68b61a?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"430\" data-height=\"430\" src=\"https://user-gold-cdn.xitu.io/2018/5/8/1633d1278e68b61a?imageView2/0/w/1280/h/960/ignore-error/1\"></center>"
    },
    {
      "articleID": 23,
      "type": 4,
      "title": "看完 `Masonry` 源码后的几点思考？",
      "publishTime": "2018年 05月 25日",
      "praise": "15",
      "tag": ["iOS","源码"],
      "author": "Swants",
      "authorImg": "https://avatars2.githubusercontent.com/u/15909932?v=3",
      "comment": [
        {
          "username": "CWenJim",
          "commentTime": "2天前",
          "commentText": "建议楼主也去看一下SDAutoLayout，那个也很6",
          "admire":"0",
          "commentImg":"https://tva2.sinaimg.cn/crop.0.0.180.180.180/663aa05ajw1e8qgp5bmzyj2050050aa8.jpg"
        }
      ],
      "preview":"最近花了两周的时间读了 Masonry 源码，被它优雅的语法深深打动。它把 Apple 原生 AutoLayout 冗长,繁琐的约束语法真是封装得简洁优雅到了极致。每一次看，都能看到不一样的东西，在这里也强烈推荐各位小伙伴阅读它的源码。我把我在看源码期间想到的问题，收获，总结到了下面几个问题中，您看能答出来多少呢？欢迎在下方评论。",
      "content":"<p>最近花了两周的时间读了 <code>Masonry</code> 源码，被它优雅的语法深深打动。它把 <code>Apple</code> 原生 <code>AutoLayout</code> 冗长,繁琐的约束语法真是封装得简洁优雅到了极致。每一次看，都能看到不一样的东西，在这里也强烈推荐各位小伙伴阅读它的源码。我把我在看源码期间想到的问题，收获，总结到了下面几个问题中，您看能答出来多少呢？欢迎在下方评论。</p>\n<ol>\n<li><code>Masonry</code> 都做了些什么？</li>\n<li></li>\n</ol>\n<pre><code class=\"hljs bash\" lang=\"bash\">[self.view addSubview:btn];\n[btn makeConstrants:^(MASLayoutConstraint *make){\nmake.left.equalTo(self.view).offset(12);\n}];\n</code></pre><p>上述代码会发生循环引用吗，为什么？</p>\n<ol start=\"3\">\n<li>\n<p><code>MAS_SHORTHAND</code>、<code>MAS_SHORTHAND_GLOBALS</code> 宏是做什么用的？它的效果是怎么实现的呢？</p>\n</li>\n<li>\n<p><code>Masonry</code> 的 <code>makeConstraints:</code> 、<code>updateConstraints:</code>、 <code>remakeConstraints:</code> 有什么区别，分别适合那些场景？</p>\n</li>\n<li>\n<p>描述下代码 <code>make.left.right.top.equalTo(self.view).offset(0);</code> 都做了些什么？</p>\n</li>\n<li>\n<p><code>Masonry</code> 是如何做到链式优雅调用的？</p>\n</li>\n</ol>\n<blockquote>\n<p>下面几个问题可能比较细节，希望不要介意。</p>\n</blockquote>\n<ol start=\"7\">\n<li>\n<p><code>MASViewConstraint</code> 为什么要弱引用一个 MASLayoutConstraint 的实例对象，它又用这个对象做了什么？</p>\n</li>\n<li>\n<p><code>MASConstraintMaker</code> 持有一个 <code>constraints</code> 数组， 而 <code>MASViewConstrint</code> 类也有一个用来记录约束的数组，这两个数组都是用来记录生成的约束，那么这两个数组有什么区别吗？各自的作用又是什么？</p>\n</li>\n<li></li>\n</ol>\n<pre><code class=\"hljs bash\" lang=\"bash\">- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *))block {\n    self.translatesAutoresizingMaskIntoConstraints = NO;\n    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];\n    constraintMaker.updateExisting = YES;\n    block(constraintMaker);\n    <span class=\"hljs-built_in\">return</span> [constraintMaker install];\n}\n</code></pre><p>上述源码中，<code>MASConstraintMaker</code> 的初始化方法 <code>initWithView:</code> 为<code>MASConstraintMaker</code>初始化了一个 <code>view</code> 属性 ，<code>MASConstraintMaker</code> 持有这个 <code>view</code> 做什么？</p>\n<ol start=\"10\">\n<li><code>MASConstraintMaker</code> 都在什么时候会初始化 <code>MASViewAttribute</code>对象？</li>\n</ol>\n<p>尽管笔者水平有限，但对这些问题的拙劣见解还是会在下篇文章中放出，在这希望可以抛砖引玉，期待各位大牛共同探讨 <code>Masonry</code> 优雅的精髓。</p>\n"
    },
    {
      "articleID": 24,
      "type": 4,
      "title": "iOS一个灵活可扩展的开源Log库",
      "publishTime": "2018年 05月 22日",
      "praise": "73",
      "tag": ["iOS","Debug"],
      "author": "RyanLY",
      "authorImg": "https://tva2.sinaimg.cn/crop.0.0.180.180.180/663aa05ajw1e8qgp5bmzyj2050050aa8.jpg",
      "comment": [
        {
          "username": "尚大大o_O",
          "commentTime": "10小时前",
          "commentText": "线上log有统一的后台调试界面吗？",
          "admire":"0",
          "commentImg":"https://lc-mhke0kuv.cn-n1.lcfile.com/BS6LemEOh6kgJTguVAdIOJB"
        }
      ],
      "preview":"目前大部分iOS的小型开发团队都不是很重视log，导致很多线上发生的或者用户反馈的bug难以排查。对于App来说一个好的日志系统可以帮助我们用最小的代价来排查一些疑难bug，我们唯一要做的就是在合适的位置打印日志，记录App的运行状况。这样做不仅仅可以让我们在debug时查看App运行日志，还可以允许App通过某些方式将日志文件回传供开发人员分析问题",
      "content":"<blockquote>\n<p>目前大部分iOS的小型开发团队都不是很重视log，导致很多线上发生的或者用户反馈的bug难以排查。对于App来说一个好的日志系统可以帮助我们用最小的代价来排查一些疑难bug，我们唯一要做的就是在合适的位置打印日志，记录App的运行状况。这样做不仅仅可以让我们在debug时查看App运行日志，还可以允许App通过某些方式将日志文件回传供开发人员分析问题。</p>\n</blockquote>\n<h2 class=\"heading\" data-id=\"heading-0\">关于NSLog</h2>\n<p>苹果提供的<code>NSLog</code>是大多数开发者常用的日志工具，但是<code>NSLog</code>还是无法满足我们对于Log的其他需求，如日志分级、日志持久化等。另外我们知道<code>NSLog</code>其实并不是<code>printf</code>的封装而是ASL的高级封装，苹果在文档上也说明了<code>NSLog</code>的设计目的是<code>Logs an error message</code>，因此我们如果在开发中大量使用<code>NSLog</code>，App的性能会变得非常糟糕。关于NSLog的性能问题可以参看这篇sunnyxx的文章<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fblog.sunnyxx.com%2F2014%2F04%2F22%2Fobjc_dig_nslog%2F\" rel=\"nofollow noopener noreferrer\">【NSLog效率低下的原因及尝试lldb断点打印Log】</a></p>\n<h2 class=\"heading\" data-id=\"heading-1\">需求</h2>\n<ul>\n<li>独立开关。比如我们希望在debug版本中打开控制台log和文件log，在release版本中只打开文件log的功能。</li>\n<li>可扩展性和灵活性。我们知道在iOS10以后苹果建议使用<code>os.log</code>来取代<code>NSLog</code>，我们希望有一个具有很强扩展性的log库，使我们可以很轻易地将log底层实现替换为<code>os.log</code>而不必改变原有的log代码。</li>\n<li>自定义格式。可以自定义log输出的标准格式，同时也不希望原有的log调用接口有大量改动。</li>\n<li>日志查看工具。我们知道<code>NSLog</code>在Mac提供了<code>Console.app</code>这样的调试工具，使得我们即使不在xcode的debug模式下也可以随时查看App的日志。甚至，我们希望使用windows PC也可以在非debug模式下查看log。</li>\n<li>分级与过滤。log应该被划分为不同等级，同时在debug和release下我们可以设置不同级别的过滤器，低级别的log可以被过滤掉。举个🌰：假如有info、default、warning、error四个等级log，我们可能会希望在debug下输出所有等级的log，而在release下只输出warning和error等级的log。</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-2\">轮子</h2>\n<h3 class=\"heading\" data-id=\"heading-3\">先上轮子<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FRyanLeeLY%2FCoolog\" rel=\"nofollow noopener noreferrer\">Coolog[Github]</a></h3>\n<p>Coolog设计之初就是为了解决上面所提到的这些需求。Coolog具有高度的可扩展性和灵活性，同时提供了一个浏览器的调试工具。目前，Coolog还有很多需要完善的地方，包括浏览器调试工具目前也只是一个demo，欢迎大家成为Coolog的Contributor。</p>\n<h2 class=\"heading\" data-id=\"heading-4\">架构</h2>\n<p>为了保证可扩展性和灵活性，Coolog包含了了生成器（COLLogger）、格式化协议与格式化器（COLFormatable和COLLogFormatter）、驱动器（COLLoggerDriver）、引擎（COLEngine）、管理者（COLLogManager），他们之间的关系可见下图：\n</p><figure><img alt=\"Architecture\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/22/16387f7dfcdaafe8?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"700\" data-height=\"525\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;700&quot; height=&quot;525&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>下面我们来一一说明它们各自的作用。</p>\n<h3 class=\"heading\" data-id=\"heading-5\">生成器 COLLogger</h3>\n<p>顾名思义，生成器负责最终log的生成，<code>COLLogger</code>是一个协议。Coolog提供了三种生成器，分别是<code>COLNSLogger</code>、<code>COLConsoleLogger</code>、<code>COLFileLogger</code>，这三个类都实现了<code>COLLogger</code>协议中<code>- (void)log:(NSString *)logString;</code>这个方法。在该方法中我们最终定义了这个类型的log最后的生成方法，log引擎会通过驱动器调用到该方法输出log。\n除了这三种生成器，也可以自己实现<code>COLLogger</code>协议来自定义一个生成器。</p>\n<h3 class=\"heading\" data-id=\"heading-6\">格式化协议 COLFormatable</h3>\n<p>这个协议只有一个方法，这个方法定义了log的输出格式。</p>\n<pre><code class=\"hljs objective-c\" lang=\"objective-c\">- (NSString *)completeLogWithType:(COLLogType)type\n                              tag:(NSString *)tag\n                          message:(NSString *)message\n                             date:(NSDate *)date;\n</code></pre><h3 class=\"heading\" data-id=\"heading-7\">格式化器 COLLogFormatter</h3>\n<p>格式化器就是实现了<code>COLFormatable</code>格式化协议的类，默认我们提供了与上述三种生成器对应的三种格式化器<code>NSLogFormatter</code>、<code>ConsoleFormatter</code>、<code>FileFormatter</code>，他们分别对应原生NSLog、控制台与浏览器工具log和文件log。这个三个类我们使用了类族提供工厂方法完成初始化，在自定义格式化器时并不需要继承<code>COLLogFormatter</code>，是需要实现<code>COLFormatable</code>协议即可。</p>\n<h3 class=\"heading\" data-id=\"heading-8\">驱动器 COLLoggerDriver</h3>\n<p>驱动器是一个容器，生成器与格式化器将作为依赖注入到驱动器中，同时驱动器负责log的级别的配置，实现log分级过滤。log类型分为5中：<code>Error&gt;Warning&gt;Info&gt;Default&gt;Debug</code>，过滤的级别分为7级：<code>LevelOff&gt;LevelError&gt;LevelWarning&gt;LevelInfo&gt;LevelDefault&gt;LevelDebug&gt;LevelAll</code>，低级别的log可能会被过滤，比如如果当前过滤级别为<code>LevelInfo</code>，那么将只有<code>Error</code>、<code>Warning</code>、<code>Info</code>这三种类型的log会被输出。最终驱动器将交由log引擎统一管理。</p>\n<h4 class=\"heading\" data-id=\"heading-9\">引擎 COLEngine</h4>\n<p>引擎负责管理所有的驱动器，由它负责启动log，引擎可以随时移除或者加入单个log驱动器，实现不同log的独立开关。</p>\n<h2 class=\"heading\" data-id=\"heading-10\">使用</h2>\n<h3 class=\"heading\" data-id=\"heading-11\">初始化</h3>\n<pre><code class=\"hljs objective-c\" lang=\"objective-c\">[[COLLogManager sharedInstance] setup];\n    \n[[COLLogManager sharedInstance] enableFileLog];  // 打开文件log\n[[COLLogManager sharedInstance] enableConsoleLog];  // 打开控制台log\n//    [[COLLogManager sharedInstance] enableNSLog];  // 一般控制台log和NSLog不同时打开\n    \n// Debug下打开所有级别log，Release下打开Info级别以上的log\n#ifdef DEBUG\n    [COLLogManager sharedInstance].level = COLLogLevelAll;\n#else\n    [COLLogManager sharedInstance].level = COLLogLevelInfo;\n#endif\n</code></pre><h3 class=\"heading\" data-id=\"heading-12\">Log</h3>\n<pre><code class=\"hljs objective-c\" lang=\"objective-c\">CLogError(@\"tag\", @\"%@\", @\"log content\");\nCLogE(@\"%@\", @\"log content\");\n\nCLogWarning(@\"tag\", @\"%@\", @\"log content\");\nCLogW(@\"%@\", @\"log content\");\n\t\nCLogInfo(@\"tag\", @\"%@\", @\"log content\");\nCLogI(@\"%@\", @\"log content\");\n\t\nCLogDefault(@\"tag\", @\"%@\", @\"log content\");\nCLog(@\"%@\", @\"log content\");\n\t\nCLogDebug(@\"tag\", @\"%@\", @\"log content\");\nCLogD(@\"%@\", @\"log content\");\n</code></pre><h3 class=\"heading\" data-id=\"heading-13\">浏览器调试</h3>\n<p>首先打开浏览器调试功能。</p>\n<pre><code class=\"hljs objective-c\" lang=\"objective-c\">[[COLLogManager sharedInstance] enableRemoteConsole];\n</code></pre><p>将电脑和手机连到同一个wifi下，打开浏览器访问<a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fcoolog.oss-cn-hangzhou.aliyuncs.com%2Findex.html%3Fhost%3Dws%3A%2F%2F%255BYourPhoneIPAddr%255D%3A9001%2Fcoolog\" rel=\"nofollow noopener noreferrer\">(http://coolog.oss-cn-hangzhou.aliyuncs.com/index.html?host=ws://[YourPhoneIPAddr]:9001/coolog</a>，注意地址后面的参数[YourPhoneIPAddr]替换为手机的IP地址。</p>\n<p>目前效果是下面这样。\n</p><figure><img alt=\"BrowserTool\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/22/16387f7e00e2acea?imageslim\" data-width=\"1114\" data-height=\"708\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1114&quot; height=&quot;708&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-14\">加入自定义的log方法</h3>\n<ul>\n<li>第一步：实现一个生成器</li>\n</ul>\n<pre><code class=\"hljs objective-c\" lang=\"objective-c\">#import \"COLLogger.h\"\n@interface MyLogger : NSObject &lt;COLLogger&gt;\n\n@end\n</code></pre><pre><code class=\"hljs objective-c\" lang=\"objective-c\">#import \"MyLogger.h\"\n#import &lt;os/log.h&gt;\n\n@implementation MyLogger\n@synthesize formatterClass = _formatterClass;\n\n+ (instancetype)logger {\n    return [[MyLogger alloc] init];\n}\n\n// This is your own log method. It will be called by log engine. \n- (void)log:(NSString *)logString {\n\t//For example, here below uses os_log as its implementation.\n    os_log(OS_LOG_DEFAULT, \"%{public}s\", [logString UTF8String]);\n}\n@end\n</code></pre><ul>\n<li>第二步：实现一个格式化器</li>\n</ul>\n<pre><code class=\"hljs objective-c\" lang=\"objective-c\">#import \"COLLogFormatter.h\"\n\n@interface MyLogFormatter : NSObject &lt;COLFormatable&gt;\n\n@end\n</code></pre><pre><code class=\"hljs objective-c\" lang=\"objective-c\">#import \"MyLogFormatter.h\"\n\n@implementation MyLogFormatter\n// The log's format depends on this method.\n- (NSString *)completeLogWithType:(COLLogType)type tag:(NSString *)tag message:(NSString *)message date:(NSDate *)date {\n    return [NSString stringWithFormat:@\"tag=[%@], type=[%zd], message=[%@], date=[%@]\", tag, type, message, date];\n}\n@end\n</code></pre><ul>\n<li>第三步：实例化驱动器并加入到log引擎</li>\n</ul>\n<pre><code class=\"hljs objective-c\" lang=\"objective-c\">COLLoggerDriver *myDriver = [[COLLoggerDriver alloc] initWithLogger:[MyLogger logger]\n                                                              formatter:[[MyLogFormatter alloc] init]\n                                                                  level:COLLogLevelInfo];\n[[COLLogManager sharedInstance].logEngine addDriver:myDriver];\n</code></pre><h2 class=\"heading\" data-id=\"heading-15\">后记</h2>\n<p>Log是我们开发过程中容易忽略的一步，但它又是十分重要的一项工作，我们要学会如何在合适的位置记录合适log，这对于我们复现和排查问题真的有很大的帮助。</p>\n<p>目前Coolog还是很有很多不完善的地方，包括浏览器调试工具也是一个初级的demo状态，后续工作会放在log的性能优化和调试工具的搜索和过滤功能，包括调试工具的UI也会进一步优化。</p>\n"
    },
    {
      "articleID": 25,
      "type": 4,
      "title": "Swift 进阶 | 看得见的算法",
      "publishTime": "2018年 05月 19日",
      "praise": "109",
      "tag": ["GitHub","iOS"],
      "author": "Castie1",
      "authorImg": "https://user-gold-cdn.xitu.io/2018/5/19/16377be9508f7e2b?imageView2/1/w/100/h/100/q/85/interlace/1",
      "comment": [
        {
          "username": "海神Lewis",
          "commentTime": "3天前",
          "commentText": "你对自己要求很高，建议你往iOS逆向攻防安全方面发展",
          "admire":"0",
          "commentImg":"https://user-gold-cdn.xitu.io/2018/4/12/162ba8e4fd44ad8e?imageView2/1/w/100/h/100/q/85/interlace/1"
        }
      ],
      "preview":"前段日子写了篇面经, 得到了掘金的征文活动的三等奖还是非常开心, 但是被寒神说面试不过就泄题, 影响不好, 我想想也是, 马上就把大厂的名字给抹掉了, 但被转载的就无能为力了, 看到下面好多喷的, 真是背后一凉, 一首凉凉送给自己, 造成的伤害无法挽回, 再此郑重道歉, 再也不写面经了. 希望以后还能获得大厂面试的机会!",
      "content":"<blockquote>\n<p>GitHub Repo：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FcoderZsq%2FcoderZsq.target.swift\" rel=\"nofollow noopener noreferrer\">coderZsq.target.swift</a>\n<br>Follow: <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FcoderZsq\" rel=\"nofollow noopener noreferrer\">coderZsq · GitHub</a>\n<br>Resume: <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fcoderzsq.github.io%2FcoderZsq.webpack.js%2F%23%2F\" rel=\"nofollow noopener noreferrer\">coderzsq.github.io/coderZsq.we…</a></p>\n</blockquote>\n<h4 class=\"heading\" data-id=\"heading-0\">日常扯淡</h4>\n<p>前段日子写了篇面经, 得到了<code>掘金</code>的<code>征文活动</code>的<code>三等奖</code>还是非常开心, 但是被寒神说<code>面试不过就泄题</code>, 影响不好, 我想想也是, 马上就把大厂的名字给<code>抹掉</code>了, 但被转载的就<code>无能为力</code>了, 看到下面好多喷的, 真是背后一凉, 一首凉凉送给自己, 造成的伤害无法挽回, 再此郑重道歉, 再也不写面经了. 希望以后还能获得<code>大厂面试</code>的机会!</p>\n<p>被<code>大厂</code>刷掉后, 我心情难以平复, 因为其实我是做了<code>充足的准备</code>来的, 但是还是<code>实力上有差</code>距, 诶... 还是想想改如何<code>提升</code>自己的水平吧!</p>\n<p>其实对于自己, 我其实并不知道<code>iOS</code>该如何进行学习, 也不知道<code>技术这条路</code>我半道转的是不是正确, 更不知道在当今环境下我这种水平的<code>iOS</code>开发者是否还有存在的必要.</p>\n<p>说起转行做<code>iOS</code>到现在, 从<code>Objective-C</code>基础语法学起, 认为<code>OC</code>是最好的语言, 学会做几个简单的<code>UITableView</code>页面, 能播放<code>音频视频</code>, 觉得自己真是<code>转了个高大上的职业</code>, 现在想想, 真是<code>肤浅</code>的让人忍不住发笑.</p>\n<p>我把做<code>iOS</code>这段学习经历分为五个阶段:</p>\n<p>第一个阶段: 是刚刚转行进入互联网企业, 那时候觉得学好<code>CALayer</code>掌握了一些酷炫的动画(<code>贝塞尔曲线</code>), 感觉就已经比大多数人都强了, 那时候还把常用的工具类封装起来, 就觉得, 嗯, 自己还不错.</p>\n<p>第二个阶段: 就是瞎学些有的没的, 如<code>Swift</code>, <code>JavaScript</code>, <code>Java</code>什么的, 觉得自己全栈了, 什么都会了, 很牛逼, 你看还自己能够写一个前端简历, 还做过公司的前端项目, 服务器开发也会了, 自信心爆棚啊, 觉得自己真是无所不能.</p>\n<p>第三个阶段: 写了一个<code>架构生成器</code>, 觉得自己<code>所向披靡</code>了, 公司项目都在用我写的架构, <code>用着我制定的规则</code>, 尼玛不就是一个简单的<code>字符串替换</code>, 嘚瑟个啥... 而且对于架构的理解<code>肤浅至极</code>...</p>\n<p>第四个阶段: 察觉到了自己的薄弱, 开始学习<code>iOS</code>的底层原理, 学习了<code>C\\C++</code>的语法, 学习了<code>Linux</code>基础, 学习了<code>8086, ARM64</code>汇编, 了解了一些<code>自认为</code>还是比较深的知识点. 觉得自己前途还是有希望的.</p>\n<p>第五个阶段: 也就是被刷掉之后的现在, 其实我现在也很迷茫, 也不知道现在学的东西到底有没有用, 也不知道大厂到底要什么样的人才(只知道牛逼就行...), 但我也通过把知识点进行分类进行进阶吧. 把最近的学习总结分享出来和大家一起讨论, 像我这种水平的玩家到底该怎么玩耍.</p>\n<h4 class=\"heading\" data-id=\"heading-1\">学习计划</h4>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/19/163742e8bc7c7170?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1240\" data-height=\"788\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1240&quot; height=&quot;788&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>我把最近学习的方面全部都整理在<code>StudyNote</code>这个里面了, 可以看得出, 这个阶段, 我明显的就是像要学习加强<code>算法与数据结构</code>方面的, 可能是因为被大厂刷的有阴影了吧.</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/19/163742e8bad1ef25?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1240\" data-height=\"788\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1240&quot; height=&quot;788&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>除了<code>数据结构与算法</code>, 最近刚看完的<code>CS193p</code>的教程, 白胡子老头的这个视频的<code>质量很高</code>, 发现了很多我平时忽略的东西, 而且觉得很多我以为的写法从<code>本质上</code>都是有问题的.</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/19/163742e8bab610c4?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1240\" data-height=\"788\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1240&quot; height=&quot;788&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>还有就是<code>objc.io</code>的这几本书了, 质量挺高的, <code>函数式Swift</code>的学习对我很有帮助. 感觉就像是打开了新世界.</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/19/163742e8bd78ea39?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1240\" data-height=\"788\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1240&quot; height=&quot;788&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>还有就是排在后面的学习计划: <code>python</code>, <code>数据分析</code>, <code>机器学习</code>, <code>深度学习</code>.可以看得出, 其实这些都学完, 其实也不知道能够干什么, 无所事事诶... 但至少这些都是我能够找到的比较<code>高质量</code>的资料了, 如果有其他高质量的资料, 欢迎进行资料共享hhhh~</p>\n<h4 class=\"heading\" data-id=\"heading-2\">算法学习</h4>\n<p>果然, 算法是挡在(<code>复制黏贴</code>)程序员和(<code>正常</code>)程序员之前的一条很难跨越的鸿沟, 我这里不是说, 你会写<code>快速排序</code>,<code>二分查找</code>, <code>深度广度优先</code>这类大家都能够背出来的东西就叫做掌握算法了, 我在<code>Coursera</code>上看了<code>加州大学</code>的算法课, 才知道该如何设计算法, 但由于是英语的, 而且没有代码, 纯数学的看不太懂, 所以转向了<code>北京大学</code>的算法课, 以下就是我最新学到的算法和你分享.</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/19/163742e8bd64240e?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1240\" data-height=\"788\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1240&quot; height=&quot;788&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>这个只是<code>算法基础</code>的第二节课, 你能想象这是算法基础么? 光是这个题目, 我就看了老半天, 大意是点击一个灯, 上下左右的灯会<code>自动点亮(熄灭)</code>, 当随机给出点亮熄灭数的时候, 需要算出点击哪几个灯可以将所有的灯点亮或熄灭.</p>\n<p>这种算法题, 真是<code>闻所未闻见所未见吧</code>, 而且这是算法基础的开头的课... 我在想难道那些大厂的人做这种题<code>跟玩的一样</code>么, 想起了<code>面试官的微笑</code>, 那可真是有力量的微笑呢.</p>\n<pre><code class=\"hljs c\" lang=\"c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span>\n\n<span class=\"hljs-keyword\">int</span> puzzle[<span class=\"hljs-number\">6</span>][<span class=\"hljs-number\">8</span>], press[<span class=\"hljs-number\">6</span>][<span class=\"hljs-number\">8</span>];\n<span class=\"hljs-comment\">/*\n推测验证过程：\n根据第一行猜测\n*/</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">guess</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">int</span> c, r;\n    <span class=\"hljs-comment\">//根据press第1行和puzzle数组，计算press其他行的值</span>\n    <span class=\"hljs-keyword\">for</span>(r=<span class=\"hljs-number\">1</span>; r&lt;<span class=\"hljs-number\">5</span>; r++) {\n        <span class=\"hljs-keyword\">for</span>(c=<span class=\"hljs-number\">1</span>; c&lt;<span class=\"hljs-number\">7</span>; c++) {\n            press[r+<span class=\"hljs-number\">1</span>][c]=(puzzle[r][c]+press[r][c]+press[r<span class=\"hljs-number\">-1</span>][c]+press[r][c<span class=\"hljs-number\">-1</span>]+press[r][c+<span class=\"hljs-number\">1</span>])%<span class=\"hljs-number\">2</span>;\n        }\n    }\n    <span class=\"hljs-comment\">//判断所计算的press数组能否熄灭第5行的所有灯</span>\n    <span class=\"hljs-keyword\">for</span>(c=<span class=\"hljs-number\">1</span>; c&lt;<span class=\"hljs-number\">7</span>; c++) {\n        <span class=\"hljs-keyword\">if</span> ((press[<span class=\"hljs-number\">5</span>][c<span class=\"hljs-number\">-1</span>]+press[<span class=\"hljs-number\">5</span>][c]+press[<span class=\"hljs-number\">5</span>][c+<span class=\"hljs-number\">1</span>]+press[<span class=\"hljs-number\">4</span>][c])%<span class=\"hljs-number\">2</span> != puzzle[<span class=\"hljs-number\">5</span>][c]) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n}\n\n<span class=\"hljs-comment\">/*\n枚举过程：\n对press第1行的元素press[1][1]~press[1][6]的各种取值进行枚举\n*/</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">enumerate</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">int</span> c;\n    <span class=\"hljs-keyword\">bool</span> success; <span class=\"hljs-comment\">//这个变量时当时定义了没排上用场吧，NodYoung注</span>\n    <span class=\"hljs-keyword\">for</span>(c=<span class=\"hljs-number\">1</span>; c&lt;<span class=\"hljs-number\">7</span>; c++) {\n        press[<span class=\"hljs-number\">1</span>][c]=<span class=\"hljs-number\">0</span>;\n    }\n    <span class=\"hljs-keyword\">while</span>(guess()==<span class=\"hljs-literal\">false</span>) {\n        press[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>]++;\n        c=<span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">while</span>(press[<span class=\"hljs-number\">1</span>][c]&gt;<span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">//累加进位</span>\n            press[<span class=\"hljs-number\">1</span>][c]=<span class=\"hljs-number\">0</span>;\n            c++;\n            press[<span class=\"hljs-number\">1</span>][c]++;\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> ;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">int</span> cases, i, r, c;\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d\"</span>, &amp;cases);\n    <span class=\"hljs-keyword\">for</span>(r=<span class=\"hljs-number\">0</span>; r&lt;<span class=\"hljs-number\">6</span>; r++) {\n        press[r][<span class=\"hljs-number\">0</span>]=press[r][<span class=\"hljs-number\">7</span>]=<span class=\"hljs-number\">0</span>;\n    }\n    <span class=\"hljs-keyword\">for</span>(c=<span class=\"hljs-number\">0</span>; c&lt;<span class=\"hljs-number\">7</span>; c++) {\n        press[<span class=\"hljs-number\">0</span>][c]=<span class=\"hljs-number\">0</span>;\n    }\n    <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>; i&lt;cases; i++) {\n        <span class=\"hljs-keyword\">for</span>(r=<span class=\"hljs-number\">1</span>; r&lt;<span class=\"hljs-number\">6</span>; r++) {\n            <span class=\"hljs-keyword\">for</span>(c=<span class=\"hljs-number\">1</span>; c&lt;<span class=\"hljs-number\">7</span>; c++) {\n                <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%d\"</span>, &amp;puzzle[r][c]); <span class=\"hljs-comment\">//读入输入数据</span>\n            }\n        }\n        enumerate();\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"PUZZLE#%d\\n\"</span>, i+<span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-keyword\">for</span> (r=<span class=\"hljs-number\">1</span>; r&lt;<span class=\"hljs-number\">6</span>; r++) {\n            <span class=\"hljs-keyword\">for</span> (c=<span class=\"hljs-number\">1</span>; c&lt;<span class=\"hljs-number\">7</span>; c++) {\n                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d \"</span>, press[r][c]);\n            }\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"\\n\"</span>);\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre><p>这是<code>北大老师</code>视频里给出的算法的答案, 讲的很好, 但是说真的听的是一知半解, 原因在于不知道为什么, 这些网课都不是<code>在线编译</code>的, 而是直接对着<code>代码分析</code>, 上面的代码摘抄自-&gt; 可以搜索<code>熄灯问题</code>.</p>\n<pre><code class=\"hljs swift\" lang=\"swift\"><span class=\"hljs-keyword\">var</span> puzzle = [[<span class=\"hljs-type\">Int</span>]](repeating: [<span class=\"hljs-type\">Int</span>](repeating: <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">count</span>: <span class=\"hljs-number\">8</span>), <span class=\"hljs-built_in\">count</span>: <span class=\"hljs-number\">6</span>)\n<span class=\"hljs-keyword\">var</span> press = [[<span class=\"hljs-type\">Int</span>]](repeating: [<span class=\"hljs-type\">Int</span>](repeating: <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">count</span>: <span class=\"hljs-number\">8</span>), <span class=\"hljs-built_in\">count</span>: <span class=\"hljs-number\">6</span>)\n</code></pre><pre><code class=\"hljs swift\" lang=\"swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">guess</span><span class=\"hljs-params\">()</span></span> -&gt; <span class=\"hljs-type\">Bool</span> {\n    <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">5</span> {\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">7</span> {\n            press[r + <span class=\"hljs-number\">1</span>][<span class=\"hljs-built_in\">c</span>] = (puzzle[r][<span class=\"hljs-built_in\">c</span>] + press[r][<span class=\"hljs-built_in\">c</span>] + press[r - <span class=\"hljs-number\">1</span>][<span class=\"hljs-built_in\">c</span>] + press[r][<span class=\"hljs-built_in\">c</span> - <span class=\"hljs-number\">1</span>] + press[r][<span class=\"hljs-built_in\">c</span> + <span class=\"hljs-number\">1</span>]) % <span class=\"hljs-number\">2</span>\n        }\n    }\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">7</span> {\n        <span class=\"hljs-keyword\">if</span> (press[<span class=\"hljs-number\">5</span>][<span class=\"hljs-built_in\">c</span> - <span class=\"hljs-number\">1</span>] + press[<span class=\"hljs-number\">5</span>][<span class=\"hljs-built_in\">c</span>] + press[<span class=\"hljs-number\">5</span>][<span class=\"hljs-built_in\">c</span> + <span class=\"hljs-number\">1</span>] + press[<span class=\"hljs-number\">4</span>][<span class=\"hljs-built_in\">c</span>]) % <span class=\"hljs-number\">2</span> != puzzle[<span class=\"hljs-number\">5</span>][<span class=\"hljs-built_in\">c</span>] {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\n</code></pre><pre><code class=\"hljs swift\" lang=\"swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">enumerate</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-built_in\">c</span> = <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-number\">_</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">7</span> {\n        press[<span class=\"hljs-number\">1</span>][<span class=\"hljs-built_in\">c</span>] = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">while</span> (guess() == <span class=\"hljs-literal\">false</span>) {\n            press[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>] += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-built_in\">c</span> = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">while</span> press[<span class=\"hljs-number\">1</span>][<span class=\"hljs-built_in\">c</span>] &gt; <span class=\"hljs-number\">1</span> {\n                press[<span class=\"hljs-number\">1</span>][<span class=\"hljs-built_in\">c</span>] = <span class=\"hljs-number\">0</span>\n                <span class=\"hljs-built_in\">c</span> += <span class=\"hljs-number\">1</span>\n                press[<span class=\"hljs-number\">1</span>][<span class=\"hljs-built_in\">c</span>] += <span class=\"hljs-number\">1</span>\n            }\n        }\n        <span class=\"hljs-built_in\">c</span> += <span class=\"hljs-number\">1</span>\n    }\n}\n</code></pre><pre><code class=\"hljs swift\" lang=\"swift\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Enumerate</span> </span>{\n    \n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n        <span class=\"hljs-keyword\">let</span> cases = <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..&lt;<span class=\"hljs-number\">6</span> {\n            press[r][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>\n            press[r][<span class=\"hljs-number\">7</span>] = <span class=\"hljs-number\">0</span>\n        }\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">7</span> {\n            press[<span class=\"hljs-number\">0</span>][<span class=\"hljs-built_in\">c</span>] = <span class=\"hljs-number\">0</span>\n        }\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..&lt;cases {\n            <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">6</span> {\n                <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">7</span> {\n                    puzzle[r][<span class=\"hljs-built_in\">c</span>] = <span class=\"hljs-number\">2</span>.arc4random\n                }\n            }\n            <span class=\"hljs-built_in\">enumerate</span>()\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"PUZZLE #<span class=\"hljs-subst\">\\(i + <span class=\"hljs-number\">1</span>)</span>\"</span>)\n            <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">6</span> {\n                <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">7</span> {\n                    <span class=\"hljs-built_in\">print</span>(puzzle[r][<span class=\"hljs-built_in\">c</span>], terminator: <span class=\"hljs-string\">\"\"</span>)\n                }\n                <span class=\"hljs-built_in\">print</span>()\n            }\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"== press ==\"</span>)\n            <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">6</span> {\n                <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">7</span> {\n                    <span class=\"hljs-built_in\">print</span>(press[r][<span class=\"hljs-built_in\">c</span>], terminator: <span class=\"hljs-string\">\"\"</span>)\n                }\n                <span class=\"hljs-built_in\">print</span>()\n            }\n            <span class=\"hljs-built_in\">print</span>()\n        }\n    }\n}\n</code></pre><p>以上是我学习的时候转换成<code>swift</code>表达的, 不为什么, 只是用来熟悉<code>Swift</code>语法罢了, 毕竟<code>OC</code>也不知道还能活个几年了.</p>\n<pre><code class=\"hljs swift\" lang=\"swift\"><span class=\"hljs-type\">PUZZLE</span> #<span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">011010</span>\n<span class=\"hljs-number\">001110</span>\n<span class=\"hljs-number\">010011</span>\n<span class=\"hljs-number\">000101</span>\n<span class=\"hljs-number\">100000</span>\n== press ==\n<span class=\"hljs-number\">001001</span>\n<span class=\"hljs-number\">000101</span>\n<span class=\"hljs-number\">001010</span>\n<span class=\"hljs-number\">001101</span>\n<span class=\"hljs-number\">011110</span>\n</code></pre><p>但是光看代码, 很难看懂这个结果到底是正确还是不正确的... 因为跑出来是这样的一个东西, 但是有些地方还是可以讲一下, 比如是<code>外面包了一圈0</code>来避免冗余逻辑判断, 用<code>2进制</code>进位的方法进行运算, 还是有学到一些皮毛的.</p>\n<h4 class=\"heading\" data-id=\"heading-3\">看得见的算法</h4>\n<p>当然, 这种文字上的描述, 很难有深刻的印象的, 所以, 我就在想是否可以把这个熄灯游戏给做出来, 再自己测试一下呢? 想到就干吧!!</p>\n<p>通过<code>CS193p</code>的学习, 对于<code>画UI</code>方面有了全新的认识, 该如何添加约束, <code>MVC</code>到底怎么写, 以至于我以前理解的感觉完全就是错的, 正好趁这个机会来练练手.</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/19/163742e8bd521ea0?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1240\" data-height=\"788\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1240&quot; height=&quot;788&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>我们通过<code>StoryBoard</code>先把<code>View</code>画好, 不得不说<code>UIStackView</code>真是好用到爆!!</p>\n<pre><code class=\"hljs swift\" lang=\"swift\"><span class=\"hljs-keyword\">import</span> Foundation\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Matrix</span> </span>{\n    <span class=\"hljs-keyword\">var</span> rows: <span class=\"hljs-type\">Int</span>\n    <span class=\"hljs-keyword\">var</span> columns: <span class=\"hljs-type\">Int</span>\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">LightSwitch</span> </span>{\n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> puzzle: [[<span class=\"hljs-type\">Int</span>]]\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> matrix: <span class=\"hljs-type\">Matrix</span>\n    <span class=\"hljs-keyword\">var</span> lights = [<span class=\"hljs-type\">Int</span>]()\n    \n    <span class=\"hljs-keyword\">mutating</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">lightUp</span><span class=\"hljs-params\">(index: Array&lt;Any&gt;.Index?)</span></span> {\n        <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">let</span> index = index <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">return</span> }\n        <span class=\"hljs-keyword\">var</span> m = <span class=\"hljs-type\">Matrix</span>(rows: <span class=\"hljs-number\">0</span>, columns: <span class=\"hljs-number\">0</span>)\n        <span class=\"hljs-keyword\">if</span> index &lt;= matrix.rows {\n            m.columns = index + <span class=\"hljs-number\">1</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            m.columns += index % matrix.columns + <span class=\"hljs-number\">1</span>\n        }\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>...index {\n            <span class=\"hljs-keyword\">if</span> i % matrix.columns == <span class=\"hljs-number\">0</span> {\n                m.rows += <span class=\"hljs-number\">1</span>\n            }\n        }\n        puzzle[m.rows][m.columns] = puzzle[m.rows][m.columns] == <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>\n        puzzle[m.rows + <span class=\"hljs-number\">1</span>][m.columns] = puzzle[m.rows + <span class=\"hljs-number\">1</span>][m.columns] == <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>\n        puzzle[m.rows][m.columns + <span class=\"hljs-number\">1</span>] = puzzle[m.rows][m.columns + <span class=\"hljs-number\">1</span>] == <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>\n        puzzle[m.rows - <span class=\"hljs-number\">1</span>][m.columns] = puzzle[m.rows - <span class=\"hljs-number\">1</span>][m.columns] == <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>\n        puzzle[m.rows][m.columns - <span class=\"hljs-number\">1</span>] = puzzle[m.rows][m.columns - <span class=\"hljs-number\">1</span>] == <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>\n        lights.removeAll()\n        <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;matrix.rows + <span class=\"hljs-number\">1</span> {\n            <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;matrix.columns + <span class=\"hljs-number\">1</span> {\n                lights.append(puzzle[r][<span class=\"hljs-built_in\">c</span>])\n            }\n        }\n    }\n    \n    <span class=\"hljs-keyword\">init</span>(matrix: <span class=\"hljs-type\">Matrix</span>) {\n        <span class=\"hljs-keyword\">self</span>.matrix = matrix\n        puzzle = [[<span class=\"hljs-type\">Int</span>]](repeating: [<span class=\"hljs-type\">Int</span>](repeating: <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">count</span>: matrix.columns + <span class=\"hljs-number\">2</span>), <span class=\"hljs-built_in\">count</span>: matrix.rows + <span class=\"hljs-number\">2</span>)\n        <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;matrix.rows + <span class=\"hljs-number\">1</span> {\n            <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;matrix.columns + <span class=\"hljs-number\">1</span> {\n                puzzle[r][<span class=\"hljs-built_in\">c</span>] = <span class=\"hljs-number\">2</span>.arc4random\n                lights.append(puzzle[r][<span class=\"hljs-built_in\">c</span>])\n            }\n        }\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"========\"</span>)\n        <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..&lt;matrix.rows + <span class=\"hljs-number\">2</span> {\n            <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..&lt;matrix.columns + <span class=\"hljs-number\">2</span> {\n                <span class=\"hljs-built_in\">print</span>(puzzle[r][<span class=\"hljs-built_in\">c</span>], terminator: <span class=\"hljs-string\">\"\"</span>)\n            }\n            <span class=\"hljs-built_in\">print</span>()\n        }\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"========\"</span>)\n    }\n}\n</code></pre><p><code>Model</code>代码, 原来<code>MVC</code>的<code>M</code>需要这样写的, 以前都只是认为是简单的<code>数据结构来的</code>真是肤浅, 这种直接业务逻辑写在<code>M</code>里面的的写法真是好用到爆啊!</p>\n<pre><code class=\"hljs swift\" lang=\"swift\"><span class=\"hljs-keyword\">import</span> UIKit\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title\">UIColor</span> </span>{\n    <span class=\"hljs-keyword\">var</span> toImage: <span class=\"hljs-type\">UIImage</span> {\n        <span class=\"hljs-keyword\">let</span> bounds = <span class=\"hljs-type\">CGRect</span>(origin: .zero, size: <span class=\"hljs-type\">CGSize</span>(width: <span class=\"hljs-number\">1.0</span>, height: <span class=\"hljs-number\">1.0</span>))\n        <span class=\"hljs-keyword\">let</span> renderer = <span class=\"hljs-type\">UIGraphicsImageRenderer</span>(bounds: bounds)\n        <span class=\"hljs-keyword\">return</span> renderer.image { context <span class=\"hljs-keyword\">in</span>\n            <span class=\"hljs-keyword\">self</span>.setFill()\n            context.fill(<span class=\"hljs-type\">CGRect</span>(x: <span class=\"hljs-number\">0.0</span>, y: <span class=\"hljs-number\">0.0</span>, width: <span class=\"hljs-number\">1.0</span>, height: <span class=\"hljs-number\">1.0</span>))\n        }\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title\">Int</span> </span>{\n    <span class=\"hljs-keyword\">var</span> arc4random: <span class=\"hljs-type\">Int</span> {\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span> &gt; <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">Int</span>(arc4random_uniform(<span class=\"hljs-type\">UInt32</span>(<span class=\"hljs-keyword\">self</span>)))\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span> &lt; <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-type\">Int</span>(arc4random_uniform(<span class=\"hljs-type\">UInt32</span>(<span class=\"hljs-keyword\">self</span>)))\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n        }\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ViewController</span>: <span class=\"hljs-title\">UIViewController</span> </span>{\n    \n    <span class=\"hljs-meta\">@IBOutlet</span> <span class=\"hljs-keyword\">var</span> lights: [<span class=\"hljs-type\">UIButton</span>]! {\n        <span class=\"hljs-keyword\">didSet</span> {\n            <span class=\"hljs-keyword\">for</span> (index, light) <span class=\"hljs-keyword\">in</span> lights.enumerated() {\n                light.setBackgroundImage(<span class=\"hljs-type\">UIColor</span>.yellow.toImage, <span class=\"hljs-keyword\">for</span>: .normal)\n                light.setBackgroundImage(<span class=\"hljs-type\">UIColor</span>.darkGray.toImage, <span class=\"hljs-keyword\">for</span>: .selected)\n                light.isSelected = switchs.lights[index] == <span class=\"hljs-number\">1</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>\n            }\n        }\n    }\n    \n    <span class=\"hljs-meta\">@IBAction</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">lightUp</span><span class=\"hljs-params\">(<span class=\"hljs-number\">_</span> sender: UIButton)</span></span> {\n        switchs.lightUp(index: lights.index(of: sender))\n        <span class=\"hljs-keyword\">for</span> (index, light) <span class=\"hljs-keyword\">in</span> lights.enumerated() {\n            light.isSelected = switchs.lights[index] == <span class=\"hljs-number\">1</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>\n        }\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-type\">Set</span>(switchs.lights).<span class=\"hljs-built_in\">count</span> == <span class=\"hljs-number\">1</span> {\n            <span class=\"hljs-keyword\">let</span> alert = <span class=\"hljs-type\">UIAlertController</span>(title: <span class=\"hljs-string\">\"Congratulation\"</span>, message: <span class=\"hljs-string\">\"You made all light up successfully\"</span>, preferredStyle: .alert)\n            alert.addAction(<span class=\"hljs-type\">UIAlertAction</span>(\n                title: <span class=\"hljs-string\">\"again\"</span>,\n                style: .<span class=\"hljs-keyword\">default</span>,\n                handler: { [<span class=\"hljs-keyword\">weak</span> <span class=\"hljs-keyword\">self</span>] <span class=\"hljs-number\">_</span> <span class=\"hljs-keyword\">in</span>\n                    <span class=\"hljs-keyword\">self</span>?.restart()\n                }\n            ))\n            present(alert, animated: <span class=\"hljs-literal\">true</span>)\n        }\n    }\n    \n    <span class=\"hljs-meta\">@IBAction</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">restart</span><span class=\"hljs-params\">(<span class=\"hljs-number\">_</span> sender: UIButton? = <span class=\"hljs-literal\">nil</span>)</span></span> {\n        switchs = <span class=\"hljs-type\">LightSwitch</span>(matrix: <span class=\"hljs-type\">Matrix</span>(rows: <span class=\"hljs-number\">5</span>, columns: <span class=\"hljs-number\">6</span>))\n        <span class=\"hljs-keyword\">for</span> (index, light) <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-keyword\">self</span>.lights.enumerated()) {\n            light.isSelected = <span class=\"hljs-keyword\">self</span>.switchs.lights[index] == <span class=\"hljs-number\">1</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>\n        }\n    }\n    \n    <span class=\"hljs-keyword\">var</span> switchs: <span class=\"hljs-type\">LightSwitch</span> = <span class=\"hljs-type\">LightSwitch</span>(matrix: <span class=\"hljs-type\">Matrix</span>(rows: <span class=\"hljs-number\">5</span>, columns: <span class=\"hljs-number\">6</span>))\n}\n</code></pre><p><code>Controller</code>的代码, 这才能够真正理解什么叫做控制器用来协调<code>View</code>和<code>Model</code>的交互, <code>Model</code>和<code>View</code>毫无关联, 这才是<code>iOS</code>的正确写法啊.</p>\n<img style=\"margin: clear: both; display: block; margin:auto; 0;\" width=\"375\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/19/163742e8e6cbc61a?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"745\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;745&quot; height=&quot;1280&quot;&gt;&lt;/svg&gt;\">\n<p>运行了一下, 果然白胡子大叔没有骗我, 跑的<code>6到飞起</code>~</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/19/163742e8e6c66a76?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1240\" data-height=\"788\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1240&quot; height=&quot;788&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>可以看到的是, 终端打印的矩阵和界面上显示的是一一对应的, 从<code>北大老师</code>学到的外面包一圈的方法也是特别好用的.</p>\n<h4 class=\"heading\" data-id=\"heading-4\">算法测试</h4>\n<pre><code class=\"hljs swift\" lang=\"swift\">    <span class=\"hljs-keyword\">init</span>(matrix: <span class=\"hljs-type\">Matrix</span>) {\n        <span class=\"hljs-keyword\">self</span>.matrix = matrix\n        puzzle = [[<span class=\"hljs-type\">Int</span>]](repeating: [<span class=\"hljs-type\">Int</span>](repeating: <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">count</span>: matrix.columns + <span class=\"hljs-number\">2</span>), <span class=\"hljs-built_in\">count</span>: matrix.rows + <span class=\"hljs-number\">2</span>)\n        <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;matrix.rows + <span class=\"hljs-number\">1</span> {\n            <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;matrix.columns + <span class=\"hljs-number\">1</span> {\n<span class=\"hljs-comment\">//                puzzle[r][c] = 2.arc4random</span>\n                puzzle[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>\n                lights.append(puzzle[r][<span class=\"hljs-built_in\">c</span>])\n            }\n        }\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"========\"</span>)\n        <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..&lt;matrix.rows + <span class=\"hljs-number\">2</span> {\n            <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..&lt;matrix.columns + <span class=\"hljs-number\">2</span> {\n                <span class=\"hljs-built_in\">print</span>(puzzle[r][<span class=\"hljs-built_in\">c</span>], terminator: <span class=\"hljs-string\">\"\"</span>)\n            }\n            <span class=\"hljs-built_in\">print</span>()\n        }\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"========\"</span>)\n    }\n</code></pre><img style=\"margin: clear: both; display: block; margin:auto; 0;\" width=\"375\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/19/163742e8e6b647c8?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"745\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;745&quot; height=&quot;1280&quot;&gt;&lt;/svg&gt;\">\n<p>我们将初始状态从随机数改成只暗一个灯, 位置是[1][1]</p>\n<pre><code class=\"hljs swift\" lang=\"swift\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Enumerate</span> </span>{\n    \n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n        <span class=\"hljs-keyword\">let</span> cases = <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..&lt;<span class=\"hljs-number\">6</span> {\n            press[r][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>\n            press[r][<span class=\"hljs-number\">7</span>] = <span class=\"hljs-number\">0</span>\n        }\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">7</span> {\n            press[<span class=\"hljs-number\">0</span>][<span class=\"hljs-built_in\">c</span>] = <span class=\"hljs-number\">0</span>\n        }\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..&lt;cases {\n            <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">6</span> {\n                <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">7</span> {\n<span class=\"hljs-comment\">//                    puzzle[r][c] = 2.arc4random</span>\n                    puzzle[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>\n                }\n            }\n            <span class=\"hljs-built_in\">enumerate</span>()\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"PUZZLE #<span class=\"hljs-subst\">\\(i + <span class=\"hljs-number\">1</span>)</span>\"</span>)\n            <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">6</span> {\n                <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">7</span> {\n                    <span class=\"hljs-built_in\">print</span>(puzzle[r][<span class=\"hljs-built_in\">c</span>], terminator: <span class=\"hljs-string\">\"\"</span>)\n                }\n                <span class=\"hljs-built_in\">print</span>()\n            }\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"== press ==\"</span>)\n            <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">6</span> {\n                <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;<span class=\"hljs-number\">7</span> {\n                    <span class=\"hljs-built_in\">print</span>(press[r][<span class=\"hljs-built_in\">c</span>], terminator: <span class=\"hljs-string\">\"\"</span>)\n                }\n                <span class=\"hljs-built_in\">print</span>()\n            }\n            <span class=\"hljs-built_in\">print</span>()\n        }\n    }\n}\n\n</code></pre><p>我们把<code>北大算法</code>也改成对应的[1][1]</p>\n<pre><code class=\"hljs swift\" lang=\"swift\"><span class=\"hljs-type\">PUZZLE</span> #<span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">100000</span>\n<span class=\"hljs-number\">000000</span>\n<span class=\"hljs-number\">000000</span>\n<span class=\"hljs-number\">000000</span>\n<span class=\"hljs-number\">000000</span>\n== press ==\n<span class=\"hljs-number\">000111</span>\n<span class=\"hljs-number\">101010</span>\n<span class=\"hljs-number\">101100</span>\n<span class=\"hljs-number\">001000</span>\n<span class=\"hljs-number\">110000</span>\n</code></pre><p>可以看懂只要按下全部位置对应为<code>1</code>的按钮就可以将所有灯都打开了, 我们来试一下.</p>\n<img style=\"margin: clear: both; display: block; margin:auto; 0;\" width=\"375\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/19/163742e8e6a94792?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"745\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;745&quot; height=&quot;1280&quot;&gt;&lt;/svg&gt;\">\n<h4 class=\"heading\" data-id=\"heading-5\">更新算法</h4>\n<p>为了不用每次都跑到另一个程序去运行算法, 我新增了<code>Hint</code>提示功能, 每盘游戏都可以点击提示, 看到提示显示的深色按钮点击对应位置的灯, 即可点亮所有的灯.</p>\n<p></p><figure><img class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/19/163766d2d49f0f26?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1240\" data-height=\"788\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1240&quot; height=&quot;788&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>添加这个功能其实也很简单, 只需要新建一个<code>Popver</code>控制器即可, 使用对应算法, 映射到<code>向量</code>即可.</p>\n<pre><code class=\"hljs swift\" lang=\"swift\"><span class=\"hljs-keyword\">import</span> UIKit\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HintViewController</span>: <span class=\"hljs-title\">UIViewController</span> </span>{\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">viewDidLayoutSubviews</span><span class=\"hljs-params\">()</span></span> {\n        <span class=\"hljs-keyword\">super</span>.viewDidLayoutSubviews()\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> fittedSize = topLevelView?.sizeThatFits(<span class=\"hljs-type\">UILayoutFittingCompressedSize</span>) {\n            preferredContentSize = <span class=\"hljs-type\">CGSize</span>(width: fittedSize.width + <span class=\"hljs-number\">30</span>, height: fittedSize.height + <span class=\"hljs-number\">30</span>)\n        }\n    }\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">viewDidLoad</span><span class=\"hljs-params\">()</span></span> {\n        <span class=\"hljs-keyword\">super</span>.viewDidLoad()\n        <span class=\"hljs-keyword\">if</span> presentationController <span class=\"hljs-keyword\">is</span> <span class=\"hljs-type\">UIPopoverPresentationController</span> {\n            view.backgroundColor = .clear\n        }        \n    }\n    <span class=\"hljs-meta\">@IBOutlet</span> <span class=\"hljs-keyword\">var</span> hints: [<span class=\"hljs-type\">UIButton</span>]! {\n        <span class=\"hljs-keyword\">didSet</span> {\n            <span class=\"hljs-keyword\">for</span> (index, hint) <span class=\"hljs-keyword\">in</span> hints.enumerated() {\n                hint.setBackgroundImage(<span class=\"hljs-type\">UIColor</span>.yellow.toImage, <span class=\"hljs-keyword\">for</span>: .normal)\n                hint.setBackgroundImage(<span class=\"hljs-type\">UIColor</span>.darkGray.toImage, <span class=\"hljs-keyword\">for</span>: .selected)\n                hint.isSelected = switchs?.hints[index] == <span class=\"hljs-number\">1</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>\n            }\n        }\n    }\n    <span class=\"hljs-meta\">@IBOutlet</span> <span class=\"hljs-keyword\">weak</span> <span class=\"hljs-keyword\">var</span> topLevelView: <span class=\"hljs-type\">UIStackView</span>!\n    <span class=\"hljs-keyword\">var</span> switchs: <span class=\"hljs-type\">LightSwitch</span>?\n}\n\n</code></pre><p>新增控制器, 就是显示提示的控制器</p>\n<pre><code class=\"hljs swift\" lang=\"swift\">    <span class=\"hljs-meta\">@IBOutlet</span> <span class=\"hljs-keyword\">weak</span> <span class=\"hljs-keyword\">var</span> hintButton: <span class=\"hljs-type\">UIButton</span>!\n    \n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">prepare</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">for</span> segue: UIStoryboardSegue, sender: Any?)</span></span> {\n        <span class=\"hljs-keyword\">if</span> segue.identifier == <span class=\"hljs-string\">\"Show Hint\"</span>, <span class=\"hljs-keyword\">let</span> destination = segue.destination.contents <span class=\"hljs-keyword\">as</span>? <span class=\"hljs-type\">HintViewController</span>,\n            <span class=\"hljs-keyword\">let</span> ppc = destination.popoverPresentationController {\n            ppc.delegate = <span class=\"hljs-keyword\">self</span>\n            ppc.sourceRect = hintButton.bounds\n            destination.switchs = switchs\n        }\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">adaptivePresentationStyle</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">for</span> controller: UIPresentationController, traitCollection: UITraitCollection)</span></span> -&gt; <span class=\"hljs-type\">UIModalPresentationStyle</span> {\n        <span class=\"hljs-keyword\">return</span> .<span class=\"hljs-keyword\">none</span>\n    }\n\n</code></pre><p>原先控制器的<code>Segue</code>设置, 让<code>iphone</code>默认不适配</p>\n<pre><code class=\"hljs swift\" lang=\"swift\">    <span class=\"hljs-keyword\">mutating</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">guess</span><span class=\"hljs-params\">()</span></span> -&gt; <span class=\"hljs-type\">Bool</span> {\n        <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;matrix.rows {\n            <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;matrix.columns + <span class=\"hljs-number\">1</span> {\n                press[r + <span class=\"hljs-number\">1</span>][<span class=\"hljs-built_in\">c</span>] = (puzzle[r][<span class=\"hljs-built_in\">c</span>] + press[r][<span class=\"hljs-built_in\">c</span>] + press[r - <span class=\"hljs-number\">1</span>][<span class=\"hljs-built_in\">c</span>] + press[r][<span class=\"hljs-built_in\">c</span> - <span class=\"hljs-number\">1</span>] + press[r][<span class=\"hljs-built_in\">c</span> + <span class=\"hljs-number\">1</span>]) % <span class=\"hljs-number\">2</span>\n            }\n        }\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">c</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;matrix.columns + <span class=\"hljs-number\">1</span> {\n            <span class=\"hljs-keyword\">if</span> (press[matrix.rows][<span class=\"hljs-built_in\">c</span> - <span class=\"hljs-number\">1</span>] + press[matrix.rows][<span class=\"hljs-built_in\">c</span>] + press[matrix.rows][<span class=\"hljs-built_in\">c</span> + <span class=\"hljs-number\">1</span>] + press[matrix.rows - <span class=\"hljs-number\">1</span>][<span class=\"hljs-built_in\">c</span>]) % <span class=\"hljs-number\">2</span> != puzzle[matrix.rows][<span class=\"hljs-built_in\">c</span>] {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    }\n    \n    <span class=\"hljs-keyword\">mutating</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">enumerate</span><span class=\"hljs-params\">()</span></span> {\n        <span class=\"hljs-keyword\">var</span> <span class=\"hljs-built_in\">c</span> = <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-number\">_</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..&lt;matrix.columns + <span class=\"hljs-number\">1</span> {\n            press[<span class=\"hljs-number\">1</span>][<span class=\"hljs-built_in\">c</span>] = <span class=\"hljs-number\">0</span>\n            <span class=\"hljs-keyword\">while</span> (guess() == <span class=\"hljs-literal\">false</span>) {\n                press[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>] += <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-built_in\">c</span> = <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">while</span> press[<span class=\"hljs-number\">1</span>][<span class=\"hljs-built_in\">c</span>] &gt; <span class=\"hljs-number\">1</span> {\n                    press[<span class=\"hljs-number\">1</span>][<span class=\"hljs-built_in\">c</span>] = <span class=\"hljs-number\">0</span>\n                    <span class=\"hljs-built_in\">c</span> += <span class=\"hljs-number\">1</span>\n                    press[<span class=\"hljs-number\">1</span>][<span class=\"hljs-built_in\">c</span>] += <span class=\"hljs-number\">1</span>\n                }\n            }\n            <span class=\"hljs-built_in\">c</span> += <span class=\"hljs-number\">1</span>\n        }\n    }\n</code></pre><p>在<code>Model</code>中加入核心算法即可</p>\n<img style=\"margin: clear: both; display: block; margin:auto; 0;\" width=\"375\" class=\"lazyload inited\" src=\"https://user-gold-cdn.xitu.io/2018/5/19/163766d2d487096e?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"745\" data-height=\"1280\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;745&quot; height=&quot;1280&quot;&gt;&lt;/svg&gt;\">\n<p>这个<code>Demo</code>可能是全网唯一的<code>熄灯问题</code>的<code>UI</code>版本吧, 给自己一个赞~</p>\n<p>经过好几次测试, 可以看见, <code>算法是正确</code>的, 我也学到了这个算法<code>背后的思维</code>, 更通过了写了一个<code>Demo</code>来证明了算法的正确性. 这个<code>Demo</code>的难点在于<code>向量</code>和<code>矩阵</code>之间的互相转换, 这里为什么不说<code>一维数组</code>和<code>二维数组</code>呢? , 原因在于<code>吴恩达</code>的机器学习课程中也教会了我一些比较厉害的算法, 比如<code>梯度下降</code>之类的.</p>\n<p>好了, 现在写文章没有之前频繁了, 原因在于之前那些文章都<code>太水</code>, <code>太肤浅</code>, 写了对自己也没有太大的意义, 被人看到也只会觉得是垃圾而已... 所以在我<code>第五阶段的学习</code>后, 希望能够有机会进入一家大厂继续深造吧!</p>\n<p>最后 本文中所有的源码都可以在github上找到:</p>\n<blockquote>\n<p>GitHub Repo：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FcoderZsq%2FcoderZsq.target.swift\" rel=\"nofollow noopener noreferrer\">coderZsq.target.swift</a>\n<br>Follow: <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FcoderZsq\" rel=\"nofollow noopener noreferrer\">coderZsq · GitHub</a>\n<br>Resume: <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fcoderzsq.github.io%2FcoderZsq.webpack.js%2F%23%2F\" rel=\"nofollow noopener noreferrer\">coderzsq.github.io/coderZsq.we…</a></p>\n</blockquote>\n"
    }
  ],
  "bplist": [
    {
      "bpid": 1,
      "uname": "WebNotes",
      "job": "CTO",
      "company": "有码科技",
      "bptime": "5小时前",
      "uimg": "https://user-gold-cdn.xitu.io/2017/8/14/e60cd398bae4a70faa1a72835eec379f?imageView2/1/w/100/h/100/q/85/interlace/1",
      "bpcon": "<div data-v-8dac9d0e=\"\" class=\"pin-content-row\"><div data-v-7f9a139a=\"\" data-v-8dac9d0e=\"\" class=\"content-box content-box\"><!----><span data-v-7f9a139a=\"\">脉脉上有人爆料陆奇即将入职小米。</span><div data-v-7f9a139a=\"\" class=\"limit-ctl-box\"><!----><!----></div></div></div><div data-v-8dac9d0e=\"\" class=\"pin-image-row\"><div data-v-5296fd9a=\"\" data-v-8dac9d0e=\"\" class=\"image-box image-box col-1\"><div data-v-5296fd9a=\"\" class=\"image\" style=\"background-image: url(&quot;https://user-gold-cdn.xitu.io/2018/5/28/163a4cd074e3f38e?imageView2/1/w/460/h/316/q/85/format/jpg/interlace/1&quot;);\"><div data-v-5296fd9a=\"\" class=\"ratio-holder\" style=\"padding-top: 68.6957%;\"></div><!----></div><div data-v-f0e3c22e=\"\" data-v-5296fd9a=\"\" class=\"image-viewer-box\"><!----></div></div></div>",
      "praise": "1",
      "comment": []
    },
    {
      "bpid": 2,
      "uname": "稀土君",
      "job": "最酷的",
      "company": "稀土",
      "bptime": "1小时前",
      "uimg": "https://user-gold-cdn.xitu.io/2016/11/29/40f695879c4acce775aba0046bde0bc7?imageView2/1/w/100/h/100/q/85/interlace/1",
      "praise": "14",
      "comment": [
        {
          "username" : "优弧",
          "commentImg" : "https://avatars.githubusercontent.com/u/8282645?v=3",
          "commentTime" : "1小时前",
          "admire":"0",
          "commentText" : "牛逼。"
        }
      ],
      "bpcon": "<div data-v-8dac9d0e=\"\" class=\"pin-content-row\"><div data-v-7f9a139a=\"\" data-v-8dac9d0e=\"\" class=\"content-box content-box\"><a data-v-7f9a139a=\"\" href=\"/topic/5abb6287092dcb4620ca3323\" target=\"_blank\" rel=\"\" class=\"topic-title\">#下班打卡#</a><span data-v-7f9a139a=\"\">Web 端沸点已上线，欢迎反馈问题~</span><div data-v-7f9a139a=\"\" class=\"limit-ctl-box\"><!----><!----></div></div></div><div data-v-8dac9d0e=\"\" class=\"pin-image-row\"><div data-v-5296fd9a=\"\" data-v-8dac9d0e=\"\" class=\"image-box image-box col-1\"><div data-v-5296fd9a=\"\" class=\"image\" style=\"background-image: url(&quot;https://user-gold-cdn.xitu.io/2018/5/8/1634023759083c90?imageView2/1/w/460/h/336/q/85/format/jpg/interlace/1&quot;);\"><div data-v-5296fd9a=\"\" class=\"ratio-holder\" style=\"padding-top: 73.2%;\"></div><!----></div><div data-v-f0e3c22e=\"\" data-v-5296fd9a=\"\" class=\"image-viewer-box\"><!----></div></div></div>"
    },
    {
      "bpid": 3,
      "uname": "阴明",
      "job": "搬砖",
      "company": "掘金",
      "bptime": "8小时前",
      "uimg": "https://user-gold-cdn.xitu.io/2018/3/14/162242895e80ca5f?imageView2/1/w/100/h/100/q/85/interlace/1",
      "praise": "5",
      "comment": [
        {
          "username" : "膜法小编",
          "commentImg" : "https://user-gold-cdn.xitu.io/2017/12/15/160584314593c258?imageView2/1/w/100/h/100/q/85/interlace/1",
          "commentTime" : "3小时前",
          "admire":"0",
          "commentText" : "立马就爆出漏洞，用 Excel 挖矿……"
        }
      ],
      "bpcon": "<div data-v-8dac9d0e=\"\" class=\"pin-content-row\"><div data-v-7f9a139a=\"\" data-v-8dac9d0e=\"\" class=\"content-box content-box\"><!----><span data-v-7f9a139a=\"\">Excel 支持 JavaScript 自定义脚本了，此外还有 ML 等功能\n微软最近在开发者服务上确实越来越好，给力！</span><div data-v-7f9a139a=\"\" class=\"limit-ctl-box\"><!----><!----></div></div></div><div data-v-8dac9d0e=\"\" class=\"pin-link-row\"><a data-v-c07c0cd2=\"\" data-v-8dac9d0e=\"\" class=\"link-box link-box\" href=\"https://dev.office.com/blogs/azure-machine-learning-javascript-custom-functions-and-power-bi-custom-visuals-further-expand-developers-capabilities-with-excel\" rel=\"nofollow noopener noreferrer\" target=\"_blank\"><div data-v-c07c0cd2=\"\" class=\"link-info-box\"><div data-v-c07c0cd2=\"\" class=\"link-title\">Azure Machine Learning, JavaScript Custom Functions, and Power BI Custom Visuals Further Expand Developers Capabilities with Excel</div><div data-v-c07c0cd2=\"\" class=\"link-domain ellipsis\">dev.office.com</div></div><div data-v-c07c0cd2=\"\" class=\"link-thumb\" style=\"background-image: url(&quot;https://mirror-gold-cdn.xitu.io/16343d004b670f09b08&quot;);\"></div></a></div>"
    },
    {
      "bpid": 4,
      "uname": "阴明",
      "job": "搬砖",
      "company": "掘金",
      "bptime": "13小时前",
      "uimg": "https://user-gold-cdn.xitu.io/2018/3/14/162242895e80ca5f?imageView2/1/w/100/h/100/q/85/interlace/1",
      "praise": "20",
      "comment": [],
      "bpcon": "<div data-v-8dac9d0e=\"\" class=\"pin-content-row\"><div data-v-7f9a139a=\"\" data-v-8dac9d0e=\"\" class=\"content-box content-box\"><a data-v-7f9a139a=\"\" href=\"/topic/5b0a7cb1092dcb32e10404f2\" target=\"_blank\" rel=\"\" class=\"topic-title\">#今天学到了#</a><span data-v-7f9a139a=\"\">IE 8 vs Chrome\n你都不敢相信在电视上我看到了什么 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fm.weibo.cn%2F2213841422%2F4244358469032765\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://m.weibo.cn/2213841422/4244358469032765</a></span><div data-v-7f9a139a=\"\" class=\"limit-ctl-box\"><!----><!----></div></div></div><div data-v-8dac9d0e=\"\" class=\"pin-image-row\"><div data-v-5296fd9a=\"\" data-v-8dac9d0e=\"\" class=\"image-box image-box col-1\"><div data-v-5296fd9a=\"\" class=\"image\" style=\"background-image: url(&quot;https://user-gold-cdn.xitu.io/2018/5/27/163a1ecb436308ed?imageView2/1/w/460/h/365/q/85/format/jpg/interlace/1&quot;);\"><div data-v-5296fd9a=\"\" class=\"ratio-holder\" style=\"padding-top: 79.3778%;\"></div><!----></div><div data-v-f0e3c22e=\"\" data-v-5296fd9a=\"\" class=\"image-viewer-box\"><!----></div></div></div>"
    }
  ]
}
